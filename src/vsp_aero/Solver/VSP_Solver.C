//
// This file is released under the terms of the NASA Open Source Agreement (NOSA)
// version 1.3 as detailed in the LICENSE file which accompanies this software.
//
//////////////////////////////////////////////////////////////////////

#include "VSP_Solver.H"

#include "START_NAME_SPACE.H"

/*##############################################################################
#                                                                              #
#                      Allocate space for statics                              #
#                                                                              #
##############################################################################*/

    double VSP_SOLVER::FarAway_ = 5.;
    
/*##############################################################################
#                                                                              #
#                                VSP_SOLVER constructor                        #
#                                                                              #
##############################################################################*/

VSP_SOLVER::VSP_SOLVER(void)
{

    // Use init routine

    init();

}

/*##############################################################################
#                                                                              #
#                                   VSP_SOLVER init                            #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::init(void)
{

    int i;

    Verbose_ = 0;
    
    FirstTimeSetup_ = 1;
    
    FirstTimeGradientSetup_ = 1;
 
    DoSymmetryPlaneSolve_ = 0;

    SearchID_ = NULL;

    SaveRestartFile_ = 0;
    
    JacobiRelaxationFactor_ = 0.25;

    DumpGeom_ = 0;

    CurrentWakeIteration_ = 0;

    ImplicitWake_ = 0;

    ImplicitWakeStartIteration_ = 0;

    Clo_2d_ = 0.;
        
    Clmax_2d_ = 1.0;
    
    MinStallFactor_ = 1.;
         
    NumberOfKelvinConstraints_ = 0;
    
    Write2DFEMFile_ = 0;
    
    WriteTecplotFile_ = 0;
    
    TimeAccurate_ = 0;
        
    StartFromSteadyState_ = 0;
    
    DeltaTime_ = 0.;
    
    TimeAnalysisType_ = 0;

    NumberOfTimeSteps_ = 1;
    
    StartAveragingTimeStep_ = 1;
    
    NumberOfTimeSamples_ = 0;
    
    ReducedFrequency_ = 0.0;
    
    Unsteady_AngleRate_ = 0.;
    
    Unsteady_Angle_ = 0.;
    
    Unsteady_AngleMax_ = 0.;
    
    Unsteady_H_ = 0.;
    
    Unsteady_HMax_ = 0.;
    
    Preconditioner_ = MATCON;

    UpdateMatrixPreconditioner_ = 0;
    
    UseWakeNodeMatrixPreconditioner_ = 0;

    snprintf(CaseString_,sizeof(CaseString_)*sizeof(char),"No Comment");

    AngleOfAttackZero_ = 0.;
    
    AngleOfBetaZero_ = 0.;   

    RotorFile_ = NULL;

    GroupFile_ = NULL;
        
    NoiseAnalysis_ = 0;
    
    SteadyStateNoise_ = 0;
    
    NoiseInterpolation_ = NOISE_QUINTIC_HERMITE_INTERPOLATION;
    
    KarmanTsienCorrection_ = 0.;
    
    KTResidual_[1] = 0.;
    
    LastMach_ = -1.;
    
    KelvinLambda_ = 1.e-7;

    GMRESTightConvergence_ = 0;
    
    PanelSpanWiseLoading_ = 1;
    
    AveragingHasStarted_ = 0;

    NumberOfAveragingSets_ = 0;
    
    DoAdjointSolve_ = 0;
    
    AdjointMatrixSolve_ = 0;
    
    OptimizationSolve_ = 0;
    
    NumberOfUnsteadyAdjointCases_ = 0;
    
    CreateHighLiftFile_ = 0;

    NumberOfSurveyTimeSteps_ = 0;
    
    NumberofSurveyPoints_ = 0;
    
    SurveyPointsStartTime_ = 0.;
    
    DoSolutionInterrogation_ = 0;
    
    NumberOfQuadTrees_ = 0;
    
    QuadTreeList_ = NULL;
    
    NumberOfEngineFaces_ = 0;
   
    SurfaceIsOnEngineFace_ = NULL;
    
    Vmax_ = 0.;
    
    WakeRelax_ = 1.;

    DoRestart_ = 0;
    
    RestartFromPreviousSolve_ = 0;
    
    CoreSizeFactor_ = 1.;

    DoVortexStretching_ = 0;
    
    ForwardGMRESConvergenceFactor_ = 1.;
    
    AdjointGMRESConvergenceFactor_ = 1.;

    NonLinearConvergenceFactor_ = 1.;

    Psi_       = NULL;
    PsiT_pR_pMesh_  = NULL;
    pF_pMesh_  = NULL;
    pF_pSoln_  = NULL;

    StallModelIsOn_ = 0;
   
    NumberOfThreads_ = 1;

    CFox_ = 0.;
    CFoy_ = 0.;
    CFoz_ = 0.;

    CLo_ = 0.;
    CSo_ = 0.;
    CDo_ = 0.;
    
    CMox_ = 0.;
    CMoy_ = 0.;
    CMoz_ = 0.;
    
    NodalForces_ = NULL;
    
    SolveOnMGLevel_ = 0;
   
    AdjointSolutionForceType_ = ADJOINT_INVISCID_AND_VISCOUS_FORCES;
    
    DoAdjointSolveForThisForceMomentCase_[1] = 1;
    DoAdjointSolveForThisForceMomentCase_[2] = 1;
    DoAdjointSolveForThisForceMomentCase_[3] = 1;
    DoAdjointSolveForThisForceMomentCase_[4] = 1;
    DoAdjointSolveForThisForceMomentCase_[5] = 1;
    DoAdjointSolveForThisForceMomentCase_[6] = 1;
    
    FreezeMultiPoleAtIteration_ = 100000;
    
    FreezeWakeAtIteration_ = 100000;
    
    FreezeWakeRootVortices_ = 0;
    
    QuadTreeBufferLevels_ = 0;
    
    NoiseAnalysis_= 0;
    NoiseTime_= 0;
    NumberOfNoiseTimeSteps_= 0;
    SteadyStateNoise_= 0;
    NoiseInterpolation_= 0;
    
    NoiseDeltaTime_ = 0.;
    NoiseTimeShift_ = 0.;
    CurrentNoiseTime_ = 0.;
    
    NumberOfRotors_ = 0;
    
    NumberOfControlGroups_ = 0;
    
    // Debug stuff
    
    UnsteadyFDTest_ = 0;
    
    // Adjoint components for adjoint solves 

    for ( i = 1 ; i < 10000 ; i++ ) {
       
       UserAdjointComponentList_[i] = 1;
       
    }

    int NumberOfThreads = omp_get_max_threads();
    
}

/*##############################################################################
#                                                                              #
#                                  VSP_SOLVER Copy                             #
#                                                                              #
##############################################################################*/

VSP_SOLVER::VSP_SOLVER(const VSP_SOLVER &Solver)
{

    init();

    // Just * use the operator = code

    *this = Solver;

}

/*##############################################################################
#                                                                              #
#                                 VSP_SOLVER operator=                         #
#                                                                              #
##############################################################################*/

VSP_SOLVER& VSP_SOLVER::operator=(const VSP_SOLVER &MGSolver)
{

    printf("VSP_SOLVER operator= not implemented! \n");
    exit(1);
    
    return *this;

}

/*##############################################################################
#                                                                              #
#                              VSP_SOLVER destructor                           #
#                                                                              #
##############################################################################*/

VSP_SOLVER::~VSP_SOLVER(void)
{


}

/*##############################################################################
#                                                                              #
#                                   VSP_SOLVER Setup                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::Setup(void)
{
  
    int c, i, j, k, p, cpu, NumberOfStations, MaxEdges, Level, Hits, CompSurfs;
    int NumSteps_1, NumSteps_2, NumberOfTimeSamples, ThereIsARotor;
    int UserNumberOfTimeSteps, *ComponentInThisGroup, Surf, *WakeSurfaceUsed;
    double Scale_X, Scale_Y, Scale_Z, FarDist, Period, S[3], Mag;
    double MinRotorDiameter, TimeSetByFastestRotor, StreamDist;
    double SlatPer, SlatMach, dx, dy, dz, CutOff;
    char GroupFileName[MAX_CHAR_SIZE], DumChar[MAX_CHAR_SIZE], HighLiftFileName[MAX_CHAR_SIZE], SurfaceName[MAX_CHAR_SIZE];
    FILE *GroupFile, *HighLiftFile;

    // Set the CG for the overall vehicle group
    
    VSPGeom().ComponentGroupList(0).OVec(0) = XYZcg_[0];
    VSPGeom().ComponentGroupList(0).OVec(1) = XYZcg_[1];
    VSPGeom().ComponentGroupList(0).OVec(2) = XYZcg_[2];
        
    // Copy over data
    
    MGLevel_ = 1;
    
    if ( SolveOnMGLevel_ > 0 ) MGLevel_ = SolveOnMGLevel_;
    
    NumberOfMGLevels_ = VSPGeom().NumberOfGridLevels();

    // Size the lists and determine the size of the domain
    
    Xmin_ = 1.e9;
    Xmax_ = -Xmin_;

    Ymin_ = 1.e9;
    Ymax_ = -Ymin_;

    Zmin_ = 1.e9;
    Zmax_ = -Zmin_;

    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; j++ ) {

       Xmin_ = MIN(Xmin_,VSPGeom().Grid(MGLevel_).NodeList(j).x());
       Xmax_ = MAX(Xmax_,VSPGeom().Grid(MGLevel_).NodeList(j).x());

       Ymin_ = MIN(Ymin_,VSPGeom().Grid(MGLevel_).NodeList(j).y());
       Ymax_ = MAX(Ymax_,VSPGeom().Grid(MGLevel_).NodeList(j).y());

       Zmin_ = MIN(Zmin_,VSPGeom().Grid(MGLevel_).NodeList(j).z());
       Zmax_ = MAX(Zmax_,VSPGeom().Grid(MGLevel_).NodeList(j).z());

    }
    
    // Determine how far to allow wakes to adapt... beyond this the wakes go straight off to
    // 'infinity' in the free stream direction
    
    Scale_X = Scale_Y = Scale_Z = 1.;
    
    if ( DoSymmetryPlaneSolve_ ) Scale_Y = 2.;
    
    FarDist = MAX3(Scale_X*(Xmax_ - Xmin_), Scale_Y*(Ymax_-Ymin_), Scale_Z*(Zmax_-Zmin_));
    
    dx = Xmax_ - Xmin_;
    dy = Ymax_ - Ymin_;
    dz = Zmax_ - Zmin_;

    printf("Xmax_ - Xmin_: %f \n",dx);
    printf("Ymax_ - Ymin_: %f \n",dy);
    printf("Zmax_ - Zmin_: %f \n",dz);
    printf("\n");

    // Distance along free stream direction
    
    StreamDist = (Xmax_ - Xmin_);

    // Surface edge cut off distance tolerance for the edges
    
    CutOff = 1.e9;

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
   
       CutOff = MIN(CutOff,VSPGeom().Grid(MGLevel_).LoopList(i).Area());
       
    }
    
    printf("Minimum loop area: %e \n",CutOff);

    CutOff = 1.e-4 * sqrt(CutOff);
 
    if ( CutOff <= 1.e-10 ) CutOff = 1.e-10;

    VSPGeom().Grid(MGLevel_).EdgeList(1).SetTolerance(CutOff);
 
    printf("Setting surface edge cutoff to: %e \n",CutOff);

    printf("Number Of Trailing Vortices: %d \n",VSPGeom().Grid(MGLevel_).NumberOfKuttaNodes());

    // Check for damping analysis runs
    
    if ( TimeAccurate_ ) {
       
       if ( TimeAnalysisType_ == P_ANALYSIS ||
            TimeAnalysisType_ == Q_ANALYSIS ||
            TimeAnalysisType_ == R_ANALYSIS  ) {

          // Determine angular rates and reduced frequency for damping analyses

          DeltaTime_ = (VSPGeom().FarFieldDist()/8.) / ( Vinf_ );
       
          Unsteady_AngleRate_ = 2. * 2. * PI / (DeltaTime_ * NumberOfTimeSteps_);

          if ( TimeAnalysisType_ == P_ANALYSIS) ReducedFrequency_ = 0.5 * Unsteady_AngleRate_ * Bref_ / Vinf_;
          if ( TimeAnalysisType_ == Q_ANALYSIS) ReducedFrequency_ = 0.5 * Unsteady_AngleRate_ * Cref_ / Vinf_;
          if ( TimeAnalysisType_ == R_ANALYSIS) ReducedFrequency_ = 0.5 * Unsteady_AngleRate_ * Bref_ / Vinf_;
          
          // Over ride any user set inputs...
          
          for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {

             VSPGeom().ComponentGroupList(c).GeometryIsARotor() = 0;

             VSPGeom().ComponentGroupList(c).GeometryIsDynamic() = PERIODIC_RATES;
                                       
             VSPGeom().ComponentGroupList(c).Omega() = Unsteady_AngleRate_;
             VSPGeom().ComponentGroupList(c).AngleMax() = Unsteady_AngleMax_;
                                      
             VSPGeom().ComponentGroupList(c).OVec(0) = XYZcg_[0];
             VSPGeom().ComponentGroupList(c).OVec(1) = XYZcg_[1];
             VSPGeom().ComponentGroupList(c).OVec(2) = XYZcg_[2];
             
             // Roll analysis
             
             if ( TimeAnalysisType_ == P_ANALYSIS ) {
             
               VSPGeom().ComponentGroupList(c).RVec(0) = -1.;
               VSPGeom().ComponentGroupList(c).RVec(1) =  0.;
               VSPGeom().ComponentGroupList(c).RVec(2) =  0.;
               
             }
             
             // Pitch analysis
             
             else if ( TimeAnalysisType_ == Q_ANALYSIS ) {
                
               VSPGeom().ComponentGroupList(c).RVec(0) =  0.;
               VSPGeom().ComponentGroupList(c).RVec(1) =  1.;
               VSPGeom().ComponentGroupList(c).RVec(2) =  0.;
               
             }
             
             // Yaw analysis
             
             else if ( TimeAnalysisType_ == R_ANALYSIS ) {
                
               VSPGeom().ComponentGroupList(c).RVec(0) =  0.;
               VSPGeom().ComponentGroupList(c).RVec(1) =  0.;
               VSPGeom().ComponentGroupList(c).RVec(2) = -1.;
               
             }
             
             else {
                
                printf("Unknown time analysis type! \n");fflush(NULL);
                exit(1);
                
             }
             
          }


       }

    }

    // Determine the slowest and fastest rotor... if there is one at all
    
    WopWopOmegaMax_ = -1.e9;
    WopWopOmegaMin_ =  1.e9;
    
    ThereIsARotor = 0;
    
    for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
    
       if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) {

          if ( ABS(VSPGeom().ComponentGroupList(c).Omega()) < WopWopOmegaMin_ ) {
    
             WopWopOmegaMin_ = ABS(VSPGeom().ComponentGroupList(c).Omega());
             
          }
                    
          if ( ABS(VSPGeom().ComponentGroupList(c).Omega()) > WopWopOmegaMax_ ) {
    
             WopWopOmegaMax_ = ABS(VSPGeom().ComponentGroupList(c).Omega());
             
          }
          
          ThereIsARotor = 1;
                    
       }
       
    }
       
    // Set time step, number of time steps, and allocate space for force and moment tables
    
    if ( TimeAccurate_ ) {

       // Determine the smallest rotor
       
       MinRotorDiameter = 1.e9;
       
       for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
       
          if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) {

             if ( VSPGeom().ComponentGroupList(c).RotorDiameter() < MinRotorDiameter ) {
       
                MinRotorDiameter = VSPGeom().ComponentGroupList(c).RotorDiameter();
                
             }
                       
          }
          
       }
            
       // Calculate a default time step if user did not set it
      
       if ( DeltaTime_ <= 0. ) {

          TimeSetByFastestRotor = 0.;
          
          if ( WopWopOmegaMax_ > 0. ) {
             
             TimeSetByFastestRotor = ABS(DeltaTime_);

             // Time step based on rotation rate
             
             DeltaTime_ = 18. * TORAD * ABS(DeltaTime_) / WopWopOmegaMax_; // 18 degrees per step... so 20 steps per rev
             
          }

          else {
             
             DeltaTime_ = 0.1*Cref_;
             
          }
          
       }

       // Calculate the number of time steps if user did not set it
       
       if ( NumberOfTimeSteps_ < 0 ) {
          
          UserNumberOfTimeSteps = NumberOfTimeSteps_;
                              
          // Slowest rotor, at least 2 rotations... but only if there's a spread in speeds from min to max omega
      
          NumSteps_1 = 0;
          
          if ( WopWopOmegaMax_ != WopWopOmegaMin_ ) {
             
             Period = 2.*PI / WopWopOmegaMin_;
             
             NumSteps_1 = float( 2.*Period / DeltaTime_ ) + 1;
             
          }
          
          // Fastest rotor does ABS(NumberOfTimeSteps_) revolutions
          
          NumSteps_2 = 0;
 
          if ( TimeSetByFastestRotor > 0. ) {
             
             NumSteps_2 = (int) float( TimeSetByFastestRotor*ABS(NumberOfTimeSteps_)*20 );
             
             if ( (double) NumSteps_2 < float( TimeSetByFastestRotor*ABS(NumberOfTimeSteps_)*20 ) ) {
                
                NumSteps_2++;
                
             }
                 
          } 
             
          if ( NumSteps_1 > NumSteps_2 ) {
             
             NumberOfTimeSteps_ = NumSteps_1;
          
             printf("Setting number of time steps to %d based on slowest rotor making 2 rotations. \n",NumberOfTimeSteps_); fflush(NULL);
             
          }
          
          else {
             
             printf("Setting number of time steps to %d based on fastest rotor making %d rotations. \n",NumSteps_2,ABS(NumberOfTimeSteps_)); fflush(NULL);
             
             NumberOfTimeSteps_ = NumSteps_2;
          
          }
             
       }
       
       // If there are user survey points, we may need to calculate the start time
       
       if ( NumberofSurveyPoints_ > 0 ) {
          
          if ( NumberOfSurveyTimeSteps_ < 0 ) {
             
             if ( ThereIsARotor ) {
             
                Period = 2.*PI / WopWopOmegaMin_;
                
                SurveyPointsStartTime_ = DeltaTime_ * NumberOfTimeSteps_ - ABS(NumberOfSurveyTimeSteps_) * Period;
                
             }
             
             else {

                SurveyPointsStartTime_ = DeltaTime_ * NumberOfTimeSteps_ - ABS(NumberOfSurveyTimeSteps_) * DeltaTime_;
                
             } 
             
          }
          
       }  

       // Size the group forces and moment tables
       
       for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {

          NumberOfTimeSamples = NumberOfTimeSteps_;
          
          if ( NoiseAnalysis_ ) NumberOfTimeSamples = 181;
          
          VSPGeom().ComponentGroupList(c).SizeForceAndMomentsTables(NumberOfTimeSamples);

       }       

       printf("Used FarFieldDist_ of: %f to calculate time step \n",VSPGeom().FarFieldDist()); fflush(NULL);
           
       printf("TimeAnalysisType_: %d \n",TimeAnalysisType_); fflush(NULL);
       
       printf("DeltaTime_: %f \n",DeltaTime_); fflush(NULL);

       printf("ReducedFrequency_: %f \n",ReducedFrequency_); fflush(NULL);
       
       printf("Unsteady_AngleRate_: %f \n",Unsteady_AngleRate_); fflush(NULL);

    }
    
    else {
       
       for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
          
          VSPGeom().ComponentGroupList(c).SizeForceAndMomentsTables();
          
       }
    
    }

    // Initialize some ref data for each component
    
    for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
    
       VSPGeom().ComponentGroupList(c).Density() = Density_;
       VSPGeom().ComponentGroupList(c).Vref() = Vref_;
       VSPGeom().ComponentGroupList(c).Sref() = Sref_;
       VSPGeom().ComponentGroupList(c).Bref() = Bref_;
       VSPGeom().ComponentGroupList(c).Cref() = Cref_; 

    }   

    LoopIsOnBaseRegion_ = new int[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];

    zero_int_array(LoopIsOnBaseRegion_, VSPGeom().Grid(MGLevel_).NumberOfLoops());

    // VLM model
    
    if ( VSPGeom().ModelType() == VLM_MODEL ) {
       
       printf("Model type: VLM \n"); fflush(NULL);
 
       NumberOfKelvinConstraints_ = 0;


    }
    
    // Panel or mixed model
    
    else {
       
       printf("Model type: PANEL or MIXED \n"); fflush(NULL);       
       
       DetermineNumberOfKelvinConstrains();
    
    }

    // Calculate the total number of equations

    NumberOfEquations_ = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() 
                       + VSPGeom().NumberOfWakeResidualEquations() 
                       + VSPGeom().NumberOfStallResidualEquations();
                       
    if ( TimeAccurate_ ) NumberOfEquations_ += VSPGeom().NumberOfVortexStretchingRatioEquations();                  

    printf("Number Of Vortex Loop Equations: %d \n",VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());fflush(NULL); 
    printf("Number Of Wake Node Equations:   %d \n",VSPGeom().NumberOfWakeResidualEquations());fflush(NULL); 
    printf("Number Of Stall Equations:       %d \n",VSPGeom().NumberOfStallResidualEquations());fflush(NULL); 
    
    if ( TimeAccurate_ ) {
       
       printf("Number Of Vortex Stretching Equations:       %d \n",VSPGeom().NumberOfVortexStretchingRatioEquations());fflush(NULL); 

    }
    
    printf("Total Number Of Equations:       %d \n",NumberOfEquations_);fflush(NULL); 

    // Allocate space for the vortex edges and loops

    LocalBodySurfaceVelocityForLoop_ = new double*[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];  

    LocalBodySurfaceVelocityForEdge_ = new double*[VSPGeom().Grid(MGLevel_).NumberOfEdges() + 1];          
        
    Gamma_[0] = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];    
    Gamma_[1] = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];    
    Gamma_[2] = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];    
    
    DeltaGamma_ = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];  

    DeltaXYZ_ = new double[3*VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];  

    Diagonal_ = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];     

    zero_double_array(Gamma_[0], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[0][0] = 0.;   
    zero_double_array(Gamma_[1], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[1][0] = 0.;   
    zero_double_array(Gamma_[2], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[2][0] = 0.;   

    zero_double_array(Diagonal_, VSPGeom().Grid(MGLevel_).NumberOfLoops()); Diagonal_[0] = 0.;    

    zero_double_array(DeltaGamma_, VSPGeom().Grid(MGLevel_).NumberOfLoops());

    zero_double_array(DeltaXYZ_, 3*VSPGeom().Grid(MGLevel_).NumberOfNodes());
       
    Residual_ = new double[NumberOfEquations_ + 1];    
    
    MatrixVectorProduct_ = new double[NumberOfEquations_ + 1];        

    RightHandSide_ = new double[NumberOfEquations_ + 1];     
     
    MatrixVecTemp_ = new double[NumberOfEquations_ + 1];     

    Delta_ = new double[NumberOfEquations_ + 1];     
   
    zero_double_array(Residual_,      NumberOfEquations_); Residual_[0]      = 0.;
    zero_double_array(RightHandSide_, NumberOfEquations_); RightHandSide_[0] = 0.;
    zero_double_array(MatrixVecTemp_, NumberOfEquations_); RightHandSide_[0] = 0.;
    zero_double_array(Delta_,         NumberOfEquations_); Delta_[0] = 0.;
        
    if ( NoiseAnalysis_ || DoSolutionInterrogation_ ) {
       
       NumberOfNoiseInterpolationPoints_ = 9;
       
       for ( i = 0 ; i < NumberOfNoiseInterpolationPoints_ ; i++ ) {
          
          GammaNoise_[i] = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];    
    
          FxNoise_[i] = new double[VSPGeom().Grid(MGLevel_).NumberOfEdges() + 1];    
          FyNoise_[i] = new double[VSPGeom().Grid(MGLevel_).NumberOfEdges() + 1];    
          FzNoise_[i] = new double[VSPGeom().Grid(MGLevel_).NumberOfEdges() + 1];    
   
          dCpUnsteadyNoise_[i] = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];    
            
          UNoise_[i] = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];    
          VNoise_[i] = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];    
          WNoise_[i] = new double[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];    
   
          zero_double_array(GammaNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); GammaNoise_[i][0] = 0.;   
   
          zero_double_array(FxNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfEdges()); FxNoise_[i][0] = 0.;   
          zero_double_array(FyNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfEdges()); FyNoise_[i][0] = 0.;   
          zero_double_array(FzNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfEdges()); FzNoise_[i][0] = 0.;   
   
          zero_double_array(dCpUnsteadyNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); dCpUnsteadyNoise_[i][0] = 0.;   
   
          zero_double_array(UNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); UNoise_[i][0] = 0.;   
          zero_double_array(VNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); VNoise_[i][0] = 0.;   
          zero_double_array(WNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); WNoise_[i][0] = 0.;   
       
       }

    }

    NodalForces_ = new double*[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {

       NodalForces_[i] = new double[3];

    }

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
    
       LocalBodySurfaceVelocityForLoop_[i] = new double[3];

       // Zero out local body surface velocities
       
       LocalBodySurfaceVelocityForLoop_[i][0] = 0.;
       LocalBodySurfaceVelocityForLoop_[i][1] = 0.;
       LocalBodySurfaceVelocityForLoop_[i][2] = 0.;         

    }
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
       
       LocalBodySurfaceVelocityForEdge_[i] = new double[3];
       
       // Zero out local body surface velocities
       
       LocalBodySurfaceVelocityForEdge_[i][0] = 0.;
       LocalBodySurfaceVelocityForEdge_[i][1] = 0.;
       LocalBodySurfaceVelocityForEdge_[i][2] = 0.;       
       
    }           
    
    // Read in high lift setup file if it exists...
 
    snprintf(HighLiftFileName,sizeof(HighLiftFileName)*sizeof(char),"%s.HightLiftData",FileName_);
    
    if ( (HighLiftFile = fopen(HighLiftFileName, "r")) == NULL ) {
    
       printf("No high lift data file found... \n"); fflush(NULL);
       
    }    
    
    else {

       fgets(DumChar,MAX_CHAR_SIZE,HighLiftFile);
       
       while ( fgets(DumChar,MAX_CHAR_SIZE,HighLiftFile) != NULL ) {
          
          sscanf(DumChar,"%d %s %lf %lf",&Surf,SurfaceName,&SlatPer,&SlatMach);
          
          printf("Surface: %d, Named: %s ---> SlatPer: %lf with SlatMach: %lf \n",Surf,SurfaceName,SlatPer,SlatMach); fflush(NULL);

          VSPGeom().BoundaryConditionForSurface(Surf).HighLiftSlatPercentage() = SlatPer;
          VSPGeom().BoundaryConditionForSurface(Surf).HighLiftSlatMachDeploy() = SlatMach;    
  
       }
       
       fclose(HighLiftFile);
       
    }

    // Create vortex loop list

    Setup_VortexLoops();

    // Create vortex edge list
 
    Setup_VortexEdges();
             
    // Zero out stuff on this grid 

    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; j++ ) {

       VSPGeom().Grid(MGLevel_).LoopList(j).Gamma() = 0.;

    }
    
    // Allocate space if this is the first time through
    
    if ( FirstTimeSetup_ ) {
       
       StartTime_ = myclock();
  
       // Determine the maximum number of edges across all grid levels
       
       MaxEdges  = 0;
       
       for ( Level = 1 ; Level <= VSPGeom().NumberOfGridLevels() ; Level++ ) {
          
          MaxEdges += VSPGeom().Grid(Level).NumberOfEdges();
          
       }
       
       // Allocate space for temporary interaction lists... one per processor
       
#ifdef VSPAERO_OPENMP

       NumberOfThreads_ = omp_get_max_threads();

#else
       NumberOfThreads_ = 1;

#endif       

       SearchID_ = new int[NumberOfThreads_];

       EdgeIsUsed_ = new int**[NumberOfThreads_];
       
       LoopIsUsed_ = new int**[NumberOfThreads_];
    
       TempInteractionList_ = new INTERACTION_LISTS[NumberOfThreads_];
       
       LoopStackList_ = new STACK_ENTRY*[NumberOfThreads_];
      
       // Now size the list per processor
       
       for ( cpu = 0 ; cpu < NumberOfThreads_ ; cpu++ ) {
          
          SearchID_[cpu] = 0;

          EdgeIsUsed_[cpu] = new int*[VSPGeom().NumberOfGridLevels() + 1];
          
          LoopIsUsed_[cpu] = new int*[VSPGeom().NumberOfGridLevels() + 1];
          
          for ( Level = VSPGeom().NumberOfGridLevels() ; Level >= 1  ; Level-- ) {
           
             EdgeIsUsed_[cpu][Level] = new int[VSPGeom().Grid(Level).NumberOfEdges() + 1];
           
             zero_int_array(EdgeIsUsed_[cpu][Level], VSPGeom().Grid(Level).NumberOfEdges());
             
             LoopIsUsed_[cpu][Level] = new int[VSPGeom().Grid(Level).NumberOfLoops() + 1];
             
             zero_int_array(LoopIsUsed_[cpu][Level], VSPGeom().Grid(Level).NumberOfLoops());
             
          }
   
          // Temporary interaction list
        
          TempInteractionList_[cpu].EdgeInteractionList = new VSP_EDGE*[VSPGeom().Grid(MGLevel_).NumberOfEdges() + 1];

          TempInteractionList_[cpu].LoopInteractionList = new VSP_LOOP*[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];
                       
          MaxStackSize_ = 0;
   
          // Loop over all grid levels for this surface
          
          for ( Level = VSPGeom().NumberOfGridLevels() ; Level >= 1  ; Level-- ) {
   
             // Loop over all vortex loops
             
             MaxStackSize_ += VSPGeom().Grid(Level).NumberOfLoops();
            
          }
   
          LoopStackList_[cpu] = new STACK_ENTRY[MaxStackSize_ + 1];

       }

       // Create Matrix preconditioner
       
       if ( Preconditioner_ == MATCON && ! DumpGeom_ ) CreateMatrixPreconditionersDataStructure();  
             
       FirstTimeSetup_ = 0;
 
    }
    
    // If panel solver, or unsteady 
    
    CreateVorticityGradientDataStructure();

    // Write out high lift setup file...
 
    if ( CreateHighLiftFile_ ) {

       snprintf(HighLiftFileName,sizeof(HighLiftFileName)*sizeof(char),"%s.HightLiftData",FileName_);
       
       if ( (HighLiftFile = fopen(HighLiftFileName, "w")) == NULL ) {
   
          printf("Could not open the High Lift File file for output! \n"); fflush(NULL);
   
          exit(1);
   
       }    
                                     //1234567890 1234567890 1234567890 1234567890 1234567890 
       fprintf(HighLiftFile,"Surface       Name     SlatPer    SlatMach\n");
 
       for ( i = 1 ; i <= VSPGeom().NumberOfSurfaces() ; i++ ) {

          fprintf(HighLiftFile,"%d %s 0.0 0.3 \n",i,VSPGeom().SurfaceNameList(i));

       }
       
       fclose(HighLiftFile);
       
    }
    
    // Set up inlet / nozzles
    
    SurfaceIsOnEngineFace_ = new int[VSPGeom().NumberOfSurfaces() + 1];
    
    zero_int_array(SurfaceIsOnEngineFace_, VSPGeom().NumberOfSurfaces());
    
    printf("VSPGeom().Grid(MGLevel_).NumberOfLoops(): %d \n",VSPGeom().Grid(MGLevel_).NumberOfLoops()); fflush(NULL);
    
    printf("NumberOfEngineFaces_: %d \n",NumberOfEngineFaces_); fflush(NULL);
    
    printf("VSPGeom().NumberOfSurfaces(): %d \n",VSPGeom().NumberOfSurfaces()); fflush(NULL);
    
    if ( VSPGeom().SurfaceType() == VSPGEOM_SURFACE && VSPGeom().ModelType() == PANEL_MODEL ) {
       
       for ( i = 1 ; i <= NumberOfEngineFaces_ ; i++ ) {
          
          if ( EngineFace_[i].SurfaceID() <= 0 || EngineFace_[i].SurfaceID() > VSPGeom().NumberOfSurfaces() ) {
             
             printf("Error... engine %d points to non-existant surface: %d \n",i,EngineFace_[i].SurfaceID()); fflush(NULL);
             
          }
          
          else {
             
             SurfaceIsOnEngineFace_[EngineFace_[i].SurfaceID()] = i;

             EngineFace_[i].Density() = Density_;

             EngineFace_[i].Area() = 0.;
             
             for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; j++ ) {
                
                if ( VSPGeom().Grid(MGLevel_).LoopList(j).SurfaceID() == EngineFace_[i].SurfaceID() ) {
            
                   EngineFace_[i].Area() += VSPGeom().Grid(MGLevel_).LoopList(j).Area();
                   
                }
                
             }
             
          }
          
          printf("EngineFace_[%d].Area(): %f \n",i,EngineFace_[i].Area()); fflush(NULL);
          
       }
       
    }
 
    printf("Done with setup... \n");fflush(NULL);

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER ZeroSolutionState                             #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroSolutionState(void)
{
  
    int Level, i, j, k, Node, NumWakeNodes;
    
  
    zero_double_array(Gamma_[0], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[0][0] = 0.;
    zero_double_array(Gamma_[1], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[1][0] = 0.;
    zero_double_array(Gamma_[2], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[2][0] = 0.;
    zero_double_array(Delta_,    VSPGeom().Grid(MGLevel_).NumberOfLoops());    Delta_[0] = 0.;

    zero_double_array(Diagonal_, VSPGeom().Grid(MGLevel_).NumberOfLoops()); Diagonal_[0] = 0.;    

    zero_double_array(DeltaGamma_, VSPGeom().Grid(MGLevel_).NumberOfLoops());

    zero_double_array(DeltaXYZ_, 3*VSPGeom().Grid(MGLevel_).NumberOfNodes());

    zero_double_array(Residual_,      NumberOfEquations_); Residual_[0]      = 0.;
    zero_double_array(RightHandSide_, NumberOfEquations_); RightHandSide_[0] = 0.;
    zero_double_array(MatrixVecTemp_, NumberOfEquations_); RightHandSide_[0] = 0.;
    zero_double_array(Delta_,         NumberOfEquations_); Delta_[0] = 0.;
        
    if ( NoiseAnalysis_ || DoSolutionInterrogation_ ) {
       
       NumberOfNoiseInterpolationPoints_ = 9;
       
       for ( i = 0 ; i < NumberOfNoiseInterpolationPoints_ ; i++ ) {

          zero_double_array(GammaNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); GammaNoise_[i][0] = 0.;   
   
          zero_double_array(FxNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfEdges()); FxNoise_[i][0] = 0.;   
          zero_double_array(FyNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfEdges()); FyNoise_[i][0] = 0.;   
          zero_double_array(FzNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfEdges()); FzNoise_[i][0] = 0.;   
   
          zero_double_array(dCpUnsteadyNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); dCpUnsteadyNoise_[i][0] = 0.;   
   
          zero_double_array(UNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); UNoise_[i][0] = 0.;   
          zero_double_array(VNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); VNoise_[i][0] = 0.;   
          zero_double_array(WNoise_[i], VSPGeom().Grid(MGLevel_).NumberOfLoops()); WNoise_[i][0] = 0.;   
       
       }

    }

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       // Zero out local body surface velocities
       
       LocalBodySurfaceVelocityForLoop_[i][0] = 0.;
       LocalBodySurfaceVelocityForLoop_[i][1] = 0.;
       LocalBodySurfaceVelocityForLoop_[i][2] = 0.;         

    }
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {

       // Zero out local body surface velocities
       
       LocalBodySurfaceVelocityForEdge_[i][0] = 0.;
       LocalBodySurfaceVelocityForEdge_[i][1] = 0.;
       LocalBodySurfaceVelocityForEdge_[i][2] = 0.;       
       
    }    
    
    // Copy over stall factor data

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfKuttaEdges() ; i++ ) {
          
          VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() = 1.;
          
       }
       
    }

    // Propagate stall factors for each trailing vortex loop
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
          
          j = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaEdge();
                
          VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor() = 1.;
    
       }
    
    }      

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
   
          VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() = 1.;

       }
       
    }

    // Initialize vortex sheets to current time, time step
    // and store the current wake location
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       VSPGeom().VortexSheet(k).Time() = 0.;

       VSPGeom().VortexSheet(k).DeltaTime() = DeltaTime_;
       
       VSPGeom().VortexSheet(k).UpdateConvectedDistance();

    }
    
    // Update all the edges to the current time    

    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfEdges() ; j++ ) {
       
          VSPGeom().Grid(Level).EdgeList(j).TimeAccurate() = TimeAccurate_;

          VSPGeom().Grid(Level).EdgeList(j).Time() = 0.;
                                                  
       }
       
    }
    
}
  
/*##############################################################################
#                                                                              #
#              VSP_SOLVER DetermineNumberOfKelvinConstrains                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DetermineNumberOfKelvinConstrains(void)
{
   
    int i, j, k, FoundOne;
    int p, Loop, Loop1, Loop2, Found, Done, KelvinGroup;
    int Edge, StackSize, Next, *LoopStack;
    int Intersected, *NodeIsOnThinSurface, *KelvinGroupPerm, NewNumberOfKelvinGroups;
    double Dot, MaxDot;
     
    printf("Setting up Kelvin constraints... \n");fflush(NULL);

    // Determine the number of disjoint thick bodies
    
    LoopInKelvinConstraintGroup_ = new int[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];
    
    LoopStack = new int[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];

    zero_int_array(LoopInKelvinConstraintGroup_, VSPGeom().Grid(MGLevel_).NumberOfLoops());

    zero_int_array(LoopStack, VSPGeom().Grid(MGLevel_).NumberOfLoops());

    NumberOfKelvinConstraints_ = 0;

    StackSize = Next = 1;
    
    // Find a loop on a thick surface to start off the search

    j = 1;
    
    FoundOne = 0;
    
    while ( j <= VSPGeom().Grid(MGLevel_).NumberOfLoops() && !FoundOne ) {
       
       if ( VSPGeom().Grid(MGLevel_).LoopList(j).SurfaceType() == THICK_SURFACE ) {
          
          FoundOne = 1;
          
          LoopStack[Next] = j;
          
          LoopInKelvinConstraintGroup_[j] = ++NumberOfKelvinConstraints_;
              
       }
       
       j++;
       
    }
    
    Done = 0;
    
    while ( !Done ) {
       
       while ( Next <= StackSize ) {
          
          Loop = LoopStack[Next];
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; j++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(j);
             
             Loop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop1();
             
             Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop2();

             if ( LoopInKelvinConstraintGroup_[Loop1] == 0 ) {
                             
                LoopInKelvinConstraintGroup_[Loop1] = NumberOfKelvinConstraints_;
                
                LoopStack[++StackSize] = Loop1;
                
             }
             
             if ( LoopInKelvinConstraintGroup_[Loop2] == 0 ) {
                
                LoopInKelvinConstraintGroup_[Loop2] = NumberOfKelvinConstraints_;

                LoopStack[++StackSize] = Loop2;
        
             }          
              
          }
          
          Next++;   
  
       }   
       
       FoundOne = 0;
       
       j = 1;
       
       while ( j <= VSPGeom().Grid(MGLevel_).NumberOfLoops() && !FoundOne ) {
          
          if ( LoopInKelvinConstraintGroup_[j] == 0 ) {
             
             if ( VSPGeom().Grid(MGLevel_).LoopList(j).SurfaceType() == THICK_SURFACE ) {
             
                StackSize = Next = 1;
                
                LoopStack[Next] = j;
       
                LoopInKelvinConstraintGroup_[j] = ++NumberOfKelvinConstraints_;
                
                FoundOne = 1;
                
             }
                
          }
          
          j++;
          
       }
       
       if ( !FoundOne ) Done = 1;
       
    }      

    printf("Found %d disjoint thick bodies \n",NumberOfKelvinConstraints_);fflush(NULL);
    
    // If this is a mixed thick/thin solve we need to check if any of the thick bodies
    // are intersected by thin surfaces
    
    NodeIsOnThinSurface = new int[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    KelvinGroupPerm = new int[NumberOfKelvinConstraints_ + 1];
    
    zero_int_array(NodeIsOnThinSurface, VSPGeom().Grid(MGLevel_).NumberOfNodes());
    
    for ( k = 1 ; k <= NumberOfKelvinConstraints_ ; k++ ) {
       
       KelvinGroupPerm[k] = k;
       
    }
    
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; j++ ) {
       
        if ( VSPGeom().Grid(MGLevel_).LoopList(j).SurfaceType() == THIN_SURFACE ) {

          for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).LoopList(j).NumberOfNodes() ; i++ ) {
             
             NodeIsOnThinSurface[VSPGeom().Grid(MGLevel_).LoopList(j).Node(i)] = 1;
             
          }
          
        }
        
    }

    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; j++ ) {

       if ( LoopInKelvinConstraintGroup_[j] > 0 ) {
          
          Intersected = 0;
          
          i = 1;
          
          while ( i <= VSPGeom().Grid(MGLevel_).LoopList(j).NumberOfNodes() && !Intersected ) {
             
             if ( NodeIsOnThinSurface[i] == 1 ) Intersected = 1;
             
             i++;
             
          }
          
   //       if ( Intersected ) KelvinGroupPerm[LoopInKelvinConstraintGroup_[j]] = 0;
          
       }
       
    }           
           
    delete [] NodeIsOnThinSurface;
    
    NewNumberOfKelvinGroups = 0;
    
    for ( k = 1 ; k <= NumberOfKelvinConstraints_ ; k++ ) {
       
       if ( KelvinGroupPerm[k] > 0 ) KelvinGroupPerm[k] = ++NewNumberOfKelvinGroups;
          
    }

    printf("Found %d actual kelvin constraints \n",NewNumberOfKelvinGroups);fflush(NULL);
    
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; j++ ) {
       
        if ( VSPGeom().Grid(MGLevel_).LoopList(j).SurfaceType() == THICK_SURFACE ) {

          LoopInKelvinConstraintGroup_[j] = KelvinGroupPerm[LoopInKelvinConstraintGroup_[j]];
          
        }
        
    }    
       
    NumberOfKelvinConstraints_ = NewNumberOfKelvinGroups;    

    KelvinGroupSum_ = new double[NumberOfKelvinConstraints_ + 1];
       
//              
//       
//                
//                
//          
//          // First
//          if ( NumberOfDisjointBodies == 0 ) {
//          
//    // Place a Kelvin constraint on each disjoint thick surface
//    
//    
//    
//    
//     
//    // Traverse the loops, edge to edge, and determine the number of 
//    // independent bodies... this is the number of Kelvin constraints
//    // we have to impose
// 
//    LoopStack = new int[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];
// 
//    LoopIsOnBaseRegion_ = new int[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];
//
//    
// 
//    zero_int_array(LoopStack, VSPGeom().Grid(MGLevel_).NumberOfLoops());
//    
//    zero_int_array(LoopIsOnBaseRegion_, VSPGeom().Grid(MGLevel_).NumberOfLoops());
//    
//    zero_int_array(LoopInKelvinConstraintGroup_, VSPGeom().Grid(MGLevel_).NumberOfLoops());
//
//    NumberOfKelvinConstraints_ = 1;
//
//    StackSize = Next = 1;
//    
//    // Find a loop on a thick surface to start off the search
//
//    j = 1;
//    
//    FoundOne = 0;
//    
//    while ( j <= VSPGeom().Grid(MGLevel_).NumberOfLoops() && !FoundOne ) {
//       
//       if ( VSPGeom().Grid(MGLevel_).LoopList(j).SurfaceType() == THICK_SURFACE ) {
//          
//          FoundOne = 1;
//          
//          LoopStack[Next] = j;
//          
//          LoopInKelvinConstraintGroup_[j] = NumberOfKelvinConstraints_;
//              
//       }
//       
//       j++;
//       
//    }
//    
//    Done = 0;
//    
//    while ( !Done ) {
//       
//       while ( Next <= StackSize ) {
//          
//          Loop = LoopStack[Next];
//          
//          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; j++ ) {
//             
//             Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(j);
//             
//             Loop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop1();
//             
//             Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop2();
//
//             if ( LoopInKelvinConstraintGroup_[Loop1] == 0 ) {
//                             
//                LoopInKelvinConstraintGroup_[Loop1] = NumberOfKelvinConstraints_;
//                
//                LoopStack[++StackSize] = Loop1;
//                
//             }
//             
//             if ( LoopInKelvinConstraintGroup_[Loop2] == 0 ) {
//                
//                LoopInKelvinConstraintGroup_[Loop2] = NumberOfKelvinConstraints_;
//
//                LoopStack[++StackSize] = Loop2;
//        
//             }          
//              
//          }
//          
//          Next++;   
//  
//       }   
//       
//       FoundOne = 0;
//       
//       j = 1;
//       
//       while ( j <= VSPGeom().Grid(MGLevel_).NumberOfLoops() && !FoundOne ) {
//          
//          if ( LoopInKelvinConstraintGroup_[j] == 0 ) {
//             
//             if ( VSPGeom().Grid(MGLevel_).LoopList(j).SurfaceType() == THICK_SURFACE ) {
//             
//                StackSize = Next = 1;
//                
//                LoopStack[Next] = j;
//       
//                LoopInKelvinConstraintGroup_[j] = ++NumberOfKelvinConstraints_;
//                
//                FoundOne = 1;
//                
//             }
//                
//          }
//          
//          j++;
//          
//       }
//       
//       if ( !FoundOne ) Done = 1;
//       
//    }
//
//    printf("There are %d Kelvin constraints \n",NumberOfKelvinConstraints_);
//    
//    printf("Setting up Kelvin constraints... and there are: %10d Vortex Sheets \n", VSPGeom().NumberOfVortexSheets());
//             
//    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
//
//       // Find a node on this vortex sheet
//       
//       FoundOne = 0;
//       
//       j = 1;
//            
//       while ( !FoundOne && j <= VSPGeom().Grid(MGLevel_).NumberOfKuttaNodes() ) {
//   
//          Wing = VSPGeom().Grid(MGLevel_).WingSurfaceForKuttaNode(j);
//        
//          if ( Wing == k && VSPGeom().Grid(MGLevel_).WingSurfaceForKuttaNodeIsPeriodic(j) ) {
//  
//             Node = VSPGeom().Grid(MGLevel_).KuttaNode(j);;
//             
//             FoundOne = 1;
//             
//          }
//          
//          j++;
//          
//       }
//
//       if ( FoundOne ) {
//
//          printf("Looking for node: %d \n",Node);fflush(NULL);
//          
//          // Grab a loop that contains this kutta node
//         
//          FoundOne = 0;
//         
//          n = 1;
//         
//          while ( !FoundOne && n <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ) {
//            
//             if ( VSPGeom().Grid(MGLevel_).LoopList(n).SurfaceType() == THICK_SURFACE ) {
//                
//                p = 1;
//                           
//                while ( p <= VSPGeom().Grid(MGLevel_).LoopList(n).NumberOfEdges() && !FoundOne ) {
//         
//                   Edge = VSPGeom().Grid(MGLevel_).LoopList(n).Edge(p);
//                  
//                   Node1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node1();
//                   Node2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node2();
//                  
//                   if ( Node == Node1 || Node == Node2 ) {
//                     
//                      Loop = n;
//                     
//                      FoundOne = 1;
//                     
//                   }
//                  
//                   p++;
//                  
//                }
//                
//             }
//            
//             n++;
//            
//          }
//         
//          if ( FoundOne ) {
// 
//             // Go edge, by edge and see if we cover the entire kelvin region
//            
//             zero_int_array(LoopStack, VSPGeom().Grid(MGLevel_).NumberOfLoops());
//            
//             StackSize = Next = 1;
//             
//             LoopStack[Next] = Loop;
//            
//             KelvinGroup = LoopInKelvinConstraintGroup_[Loop];
//   
//             while ( Next <= StackSize ) {
//                
//                Loop = LoopStack[Next];
//                
//                for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; p++ ) {
//                   
//                   Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(p);
//                  
//                   if ( !VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) {
//                  
//                      Loop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop1();
//                      
//                      Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop2();
//   
//                      if ( LoopInKelvinConstraintGroup_[Loop1] == KelvinGroup ) {
//                         
//                         LoopInKelvinConstraintGroup_[Loop1] = -KelvinGroup;
//               
//                         if ( Loop1 != Loop ) LoopStack[++StackSize] = Loop1;
//                         
//                      }
//                     
//                      else if ( LoopInKelvinConstraintGroup_[Loop1] != -KelvinGroup ){
//                        
//                         printf("wtf... how did we jump to another Kelvin Group... \n"); fflush(NULL);
//                         exit(1);
//                         
//                      }
//                      
//                      if ( LoopInKelvinConstraintGroup_[Loop2] == KelvinGroup ) {
//                         
//                         LoopInKelvinConstraintGroup_[Loop2] = -KelvinGroup;
//       
//                         if ( Loop2 != Loop ) LoopStack[++StackSize] = Loop2;
//                 
//                      }    
//                     
//                      else if ( LoopInKelvinConstraintGroup_[Loop2] != -KelvinGroup ){
//                        
//                         printf("wtf... how did we jump to another Kelvin Group... \n"); fflush(NULL);
//                         exit(1);
//                        
//                      }    
//                     
//                   }                       
//                    
//                }
//                
//                Next++;   
//        
//             }
//         
//             // Check and see if there are any loops in this Kelvin group that were not flipped
//            
//             NotFlipped = 0;
//   
//             for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; p++ ) {                  
//                     
//                if ( LoopInKelvinConstraintGroup_[p] == KelvinGroup ) {
//                  
//                   NotFlipped++;
//                  
//                }
//               
//             }
//               
//             // If not all were flipped... then there is a base region
//            
//             if ( NotFlipped > 0 ) {
//                                 
//                printf("Base region found for vortex sheet system: %d \n",k);fflush(NULL);
//                                           
//                // Determine which region ... + or - ... is the base region
//               
//                Vec1[0] = Vec1[1] = Vec1[2] = 0.;
//               
//                Vec2[0] = Vec2[1] = Vec2[2] = 0.;
//   
//                for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; p++ ) {                  
//                        
//                   if ( LoopInKelvinConstraintGroup_[p] ==  KelvinGroup ) {
//                     
//                      Vec1[0] += VSPGeom().Grid(MGLevel_).LoopList(p).Nx();
//                      Vec1[1] += VSPGeom().Grid(MGLevel_).LoopList(p).Ny();
//                      Vec1[2] += VSPGeom().Grid(MGLevel_).LoopList(p).Nz();
//                     
//                   }
//                  
//                   if ( LoopInKelvinConstraintGroup_[p] == -KelvinGroup ) {
//                     
//                      Vec2[0] += VSPGeom().Grid(MGLevel_).LoopList(p).Nx();
//                      Vec2[1] += VSPGeom().Grid(MGLevel_).LoopList(p).Ny();
//                      Vec2[2] += VSPGeom().Grid(MGLevel_).LoopList(p).Nz();
//                     
//                   }                     
//                  
//                }
//               
//                Dot = sqrt(vector_dot(Vec1,Vec1));
//               
//                Vec1[0] /= Dot; 
//                Vec1[1] /= Dot; 
//                Vec1[2] /= Dot; 
//               
//                Dot = sqrt(vector_dot(Vec2,Vec2));
//               
//                Vec2[0] /= Dot; 
//                Vec2[1] /= Dot; 
//                Vec2[2] /= Dot;
//               
//                // Remove those loops in the base region from the Kelvin group, and add them
//                // to the base region list
//               
//                if ( Vec1[0] > Vec2[0] ) {
//              
//                   for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; p++ ) {                  
//                        
//                      if ( LoopInKelvinConstraintGroup_[p] == KelvinGroup ) {
//                        
//                         LoopIsOnBaseRegion_[p] = 1;
//                        
//                         LoopInKelvinConstraintGroup_[p] = KelvinGroup;
//                 
//                      }
//                     
//                   }
//                  
//                   for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; p++ ) {                  
//                        
//                      if ( LoopInKelvinConstraintGroup_[p] == -KelvinGroup ) {
//                     
//                         LoopInKelvinConstraintGroup_[p] = KelvinGroup;
//                 
//                      }
//                     
//                   }                     
//                  
//                }
//               
//                else {
//          
//                   for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; p++ ) {                  
//                        
//                      if ( LoopInKelvinConstraintGroup_[p] == -KelvinGroup ) {
//                        
//                         LoopIsOnBaseRegion_[p] = 1;
//                        
//                         LoopInKelvinConstraintGroup_[p] = KelvinGroup;
//                        
//                      }
//                     
//                   }
//                  
//                   for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; p++ ) {                  
//                        
//                      if ( LoopInKelvinConstraintGroup_[p] == KelvinGroup ) {
//                      
//                         LoopInKelvinConstraintGroup_[p] = KelvinGroup;
//                 
//                      }
//                     
//                   }                        
//                  
//                }  
//                      
//             }
//             
//             else {
//                
//                for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; p++ ) {                  
//                     
//                   if ( LoopInKelvinConstraintGroup_[p] == -KelvinGroup ) {
//                     
//                      LoopInKelvinConstraintGroup_[p] = KelvinGroup;
//                     
//                   }
//               
//                }
//             
//             }
//            
//          }     
//          
//       }            
//       
//    }
//
//    printf("There are %d Kelvin constraints \n",NumberOfKelvinConstraints_);
//    
//    delete [] LoopStack; 
 
}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER Setup_VortexLoops                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::Setup_VortexLoops(void)
{
    
    int j, k, Level;

    // Set up the Vortex Loops... 

    k = 0;
    
    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfLoops() ; j++ ) {

         VSPGeom().Grid(Level).LoopList(j).VortexLoop() = j;

         VSPGeom().Grid(Level).LoopList(j).MGVortexLoop() = ++k;
         
       }
       
    }
    
}    

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER Setup_VortexEdges                         #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::Setup_VortexEdges(void)
{
    
    int j, k, Node1, Node2, Level;
    VSP_NODE VSP_Node1, VSP_Node2;
    
    // Setup the surface vortex edge data
    
    k = 0;
    
    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfEdges() ; j++ ) {
       
          // Pointer from grid edge to vortex edge

          VSPGeom().Grid(Level).EdgeList(j).ThisEdge() = j;
   
          VSPGeom().Grid(Level).EdgeList(j).VortexEdge() = ++k;
                    
          // Pass in edge data and create edge coefficients
          
          Node1 = VSPGeom().Grid(Level).EdgeList(j).Node1();
          Node2 = VSPGeom().Grid(Level).EdgeList(j).Node2();

          VSPGeom().Grid(Level).EdgeList(j).Setup(VSPGeom().Grid(Level).NodeList(Node1),
                                                  VSPGeom().Grid(Level).NodeList(Node2));
                                                  
       }
       
    }

}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER InitializeFreeStream                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::InitializeFreeStream(void)
{
 
    int c, i, j, Level, k, Loop, BestLoop;
    double xyz[3], q[5], CA, SA, CB, SB, Rate_P, Rate_Q, Rate_R, qp[4];
    double gamma, f1, f2, gm1, gm2, gm3, Wgt1, Wgt2, Area1, Area2;
    VSP_NODE VSP_Node1, VSP_Node2;
    double OVec[3], TVec[3], RVec[3], Dot, MaxDot;
    QUAT Quat, InvQuat, Vec1, Vec2, DQuatDt, Omega, BodyVelocity, WQuat;

    // Limit lower value of Mach number
    
    if ( Mach_ <= 0. ) Mach_ = 0.001;

    // Set Mach number for the edge class... it is static across all edge instances
    
    for ( i = 0 ; i <= NumberOfMGLevels_ ; i++ ) {

       VSPGeom().Grid(i).SetMachNumber(Mach_);    
       
    }

    // Set multi-pole far away ratio for supersonic flow

    if ( Mach_ > 1. ) FarAway_ *= 4.;

    // Supersonic smoothing 
         
    SmoothFactor_ = 0.0;

    // Turn on KT correction
    
    if ( KarmanTsienCorrection_ && VSPGeom().ModelType() == VLM_MODEL ) {
       
      for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
       
         // if ( Mach_ * 1.125 < 0.9 ) VSPGeom().Grid(MGLevel_).EdgeList(j).KTFact() = 1.125;
 
          VSPGeom().Grid(MGLevel_).EdgeList(j).KTFact() = MAX(1.,MIN(1.125, 0.90/Mach_));
  
       }
       
       RestrictKTFactorFromGrid(MGLevel_);
       
    }
    
    // Limits on max velocity, and min/max pressures

    gamma = 1.4;

    gm1 = gamma - 1.;

    gm2 = 0.5*gm1*SQR(Mach_);

    gm3 = 1./gm1;

    QMax_ = 0.75*sqrt( 1./gm2 + 1. );    
    
    CpMin_ = -2./(gamma*Mach_*Mach_);

    CpMin_ = MAX(-15.,CpMin_);

    f1 = 1. + 0.5*(gamma-1.)*Mach_*Mach_;

    CpMax_ = 2.*( pow(f1,(gamma)/(gamma-1.)) - 1. ) / ( 1.4*Mach_*Mach_ );
    
    if ( Mach_ > 1. ) {
       
       f1 = pow((gamma+1.)*Mach_,2.)/(4.*gamma*Mach_*Mach_ - 2.*(gamma-1.));
       f2 = (1. - gamma + 2.*gamma*Mach_*Mach_)/(gamma+1.);

       CpMax_ = (2./(gamma*Mach_*Mach_))*( pow(f1,gamma/(gamma-1.))*f2 - 1. );
       
    }
 
    DCpMax_ = CpMax_ - CpMin_;

    // Estimate of Vmax

    Vmax_ = MAX3(Vinf_, Vref_,sqrt(2.*QMax_)*Vinf_);
    
    // Engine faces
    
    for ( i = 1 ; i <= NumberOfEngineFaces_ ; i++ ) {

       Vmax_ = MAX(Vmax_,Vinf_ + EngineFace_[i].NormalVelocity());
       
       Vmax_ = MAX(Vmax_,Vinf_ + EngineFace_[i].NozzleVelocity());
         
    }  
    
    // Base pressure
    
    if ( Mach_ <= 1.1 ) {

       CpBase_ = -0.20 - 0.25/40.*pow(Mach_ + 1., 4.);

    }

    else if ( Mach_ > 1.1 && Mach_ <= 4. ) {

       CpBase_ = -1.418/pow(Mach_+1.,1.95);

    }

    else {

	    CpBase_ = -1./(Mach_*Mach_);

    }    

    // Free stream velocity vector

    CA = cos(AngleOfAttack_);
    SA = sin(AngleOfAttack_);

    CB = cos(AngleOfBeta_);
    SB = sin(AngleOfBeta_);

    FreeStreamVelocity_[0] = CA*CB * Vinf_;
    FreeStreamVelocity_[1] =   -SB * Vinf_;
    FreeStreamVelocity_[2] = SA*CB * Vinf_;
    
    // Calculate body velocities for rotor cases
    
    if ( !TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();

    // Loops
    
    UpdateLoopFreeStreamVelocities();
    
    // Edges

    UpdateEdgeFreeStreamVelocities();

    // Calculate the smoothed principal part of the generalized biot-savart law
    
    SmoothPrincipalPart();

}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER UpdateLoopFreeStreamVelocities                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdateLoopFreeStreamVelocities(void)
{
   
    int i, Level;
    double qp[4];
    
    // Zero out loop level local free stream velocities
    
    for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfLoops() ; i++ ) {

          VSPGeom().Grid(Level).LoopList(i).LocalFreeStreamVelocity(0) = 0.;
          VSPGeom().Grid(Level).LoopList(i).LocalFreeStreamVelocity(1) = 0.;   
          VSPGeom().Grid(Level).LoopList(i).LocalFreeStreamVelocity(2) = 0.;   
          VSPGeom().Grid(Level).LoopList(i).LocalFreeStreamVelocity(3) = 0.;   
          VSPGeom().Grid(Level).LoopList(i).LocalFreeStreamVelocity(4) = 0.;   
          
       }
       
    }

    // Free stream contributions

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       Calculate_Total_FreeStream_Velocity_at_pXYZ(VSPGeom().Grid(MGLevel_).LoopList(i).xyz_c(), qp);

       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(0) = qp[0];
       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(1) = qp[1];
       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(2) = qp[2];
       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(3) = qp[3];
       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(4) = 0.;
             
    }        
 
    // Add in surface velocity terms
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {

       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(0) -= LocalBodySurfaceVelocityForLoop_[i][0];
       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(1) -= LocalBodySurfaceVelocityForLoop_[i][1];
       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(2) -= LocalBodySurfaceVelocityForLoop_[i][2];
     
    }       
    
    // Update velocity magnitude
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
 
       // Calculate local free stream conditions

       VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(4) = sqrt( SQR(VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(0))
                                                                             + SQR(VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(1))
                                                                             + SQR(VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(2)) );
        
    }   

    // Restrict the local free stream velocities onto the coarser grids loops
    
    RestrictFreeStreamVelocity();
     
}
 
/*##############################################################################
#                                                                              #
#             VSP_SOLVER UpdateEdgeFreeStreamVelocities                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdateEdgeFreeStreamVelocities(void)
{

    int i, j, k;
    double qp[4], Angle, Omega;
    VSP_EDGE *WakeEdge;
    QUAT OmegaVec, Quat, InvQuat, WQuat, Vec1, Vec2, RotationalVelocity;
    
    // Initialize all edges to free stream velocity
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
                 
       Calculate_Total_FreeStream_Velocity_at_pXYZ(VSPGeom().Grid(MGLevel_).EdgeList(i).xyz_c(), qp);
                 
       VSPGeom().Grid(MGLevel_).EdgeList(i).LocalFreeStreamVelocity(0) = qp[0];
       VSPGeom().Grid(MGLevel_).EdgeList(i).LocalFreeStreamVelocity(1) = qp[1];
       VSPGeom().Grid(MGLevel_).EdgeList(i).LocalFreeStreamVelocity(2) = qp[2];
       VSPGeom().Grid(MGLevel_).EdgeList(i).LocalFreeStreamVelocity(3) = qp[3];
       VSPGeom().Grid(MGLevel_).EdgeList(i).LocalFreeStreamVelocity(4) = 0.; 
       
    }
    
    // Add in surface velocity terms
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; i++ ) {
    
       VSPGeom().Grid(MGLevel_).EdgeList(i).LocalFreeStreamVelocity(0) -= LocalBodySurfaceVelocityForEdge_[i][0];
       VSPGeom().Grid(MGLevel_).EdgeList(i).LocalFreeStreamVelocity(1) -= LocalBodySurfaceVelocityForEdge_[i][1];
       VSPGeom().Grid(MGLevel_).EdgeList(i).LocalFreeStreamVelocity(2) -= LocalBodySurfaceVelocityForEdge_[i][2];
       
    }
    
    // Add in any quasi steady state rotor velocities

    if ( VSPGeom().ThereAreRotors() && !TimeAccurate_ ) {
    
       // Mark and setup any vortex sheets / vortex trails that come off rotors
                    
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          if ( VSPGeom().VortexSheet(k).IsARotor() ) {
  
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
   
                // Calculate the rates
                
                Angle = 0.;
                
                Quat.FormRotationQuat(VSPGeom().VortexSheet(k).TrailingVortex(i).RotorThrustVector(),Angle);
                
                InvQuat = Quat;
                
                InvQuat.FormInverse();   
                
                // Angular rate
                
                Omega = -VSPGeom().VortexSheet(k).TrailingVortex(i).BladeRPM() * 2. * PI / 60.;
                
                OmegaVec(0) = Omega * VSPGeom().VortexSheet(k).TrailingVortex(i).RotorThrustVector(0);
                OmegaVec(1) = Omega * VSPGeom().VortexSheet(k).TrailingVortex(i).RotorThrustVector(1);
                OmegaVec(2) = Omega * VSPGeom().VortexSheet(k).TrailingVortex(i).RotorThrustVector(2);
                OmegaVec(3) = 0.;
                   
                // Quaternion rates
                
                WQuat = OmegaVec * Quat * InvQuat;
  
                for ( j = 1 ; j < VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes() ; j++ ) {
                   
                   WakeEdge = VSPGeom().VortexSheet(k).TrailingVortex(i).EdgeList(j);
                   
                   if ( WakeEdge->IsWakeEdge() ) {
                      
                      if ( WakeEdge->WakeEdgeData().dS() > 0. ) {
                         
                         if ( WakeEdge->WakeEdgeData().Direction() > 0 ) {

                            Vec1(0) = WakeEdge->X2() - VSPGeom().VortexSheet(k).TrailingVortex(i).RotorOrigin(0);
                            Vec1(1) = WakeEdge->Y2() - VSPGeom().VortexSheet(k).TrailingVortex(i).RotorOrigin(1);
                            Vec1(2) = WakeEdge->Z2() - VSPGeom().VortexSheet(k).TrailingVortex(i).RotorOrigin(2);             
                                      
                         }
                                
                         else {

                            Vec1(0) = WakeEdge->X1() - VSPGeom().VortexSheet(k).TrailingVortex(i).RotorOrigin(0);
                            Vec1(1) = WakeEdge->Y1() - VSPGeom().VortexSheet(k).TrailingVortex(i).RotorOrigin(1);
                            Vec1(2) = WakeEdge->Z1() - VSPGeom().VortexSheet(k).TrailingVortex(i).RotorOrigin(2);       
                                      
                         }     
                                              
                         Vec2 = Quat * Vec1 * InvQuat;
                         
                         // Rotation velocity
                         
                         RotationalVelocity = WQuat * Vec2;
     
                         WakeEdge->LocalFreeStreamVelocity(0) += RotationalVelocity(0);
                         WakeEdge->LocalFreeStreamVelocity(1) += RotationalVelocity(1);
                         WakeEdge->LocalFreeStreamVelocity(2) += RotationalVelocity(2);
          
                      }
                      
                   }
                   
                }
                
             }
             
          }
                      
       }       
       
    }

    // Mark wake edges on rotors and specify the rotor direction
    
    if (  VSPGeom().ThereAreRotors() || TimeAccurate_ ) {
         
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          if ( VSPGeom().VortexSheet(k).IsARotor() > 0 ) {
  
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
   
                for ( j = 1 ; j < VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes() ; j++ ) {
                   
                   WakeEdge = VSPGeom().VortexSheet(k).TrailingVortex(i).EdgeList(j);
                   
                   if ( WakeEdge->IsWakeEdge() ) {      
                      
                      WakeEdge->WakeEdgeData().IsRotorWake() = VSPGeom().VortexSheet(k).IsARotor();
                      
                      WakeEdge->WakeEdgeData().RotorThrustVector(0) = VSPGeom().VortexSheet(k).TrailingVortex(i).RotorThrustVector(0);
                      WakeEdge->WakeEdgeData().RotorThrustVector(1) = VSPGeom().VortexSheet(k).TrailingVortex(i).RotorThrustVector(1);
                      WakeEdge->WakeEdgeData().RotorThrustVector(2) = VSPGeom().VortexSheet(k).TrailingVortex(i).RotorThrustVector(2);
                       
                   }
                   
                }
                
             }
             
          }
          
       }
       
    }
    
}

/*##############################################################################
#                                                                              #
#          VSP_SOLVER Calculate_Total_FreeStream_Velocity_at_pXYZ              #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::Calculate_Total_FreeStream_Velocity_at_pXYZ(double xyzp[3], double qp[4])
{
 
    double q[4];

    // Initialize to free stream
    
    qp[0] = FreeStreamVelocity_[0];
    qp[1] = FreeStreamVelocity_[1];
    qp[2] = FreeStreamVelocity_[2];
    qp[3] = 0.;

    Calculate_FreeStream_Velocity_From_RotationRates_at_pXYZ(xyzp, q);
    
    qp[0] += q[0];
    qp[1] += q[1];
    qp[2] += q[2];
    qp[3] += q[3];

    Calculate_FreeStreamVelocity_From_Rotors_And_Engines_At_pXYZ(xyzp, q);
    
    qp[0] += q[0];
    qp[1] += q[1];
    qp[2] += q[2];
    qp[3] += q[3];
     
}
 
/*##############################################################################
#                                                                              #
#      VSP_SOLVER Calculate_FreeStream_Velocity_From_RotationRates_at_pXYZ     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::Calculate_FreeStream_Velocity_From_RotationRates_at_pXYZ(double xyzp[3], double qp[4])
{
 
    double xyz[3], Rate_P, Rate_Q, Rate_R;

    qp[0] = 0.;
    qp[1] = 0.;
    qp[2] = 0.;
    qp[3] = 0.;
    
    // Rotational rates... note these rates are wrt to the body stability
    // axes... so we have to convert them to equivalent freestream velocities...
    // in the VSPAERO axes system with has X and Z pointing in the opposite
    // directions
    
    Rate_P = RotationalRate_[0];
    Rate_Q = RotationalRate_[1];
    Rate_R = RotationalRate_[2];
       
    xyz[0] = xyzp[0] - Xcg();            
    xyz[1] = xyzp[1] - Ycg();           
    xyz[2] = xyzp[2] - Zcg();      
    
    // P - Roll
    
    qp[0] += 0.;
    qp[1] += -xyz[2] * Rate_P;
    qp[2] += +xyz[1] * Rate_P;      
     
    // Q - Pitch
    
    qp[0] += -xyz[2] * Rate_Q;
    qp[1] += 0.;
    qp[2] += +xyz[0] * Rate_Q;    
    
    // R - Yaw
    
    qp[0] += -xyz[1] * Rate_R;
    qp[1] += +xyz[0] * Rate_R;
    qp[2] += 0.;    

}

/*##############################################################################
#                                                                              #
#   VSP_SOLVER Calculate_FreeStreamVelocity_From_Rotors_And_Engines_At_pXYZ    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::Calculate_FreeStreamVelocity_From_Rotors_And_Engines_At_pXYZ(double xyzp[3], double qp[4])
{
 
    int j;
    double xyz[3], q[5];

    // Initialize
    
    qp[0] = 0.;
    qp[1] = 0.;
    qp[2] = 0.;
    qp[3] = 0.;
    
    // Rotor induced velocities

    for ( j = 1 ; j <= NumberOfRotors_ ; j++ ) {
     
       RotorDisk(j).Density() = Density_;
    
       RotorDisk(j).Vinf(0) = FreeStreamVelocity_[0];
       RotorDisk(j).Vinf(1) = FreeStreamVelocity_[1];
       RotorDisk(j).Vinf(2) = FreeStreamVelocity_[2];
     
    }
        
    for ( j = 1 ; j <= NumberOfRotors_ ; j++ ) {
    
       xyz[0] = xyzp[0];           
       xyz[1] = xyzp[1];          
       xyz[2] = xyzp[2];
          
       RotorDisk(j).Velocity(xyz, q);                   
    
       qp[0] += q[0];
       qp[1] += q[1];
       qp[2] += q[2];
       qp[3] += q[3];
                      
       // If there is a ground effects, z - plane
       
       if ( DoGroundEffectsAnalysis() ) {
    
          xyz[0] = xyzp[0];           
          xyz[1] = xyzp[1];          
          xyz[2] = xyzp[2];
       
          xyz[2] *= -1.;
         
          RotorDisk(j).Velocity(xyz, q);      
    
          q[2] *= -1.;
          
          qp[0] += q[0];
          qp[1] += q[1];
          qp[2] += q[2];
          qp[3] += q[3];  
                 
       }
                 
       // If there is a symmetry plane, calculate influence of the reflection
       
       if ( DoSymmetryPlaneSolve_ ) {
    
          xyz[0] = xyzp[0];           
          xyz[1] = xyzp[1];          
          xyz[2] = xyzp[2];
          
          xyz[1] *= -1.;
         
          RotorDisk(j).Velocity(xyz, q);      
    
          q[1] *= -1.;
          
          qp[0] += q[0];
          qp[1] += q[1];
          qp[2] += q[2];
          qp[3] += q[3];           
          
          // If there is a ground effects, z - plane
          
          if ( DoGroundEffectsAnalysis() ) {
    
             xyz[2] *= -1.;
            
             RotorDisk(j).Velocity(xyz, q);      
    
             q[1] *= -1.;
             q[2] *= -1.;
    
             qp[0] += q[0];
             qp[1] += q[1];
             qp[2] += q[2];
             qp[3] += q[3];                      
               
          }    
            
       }             
         
    }
    
    // Engine flow fields
    
    for ( j = 1 ; j <= NumberOfEngineFaces_ ; j++ ) {
     
       xyz[0] = xyzp[0];           
       xyz[1] = xyzp[1];          
       xyz[2] = xyzp[2];
          
       EngineFace(j).Velocity(xyz, q);   

       qp[0] += q[0];
       qp[1] += q[1];
       qp[2] += q[2];
       qp[3] += q[3];
                      
       // If there is a ground effects, z - plane
       
       if ( DoGroundEffectsAnalysis() ) {

          xyz[0] = xyzp[0];           
          xyz[1] = xyzp[1];          
          xyz[2] = xyzp[2];
       
          xyz[2] *= -1.;
         
          EngineFace(j).Velocity(xyz, q);      

          q[2] *= -1.;
          
          qp[0] += q[0];
          qp[1] += q[1];
          qp[2] += q[2];
          qp[3] += q[3]; 
                 
        }      
                 
        // If there is a symmetry plane, calculate influence of the reflection
        
        if ( DoSymmetryPlaneSolve_ ) {

          xyz[0] = xyzp[0];           
          xyz[1] = xyzp[1];          
          xyz[2] = xyzp[2];
          
          xyz[1] *= -1.;
         
          EngineFace(j).Velocity(xyz, q);          

          q[1] *= -1.;
          
          qp[0] += q[0];
          qp[1] += q[1];
          qp[2] += q[2];
          qp[3] += q[3];           
          
          // If there is a ground effects, z - plane
          
          if ( DoGroundEffectsAnalysis() ) {

             xyz[2] *= -1.;
            
             EngineFace(j).Velocity(xyz, q);      
   
             q[1] *= -1.;
             q[2] *= -1.;

             qp[0] += q[0];
             qp[1] += q[1];
             qp[2] += q[2];
             qp[3] += q[3];               
               
          }    
            
       }             
          
    }

}

/*##############################################################################
#                                                                              #
#         VSP_SOLVER CalculateBodyVelocitiesForQuasiUnsteadyAnalysis           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateBodyVelocitiesForQuasiUnsteadyAnalysis(void) 
{
   
    int c, i, j, *ComponentInThisGroup;
    double OVec[3], TVec[3], RVec[3];
    QUAT Quat, InvQuat, Vec1, Vec2, DQuatDt, BodyVelocity, WQuat;

    // Loop over any quasi-unsteady component groups calculate body velocities
    
    ComponentInThisGroup = new int[VSPGeom().NumberOfComponents() + 1];
   
    for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
                          
       // If a rotor...
    
       if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) {

          CalculateLocalBodyVelocitiesFromMovingGeometries(c);             

       }
   
    }
 
}

/*##############################################################################
#                                                                              #
#                   VSP_SOLVER RestrictFreeStreamVelocity                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestrictFreeStreamVelocity(void) 
{
 
    int Level, i_c, i_f;
    double Fact;

    for ( Level = 1 ; Level < NumberOfMGLevels_ ; Level++ ) {

       for ( i_f = 1 ; i_f <= VSPGeom().Grid(Level).NumberOfLoops() ; i_f++ ) {
  
          i_c = VSPGeom().Grid(Level).LoopList(i_f).CoarseGridLoop();
          
          Fact = VSPGeom().Grid(Level).LoopList(i_f).Area() / VSPGeom().Grid(Level).LoopList(i_c).Area();
          
          VSPGeom().Grid(Level+1).LoopList(i_c).LocalFreeStreamVelocity(0) += Fact*VSPGeom().Grid(Level).LoopList(i_f).LocalFreeStreamVelocity(0);
          VSPGeom().Grid(Level+1).LoopList(i_c).LocalFreeStreamVelocity(1) += Fact*VSPGeom().Grid(Level).LoopList(i_f).LocalFreeStreamVelocity(1);
          VSPGeom().Grid(Level+1).LoopList(i_c).LocalFreeStreamVelocity(2) += Fact*VSPGeom().Grid(Level).LoopList(i_f).LocalFreeStreamVelocity(2);

       }
       
    }          
                      
} 

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER InitializeTrailingVortices                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::InitializeTrailingVortices(void)
{
 
    int i, j, k, c, jj, kk, l, m, p, q, NumEdges, Node1, Node2, Loop;
    int NodeA, NodeB, Found, Done;
    int NumberOfSheets, NumberOfKuttaNodes, Hits;
    int *ComponentInThisGroup, NumberOfStations, *ComponentGroup;
    int *NumberOfVortexSheetsForSurface, *MaxNumberOfVortexSheetsForSurface, **VortexSheetListForSurface;
    int MaxNumberOfSurfaces, SurfaceID, Edge, NumWakeNodes, iRatio;
    double FarDist, *Sigma, Dist;
    double Scale_X, Scale_Y, Scale_Z, WakeDist, xyz_te[3];
    double Vec0[3], Vec1[3], Vec2[3], Mag, dt, ds, Omega, Ratio;
    double VecS[3], VecT[3], VecN[3], S, S1, S2, Uc, U1, U2, MaxSoverB;
    VSP_NODE VSP_Node1, VSP_Node2;
    
    Node1 = 0;
    Node2 = 0;
    
    // Initial wake in the free stream direction

    if ( Vinf_ > 0. ) {
       
       WakeAngle_[0] = FreeStreamVelocity_[0] / Vinf_;
       WakeAngle_[1] = FreeStreamVelocity_[1] / Vinf_;
       WakeAngle_[2] = FreeStreamVelocity_[2] / Vinf_;
       
    }
    
    else {

       WakeAngle_[0] = 1.;
       WakeAngle_[1] = 0.;
       WakeAngle_[2] = 0.;
       
    }
    
    printf("WakeAngle_: %f %f %f \n",WakeAngle_[0],WakeAngle_[1],WakeAngle_[2]);fflush(NULL);

    // Determine how far to allow wakes to adapt... beyond this the wakes go straight off to
    // 'infinity' in the free stream direction
    
    Scale_X = Scale_Y = Scale_Z = 1.;
    
    if ( DoSymmetryPlaneSolve_ ) Scale_Y = 2.;
    
    FarDist = MAX3(Scale_X*(Xmax_ - Xmin_), Scale_Y*(Ymax_-Ymin_), Scale_Z*(Zmax_-Zmin_));

    printf("Xmax_ - Xmin_: %f \n", double(Xmax_ - Xmin_));
    printf("Ymax_ - Ymin_: %f \n", double(Ymax_ - Ymin_));
    printf("Zmax_ - Zmin_: %f \n", double(Zmax_ - Zmin_));
    printf("\n");
    
    printf("The wake FarDist set to: %f \n",FarDist);
    
    VSPGeom().InitializeWakeGrid(Vinf_, FreeStreamVelocity_, WakeAngle_, Xmax_, TimeAccurate_);
 
    // Set intial wake start time
    
    WakeStartingTime_ = 0;
    
    if ( TimeAccurate_ && StartFromSteadyState_ ) WakeStartingTime_ = VSPGeom().NumberOfWakeTrailingNodes();

    // Determine the minimum trailing edge spacing for edge kutta node

    Sigma = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; j++ ) {

       Sigma[j] = 1.e9;

    }
  
    Hits = 0;
    
    SigmaAvg_ = 0.;
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
     
       if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsTrailingEdge() ) {     

          Node1 = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
          Node2 = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();
          
          Sigma[Node1] = MIN(Sigma[Node1], VSPGeom().Grid(MGLevel_).EdgeList(i).Length());
          Sigma[Node2] = MIN(Sigma[Node2], VSPGeom().Grid(MGLevel_).EdgeList(i).Length());
       
          SigmaAvg_ += pow(VSPGeom().Grid(MGLevel_).EdgeList(i).Length(),2.);
          
          Hits++;
        
       }
       
    } 
    
    // Average trailing edge spacing
    
    if ( Hits > 0 ) SigmaAvg_ /= Hits;
    
    SigmaAvg_ = sqrt(SigmaAvg_);

    printf("SigmaAvg_: %f \n",SigmaAvg_);fflush(NULL);

    delete [] Sigma;
    
}

/*##############################################################################
#                                                                              #
#                               VSP_SOLVER Solve                               #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::Solve(int Case)
{
 
    int c, i, j, k, Converged;
    char StatusFileName[MAX_CHAR_SIZE], LoadFileName[MAX_CHAR_SIZE], ADBFileName[MAX_CHAR_SIZE];
    char GroupFileName[MAX_CHAR_SIZE], RotorFileName[MAX_CHAR_SIZE], SurveyFileName[MAX_CHAR_SIZE];
    char QUADTREEFileName[MAX_CHAR_SIZE];
    
    // Zero out solution

    if ( !RestartFromPreviousSolve_ ) ZeroSolutionState();

    CurrentTime_ = 0.;
    
    AveragingHasStarted_ = 0;  
   
    NumberOfAveragingSets_ = 0;

    // Keep track of unsteady forces and moments
    
    if ( TimeAccurate_ ) {

       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

          VSPGeom().VortexSheet(k).DeltaTime() = DeltaTime_;
        
       }
                
    }
 
    // Update geometry location and interaction lists for moving geometries

    CurrentTime_ = CurrentNoiseTime_ = 0.;
    
    Time_ = 0;
    
    // Initialize wakes
    
    if ( !RestartFromPreviousSolve_ ) {
       
       // Mark any wakes coming off rotors
       
       VSPGeom().MarkAndSetupRotorWakes();
       
       // Initialize free stream
       
       InitializeFreeStream();
       
       // Initialize the wake trailing vortices
   
       InitializeTrailingVortices();
       
    }
           
    // Recalculate interaction lists

    CurrentWakeIteration_ = 0;

    if ( !DumpGeom_ ) {
              
#ifdef MYMEMORY    
       
       double Mem1 = mymemory();
#endif             
 
       CreateSurfaceVorticesInteractionList();

#ifdef MYMEMORY    
       
       double Mem2 = mymemory();

       printf("Initial Interaction list memory: %lf \n",Mem2-Mem1);fflush(NULL);

#endif              
           
    }

    LastMach_ = Mach_;

    if ( !DumpGeom_ ) ZeroVortexState();

    // Create matrix preconditioners

#ifdef MYMEMORY    

    double Mem1 = mymemory();

#endif    

    if ( !DumpGeom_ && Preconditioner_ != MATCON ) CalculateDiagonal();       
    
    if ( !DumpGeom_ && Preconditioner_ == MATCON ) CreateMatrixPreconditioners();
       
#ifdef MYMEMORY    

    double Mem2 = mymemory();
    
    printf("Preconditioner storage: %lf \n",Mem2-Mem1);fflush(NULL);

#endif    
       
    // Zero out group data

    if ( !DumpGeom_ ) {
       
       for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
          
          VSPGeom().ComponentGroupList(c).ZeroForcesAndMoments();
          
          VSPGeom().ComponentGroupList(c).ZeroOutTotals();

       }
       
    }

    // Do a restart
    
    if ( DoRestart_ == 1 ) {
  
       LoadRestartFile();

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

           VSPGeom().Grid(MGLevel_).LoopList(i).Gamma() = Gamma(i);
    
       }
        
    }
    
    else {

       if ( !RestartFromPreviousSolve_ ) {
       
          for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
              VSPGeom().Grid(MGLevel_).LoopList(i).Gamma() = Gamma(i) = 0.;
          
          }
          
       }
               
    }

    // Open status file
    
    if ( Case == 0 || Case == 1 ) {
       
       snprintf(StatusFileName,sizeof(StatusFileName)*sizeof(char),"%s.history",FileName_);
       
       if ( (StatusFile_ = fopen(StatusFileName, "w")) == NULL ) {
   
          printf("Could not open the history file for output! \n");
   
          exit(1);
   
       }    
       
    }

    // Open the load file the first time only
    
    if ( Case == 0 || Case == 1 ) {
    
       snprintf(LoadFileName,sizeof(LoadFileName)*sizeof(char),"%s.lod",FileName_);
       
       if ( (LoadFile_ = fopen(LoadFileName, "w")) == NULL ) {
   
          printf("Could not open the spanwise loading file for output! \n");
   
          exit(1);
   
       }
       
       // Write out generic header
       
       WriteCaseHeader(LoadFile_);       
       
    }         
   
    // Header for history file
    
    if ( ABS(Case) > 0 ) {
       
       // Write out generic header
       
       WriteCaseHeader(StatusFile_);
       
       // Status update to user
       
       fprintf(StatusFile_,"\n\nSolver Case: %d \n\n",ABS(Case));
       
    }
                   
    if ( !TimeAccurate_ ) {

                          //1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456            

       fprintf(StatusFile_,"                                                                    Surface Integration Forces and Moments -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Wake Induced Forces -->  \n");                
       fprintf(StatusFile_,"                                                                    Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Su Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake- \n");
       fprintf(StatusFile_,"      Iter             Mach             AoA              Beta              CLo             CLi            CLtot              CDo              CDi             CDtot              CSo              CSi            CStot               L/D              E               CMox             CMoy             CMoz             CMix             CMiy             CMiz             CMxtot           CMytot           CMztot           CFox             CFoy             CFoz             CFix             CFiy             CFiz             CFxtot           CFytot           CFztot           CLwtot           CDwtot           CSwtot           CLiw             CDiw             CSiw             CFwxtot          CFwytot          CFwztot         CFiwx            CFiwy            CFiwz           LoDw              Ew              T/QS         L2 Residual      Max Residual     Wall_Time \n");
   
    }
    
    else {

       fprintf(StatusFile_,"                                                                    Surface Integration Forces and Moments -->                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Wake Induced Forces -->  \n");                
       fprintf(StatusFile_,"                                                                    Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Su Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake- \n");
       fprintf(StatusFile_,"      Time             Mach             AoA              Beta              CLo             CLi            CLtot              CDo              CDi             CDtot              CSo              CSi            CStot               L/D              E               CMox             CMoy             CMoz             CMix             CMiy             CMiz             CMxtot           CMytot           CMztot           CFox             CFoy             CFoz             CFix             CFiy             CFiz             CFxtot           CFytot           CFztot           CLwtot           CDwtot           CSwtot           CLiw             CDiw             CSiw             CFwxtot          CFwytot          CFwztot         CFiwx            CFiwy            CFiwz           LoDw              Ew              T/QS         L2 Residual      Max Residual     Wall_Time \n");

    }
    
    // Survey points file

    if ( NumberofSurveyPoints_ > 0 ) {
       
       snprintf(SurveyFileName,sizeof(SurveyFileName)*sizeof(char),"%s.svy",FileName_);
       
       if ( (SurveyFile_ = fopen(SurveyFileName, "w")) == NULL ) {
   
          printf("Could not open the survey file for output! \n");
   
          exit(1);
   
       }    
                          //0123456789x0123456789x0123456789x   0123456789x0123456789x0123456789x 
       fprintf(SurveyFile_, "     X          Y          Z             U          V          W \n");
       
    }

    // Open the adb and case list files the first time only
    
    if ( Case == 0 || Case == 1 ) {

       snprintf(ADBFileName,sizeof(ADBFileName)*sizeof(char),"%s.adb",FileName_);
       
       if ( (ADBFile_ = fopen(ADBFileName, "wb")) == NULL ) {
   
          printf("Could not open the aero data base file for binary output! \n");
   
          exit(1);
   
       }
       
       snprintf(ADBFileName,sizeof(ADBFileName)*sizeof(char),"%s.adb.cases",FileName_);
       
       if ( (ADBCaseListFile_ = fopen(ADBFileName, "w")) == NULL ) {
   
          printf("Could not open the aero data base case list file for output! \n");
   
          exit(1);
   
       }

       if ( NumberOfQuadTrees_ > 0 ) {  
        
          snprintf(QUADTREEFileName,sizeof(QUADTREEFileName)*sizeof(char),"%s.quad.cases",FileName_);

          if ( (QUADTREECaseListFile_ = fopen(QUADTREEFileName, "w")) == NULL ) {
      
             printf("Could not open the aero data base case list file for output! \n");
      
             exit(1);
      
          }
          
          fprintf(QUADTREECaseListFile_,"%d\n",NumberOfQuadTrees_);

          for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {
             
             fprintf(QUADTREECaseListFile_,"%d %d %f \n",
              j,
              QuadTreeDirection(j),
              QuadTreeValue(j));
              
          }
          
          fclose(QUADTREECaseListFile_);
                  
       }
          
    }    
    
    // Set up group and rotor files

    GroupFile_ = new FILE*[VSPGeom().NumberOfComponentGroups() + 1];
        
    k = 0;
    
    for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
       
       if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) k++;
       
    }
    
    k++;

    RotorFile_ = new FILE*[k + 1];
    
    k = 0;
   
    for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
    
       // Create group file
       
       snprintf(GroupFileName,sizeof(GroupFileName)*sizeof(char),"%s.group.%d",FileName_,c);
    
       if ( (GroupFile_[c] = fopen(GroupFileName, "w")) == NULL ) {
    
          printf("Could not open the %s group coefficient file! \n",GroupFileName);
    
          exit(1);
    
       }

                            //1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456 1234567890123456
       fprintf(GroupFile_[c],"Force Coefficients for group %d --> %s \n\n",c,VSPGeom().ComponentGroupList(c).GroupName()); 
       fprintf(GroupFile_[c],"      Time              Cx               Cy               Cz               Cxo              Cyo              Czo              Cxi              Cyi              Czi              Cmx              Cmy              Cmz             Cmxo            Cmyo              Cmzo             Cmxi             Cmyi             Cmzi              CL               CD               CS              CLo              CDo              CSo              CLi               CDi             CSi              Cwx              Cwy              Cwz              Cxiw             Cyiw             Cziw             CLw              CDw              CSw               CLiw            CDiw             CSiw\n");
                          
       // Create rotor file
       
       if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) {
          
          k++;
          
          snprintf(RotorFileName,sizeof(RotorFileName)*sizeof(char),"%s.rotor.%d",FileName_,k);
    
          if ( (RotorFile_[k] = fopen(RotorFileName, "w")) == NULL ) {
      
             printf("Could not open the %s rotor coefficient file! \n",RotorFileName);
      
             exit(1);
      
          }

                               //1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890 1234567890
          fprintf(RotorFile_[k],"                                                                                                                                        ------------ Propeller Coefficients _----------       -------- Rotor Coefficients _-------\n\n");                        
          fprintf(RotorFile_[k]," Time       Diameter     RPM       Thrust    Thrusto    Thrusti     Power      Powero     Poweri     Moment     Momento    Momenti      J          CT         CQ         CP        EtaP       CT_H       CQ_H       CP_H       FOM        Angle \n");
 
       }
   
    }     

    // Write out ADB Geometry
    
    if ( Case == 0 || Case == 1 ) {

       WriteOutAerothermalDatabaseHeader();

    }

    printf("Solving... Mach: %f ... Alpha: %f ... Beta: %f \n\n",Mach_,AngleOfAttack_/TORAD,AngleOfBeta_/TORAD);fflush(NULL);

    // Header for command line status

    if ( !TimeAccurate_ ) {

             //123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789                       
       printf("                                                                    Surface Integration Forces and Moments -->                                                  Wake Induced Forces -->  \n");                
       printf("                                                                    Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-  Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake \n");
       printf("    Iter    Mach       AoA      Beta       CLo       CLi      CLtot     CDo        CDi      CDtot      L/D        E       CMxtot    CMytot    Cmztot    CLiw       CDiw    LoDwake    Ewake      T/QS      L2Res    MaxRes  Wall_Time \n");

    }
    
    else {
       
             //123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789                       
       printf("                                                                    Surface Integration Forces and Moments -->                                                  Wake Induced Forces -->  \n");                
       printf("                                                                    Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-Surf-  Wake-Wake-Wake-Wake-Wake-Wake-Wake-Wake \n");
       printf("   Time      Iter      Mach       AoA      Beta       CLo       CLi      CLtot     CDo        CDi      CDtot      L/D        E       CMxtot    CMytot    Cmztot    CLiw      CDiw    LoDwake    Ewake      T/QS      L2Res    MaxRes  Wall_Time \n");

    }       
    
    // Set wake iterations to zero if we are just processing the geometry to view/debug in viewer
    
    if ( DumpGeom_ ) WakeIterations_ = 0;

    // Solve at the each time step... or single solve if just a steady state solution

    if ( !TimeAccurate_ ) NumberOfTimeSteps_ = 1;
    
    // If time accurate, write out current t=0 solution state
    
    if ( TimeAccurate_ ) {
       
        snprintf(CaseString_,sizeof(CaseString_)*sizeof(char),"Time: %-f ...",0.);
       
        WriteOutAerothermalDatabaseGeometry();
       
        WriteOutAerothermalDatabaseSolution();
    
    }

    // Update geometry for control surfaces

    VSPGeom().DeflectControlSurfaces();

    // Initialize starting geometry and wakes for unsteady cases

    if ( TimeAccurate_ ) CalculateVelocities(ALL_WAKE_GAMMAS);
    
    // Zero out gammas
 
    if ( !RestartFromPreviousSolve_ ) {
       
       for ( i = 0 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
          GammaNM2(i) = GammaNM1(i) = Gamma(i) = 0.;
          
       }
       
    }
    
    // If this is a time accurate adjoint case... we need to save the states
    
    if ( TimeAccurate_ && DoAdjointSolve_ ) {

       NumberOfTimeSamples_ = NumberOfTimeSteps_ - StartAveragingTimeStep_ + 1;

       CreateSavedStateStack(NumberOfTimeSamples_);
       
       SaveCurrentState(0);
       
    }
        
    // Do time stepping for time accurate, otherwise we are just passing through the Time loop once
    // for a steady state case

    StartSolveTime_ = myclock();

    for ( Time_ = 1 ; Time_ <= NumberOfTimeSteps_ ; Time_++ ) {

       // Time shift gammas
       
       if ( TimeAccurate_ ) {
          
          for ( i = 0 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
             
             GammaNM2(i) = GammaNM1(i);
          
             GammaNM1(i) = Gamma(i);
          
          }
          
       }
     
       CurrentTime_ = Time_*DeltaTime_;
              
       if ( !TimeAccurate_ ) CurrentTime_ = 0.;
       
       // Forward solve iterations
       
       CurrentWakeIteration_ = 1;
       
       // Freeze wake root vortices
       
       if ( FreezeWakeRootVortices_ ) VSPGeom().FreezeWakeRootVortices(FreezeWakeRootVortices_);
       
       // Freeze the wake grids if the waker iterations is 0

       if ( WakeIterations_ == 0 && !TimeAccurate_ ) {
          
          VSPGeom().FreezeWakeGrids();
          
          WakeIterations_ = 1;
          
          CurrentWakeIteration_ = 1;
          
       }

       if ( TimeAccurate_ ) {
          
          UpdateWakeConvectedDistance();

          UpdateGeometryLocation();

          if ( Time_ <= VSPGeom().NumberOfWakeTrailingNodes() && FreezeMultiPoleAtIteration_ > 0 ) CreateSurfaceVorticesInteractionList();

       }
          
       Converged = 0;
       
       while ( CurrentWakeIteration_ <= WakeIterations_ && !Converged ) {

          // Update the vortex interaction lists

          if ( ( CurrentWakeIteration_ > 1 && CurrentWakeIteration_ <= FreezeMultiPoleAtIteration_ && VSPGeom().NumberOfVortexSheets() > 0 ) && !TimeAccurate_ ) CreateSurfaceVorticesInteractionList();

          // Freeze the wake 
          
          if ( CurrentWakeIteration_ >= FreezeWakeAtIteration_  ) VSPGeom().FreezeWakeGrids();
          
          // Update the free stream for the wake edges
          
          if ( NumberOfRotors_ > 0 || NumberOfEngineFaces_ > 0 || TimeAccurate_ || VSPGeom().ThereAreRotors() ) UpdateEdgeFreeStreamVelocities();

          // Solve the linear system

          SolveForwardLinearSystem();

          // Update residual if this is the last iteration
                   
          if ( CurrentWakeIteration_ == WakeIterations_ && ImplicitWake_ && !TimeAccurate_ ) {
      
             CalculateResidual();
             
             L2Residual_ = sqrt(L2Residual_/NumberOfEquations_);
              
          }
            
          // Update the velocities on the last iteration
          
          if ( CurrentWakeIteration_ == WakeIterations_ ) CalculateVelocities(ALL_WAKE_GAMMAS);
   
          // Calculate forces
            
          CalculateForces();

          // Output status

          OutputStatusFile(0);
          
          // Write out group data, and any rotor data
     
          if ( !TimeAccurate_ && !DumpGeom_ ) OutputForcesAndMomentsForGroup(0);   

          if ( log10(MaxResidual_) <= log10(0.001*NonLinearConvergenceFactor_) || ( TimeAccurate_ && log10(MaxResidual_) <= log10(0.001*NonLinearConvergenceFactor_) ) ) Converged = 1;

          // Some time accurate FD debug code
          
          if ( 0 && TimeAccurate_ ) {
             
             if ( UnsteadyFDTest_ > 0 && Time_ == NumberOfTimeSteps_ && log10(MaxResidual_) <= log10(0.001*NonLinearConvergenceFactor_) ) {
             
                printf("Converged: %d \n",Converged);
                
                TestTotalUnsteadyForceGradients();
                
                CurrentWakeIteration_ = 1;      
                
                Converged = 0;     
                
                if ( UnsteadyFDTest_ == 3 ) Converged = 1;                     
             
             }
                          
             if ( UnsteadyFDTest_ == 0 && Time_ == NumberOfTimeSteps_ && log10(MaxResidual_) <= log10(0.001*NonLinearConvergenceFactor_) ) {
                
                TestTotalUnsteadyForceGradients();
                
                CurrentWakeIteration_ = 1;
                
                Converged = 0;
                
             }
            
          }

          CurrentWakeIteration_++;
             
       }

       if ( TimeAccurate_ ) { OutputStatusFile(1); }
       
       // Save the state for later adjoint solver

       if ( TimeAccurate_ && DoAdjointSolve_ && Time_ >= StartAveragingTimeStep_ ) {
           
          SaveCurrentState(Time_ - StartAveragingTimeStep_ + 1);
          
       }
    
       // Solve the adjoint system
              
       if ( ( DoAdjointSolve_ && !TimeAccurate_ ) || ( DoAdjointSolve_ && Time_ == NumberOfTimeSteps_ ) ) {
                 
          printf("Solving adjoint linear systems ... \n");
                  
          ImplicitWakeStartIteration_ = 0;
                 
          SolveAdjointLinearSystem();
          
          if ( TimeAccurate_ ) RestoreStateToTime(NumberOfTimeSteps_ - StartAveragingTimeStep_ + 1);
          
       }

       // Debug code...

          if ( 0 ) { CreateAdjointMatrix(); exit(1); }
          
          if ( 0 ) { CreateAdjointMatrixFull(); exit(1); }
          
          if ( 0 && Time_ == NumberOfTimeSteps_ ) { CreateAdjointMatrixFull(); exit(1); };

          if ( 0 && Time_ == NumberOfTimeSteps_ ) { CreateAdjointMatrix(); exit(1); }
          
          if ( 0 ) {
             
             int Loop;
             
             for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; Loop++ ) {
                
                TestCalculateLoopNormalGradients_wrt_Mesh(MGLevel_,Loop);
             
             }
             
             fflush(NULL);exit(1);
             
          }

          if ( 0 && Time_ == NumberOfTimeSteps_  ) {
             
             int Loop;
             
             for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; Loop++ ) {
                
                TestCalculateLoopNormalGradients_wrt_Mesh(MGLevel_,Loop);
             
             }
             
             fflush(NULL);exit(1);
             
          }
          
                
          if ( 0 && !TimeAccurate_ ) { TestForceGradients(); exit(1); } 
          
          if ( 0 && !TimeAccurate_ ) { TestInducedForceGradients(); exit(1); } 
        
          if ( 0 && Time_ == NumberOfTimeSteps_ ) { TestForceGradients(); exit(1); } 
          
          if ( 0 ) { TestJacobianMatrix(); exit(1); }
          
          if ( 0 && Time_ == NumberOfTimeSteps_ ) { TestJacobianMatrix(); exit(1); }
          
          if ( 0 ) { TestEdgeCentroidGradients(); exit(1); }
              
          if ( 0 ) { CreateAdjointMatrix(); exit(1); }
          
          if ( 0 ) { TestPartialResdiual_pMesh(); exit(1); }

          if ( 0 && Time_ == NumberOfTimeSteps_ ) { TestPartialResdiual_pMesh(); exit(1); }
          
          if ( 0 ) { TestPartialResdiual_pMesh_Full();exit(1); }
          
          if ( 0 && Time_ == NumberOfTimeSteps_ ) { TestPartialResdiual_pMesh_Full();exit(1); }
         
          if ( 0 ) { TestPartialResdiual_pVinf(); exit(1); }
       
       // Write out ADB Solution for time accurate cases
       
       if ( TimeAccurate_ ) {
          
          if ( TimeAnalysisType_ == P_ANALYSIS ) {
             
             snprintf(CaseString_,sizeof(CaseString_)*sizeof(char),"T: %-f, P: %-f",CurrentTime_, Unsteady_Angle_/TORAD);
             
          }
             
          else if ( TimeAnalysisType_ == Q_ANALYSIS ) {
             
             snprintf(CaseString_,sizeof(CaseString_)*sizeof(char),"T: %-f, Q: %-f",CurrentTime_, Unsteady_Angle_/TORAD);

             
          }
          
          else if ( TimeAnalysisType_ == R_ANALYSIS ) {
             
             snprintf(CaseString_,sizeof(CaseString_)*sizeof(char),"T: %-f, R: %-f",CurrentTime_, Unsteady_Angle_/TORAD);
             
          }
                
          else {
          
             snprintf(CaseString_,sizeof(CaseString_)*sizeof(char),"Time: %-f ...",CurrentTime_);
             
          }

          WriteOutAerothermalDatabaseGeometry();
  
          InterpolateSolutionFromGrid(MGLevel_);
          
          WriteOutAerothermalDatabaseSolution();

          // Write out group data, and any rotor data
  
          OutputForcesAndMomentsForGroup(0);    
          
          // Write out loading data, and any rotor loading data
          
          if ( !DumpGeom_ && VSPGeom().NumberOfVortexSheets() > 0 ) CalculateSpanWiseLoading();
                    
       }

       // Calculate survey point results for steady/unsteady results
      
       if ( NumberofSurveyPoints_ > 0 ) {
          
          if ( TimeAccurate_ ) {
             
             if ( NumberOfSurveyTimeSteps_ > 0 && (Time_/NumberOfSurveyTimeSteps_)*NumberOfSurveyTimeSteps_ == Time_ ) CalculateVelocitySurvey(Case);
             
             if ( NumberOfSurveyTimeSteps_ < 0 && Time_ >= SurveyPointsStartTime_ ) CalculateVelocitySurvey(Case);
             
          }
          
          else {
             
             CalculateVelocitySurvey(Case);
             
          }
          
       }
      
       // Calculate quad tree survey points for steady cases, and for the last time step of unsteady cases
       
       if ( !TimeAccurate_ || ( TimeAccurate_ && Time_ == NumberOfTimeSteps_ ) ) {

          if ( NumberOfQuadTrees_ > 0 ) {

             CreateQuadTreePlaneDataStructures();
                    
             CalculateQuadTreeVelocitySurvey(Case);
             
          }
          
       }          
                                            
    }

    Time_ = NumberOfTimeSteps_;

    // Output status file... time averaged quantities

    if ( TimeAccurate_ ) OutputStatusFile(1);  

    // Calculate spanwise load distributions for lifting surfaces
 
    if ( !DumpGeom_ && VSPGeom().NumberOfVortexSheets() > 0 ) CalculateSpanWiseLoading();

    // Interpolate solution from grid 1 to 0
 
    InterpolateSolutionFromGrid(MGLevel_);

    // Write out ADB Solution

    if ( !TimeAccurate_ ) {
       
       WriteOutAerothermalDatabaseGeometry();
       
       WriteOutAerothermalDatabaseSolution();
    
    }
    
    // Write out 2d FEM geometry and solution if requested
    
    if ( Write2DFEMFile_ )  {
       
       if ( Case == 0 || Case == 1 ) WriteFEM2DGeometry();
       
       if ( !DumpGeom_ ) WriteFEM2DSolution();
       
    }          

    // Write out tepclot file
    
    if ( WriteTecplotFile_ ) WriteOutTecPlotFile();
       
    // Close up files
 
    if ( Case <= 0                    ) fclose(StatusFile_);
    if ( Case <= 0                    ) fclose(LoadFile_);
    if ( Case <= 0                    ) fclose(ADBFile_);
    if ( Case <= 0                    ) fclose(ADBCaseListFile_);
    if ( Case <= 0 && Write2DFEMFile_ ) fclose(FEM2DLoadFile_);
    if ( NumberofSurveyPoints_ > 0    ) fclose(SurveyFile_);
  
    // Close any rotor coefficient files
    
    k = 0;
    
    for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
       
       fclose(GroupFile_[c]);
       
       if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) fclose(RotorFile_[++k]);
          
    }
    
    if ( RotorFile_ != NULL ) delete [] RotorFile_;
       
    if ( SaveRestartFile_ ) WriteRestartFile();

    // Restore geometry for control surfaces

    VSPGeom().UnDeflectControlSurfaces();

#ifdef MYMEMORY    
    double MemoryGB = mymemory();

    printf("Memory usage: %f GBs \n",MemoryGB);fflush(NULL);
#endif

}

/*##############################################################################
#                                                                              #
#                   VSP_SOLVER RestartAndInterrogateSolution                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestartAndInterrogateSolution(int Case)
{
     
    int i, j;
    char ADBFileName[MAX_CHAR_SIZE];
    char SurveyFileName[MAX_CHAR_SIZE];
    char QUADTREEFileName[MAX_CHAR_SIZE];
   
    // Zero out solution
   
    zero_double_array(Gamma_[0], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[0][0] = 0.;   
    zero_double_array(Gamma_[1], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[1][0] = 0.;
    zero_double_array(Gamma_[2], VSPGeom().Grid(MGLevel_).NumberOfLoops()); Gamma_[2][0] = 0.;
    zero_double_array(Delta_,    VSPGeom().Grid(MGLevel_).NumberOfLoops());    Delta_[0] = 0.;

    // Update geometry location... really just the surface velocities
             
    CurrentTime_ = CurrentNoiseTime_ = 0.;
    
    Time_ = 0;
             
    if ( TimeAccurate_ ) UpdateGeometryLocation();
                 
    // Initialize free stream
    
    InitializeFreeStream();

    // Create interaction list for fixed components

    CreateSurfaceVorticesInteractionList();

    // Initialize the wake trailing vortices

    InitializeTrailingVortices();
    
    ZeroVortexState();
    
    // Create matrix preconditioners
    
    if ( Preconditioner_ != MATCON ) CalculateDiagonal();       
       
    if ( Preconditioner_ == MATCON ) CreateMatrixPreconditioners();

    // Calculate the right hand side
    
    CalculateRightHandSide();

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

        VSPGeom().Grid(MGLevel_).LoopList(i).Gamma() = Gamma(i) = 0.;
 
    }

    // Survey points file

    if ( NumberofSurveyPoints_ > 0 ) {
       
       snprintf(SurveyFileName,sizeof(SurveyFileName)*sizeof(char),"%s.interrogate.svy",FileName_);
       
       if ( (SurveyFile_ = fopen(SurveyFileName, "w")) == NULL ) {
   
          printf("Could not open the survey file for output! \n");
   
          exit(1);
   
       }    
                          //0123456789x0123456789x0123456789x   0123456789x0123456789x0123456789x 
       fprintf(SurveyFile_, "     X          Y          Z             U          V          W \n");
       
    }

    if ( NumberOfQuadTrees_ > 0 ) {  
     
       snprintf(QUADTREEFileName,sizeof(QUADTREEFileName)*sizeof(char),"%s.quad.cases",FileName_);

       if ( (QUADTREECaseListFile_ = fopen(QUADTREEFileName, "w")) == NULL ) {
    
          printf("Could not open the aero data base case list file for output! \n");
    
          exit(1);
    
       }
       
       fprintf(QUADTREECaseListFile_,"%d\n",NumberOfQuadTrees_);

       for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {
          
          fprintf(QUADTREECaseListFile_,"%d %d %f \n",
           j,
           QuadTreeDirection(j),
           QuadTreeValue(j));
           
       }
       
       fclose(QUADTREECaseListFile_);
               
    }
      
    // Open the input adb file
    
    if ( Case == 0 || Case == 1 ) {

       snprintf(ADBFileName,sizeof(ADBFileName)*sizeof(char),"%s.adb",FileName_);
       
       if ( (InputADBFile_ = fopen(ADBFileName, "rb")) == NULL ) {
   
          printf("Could not open the aero data base file for binary input! \n");
   
          exit(1);
   
       }

       // Read in the header
       
       ReadInAerothermalDatabaseHeader();

    }
     
    if ( TimeAccurate_ && !StartFromSteadyState_ ) WakeIterations_ = 1;
    
    // Step through the entire ADB file until we get to the end

    printf("Reading in solution... \n\n");fflush(NULL);
     
    if ( !TimeAccurate_ ) {
       
       NumberOfTimeSteps_ = 0;
    
       NoiseDeltaTime_ = DeltaTime_ = 1.;
       
    }

    if ( TimeAccurate_ ) printf("NumberOfTimeSteps_: %d \n",NumberOfTimeSteps_);
      
    for ( Time_ = 0 ; Time_ <= NumberOfTimeSteps_ ; Time_++ ) {
 
       if ( TimeAccurate_ ) { printf("Time step: %d of %d \n",Time_, NumberOfTimeSteps_);fflush(NULL); };
       
       CurrentTime_ = CurrentNoiseTime_ = 0.;
       
       if ( TimeAccurate_ ) CurrentTime_ = CurrentNoiseTime_ = Time_ * DeltaTime_;
       
       // Read in the next ADB Solution

       if ( Case == 0 || Case == 1 || TimeAccurate_ ) ReadInAerothermalDatabaseGeometry();
    
       ReadInAerothermalDatabaseSolution(0);

       InterpolateExistingSolution(CurrentNoiseTime_);
                 
       UpdateVortexEdgeStrengths(MGLevel_, ALL_WAKE_GAMMAS);
    
       // Initialize the free stream conditions
                   
       InitializeFreeStream();
       
       // Update right hand side
       
       CalculateRightHandSide();
       
       // Update velocities, forces, etc
       
       CalculateForces();

       if ( NumberofSurveyPoints_ > 0 ) CalculateVelocitySurvey(Case);

       // Calculate quad tree survey points
       
       if ( NumberOfQuadTrees_ > 0 ) {

          CreateQuadTreePlaneDataStructures();
                 
          CalculateQuadTreeVelocitySurvey(Case);
 
       }    
       
       // Update geometry location and interaction lists for moving geoemtries

       if ( TimeAccurate_ ) UpdateGeometryLocation();     
  
    }
    
    // Close up files
   
    if ( Case < 0 ) fclose(InputADBFile_);

    if ( NumberofSurveyPoints_ > 0 ) fclose(SurveyFile_);

}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CalculateRightHandSide                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateRightHandSide(void)
{
 
    int i, j, k, p, Loop, Loop2, LoopF, LoopC, Edge;
    double Normal[3], Ratio;

    // Vortex loop residual

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {

       RightHandSide_[i] = -vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(), VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity());

    }

    if ( Mach_ > 1. ) {
       
       // Regularization terms
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);
             
             Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop2() + VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop1() - i;
 
             if ( i != Loop2 && vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(),VSPGeom().Grid(MGLevel_).LoopList(Loop2).Normal()) > 0. ) {
   
                RightHandSide_[i] -= SmoothFactor_*Vinf_*( Gamma(i) - Gamma(Loop2) );
                
             }
                                       
          }

       }       
       
    }    
    
    // Modify righthandside for control surface deflections

    for ( k = 1 ; k <= VSPGeom().NumberOfControlSurfaces() ; k++ ) {
    
       for ( p = 1 ; p <= VSPGeom().ControlSurface(k).NumberOfLoops() ; p++ ) {
       
          LoopF = VSPGeom().ControlSurface(k).LoopList(p);
          
          LoopC = VSPGeom().Grid(0).LoopList(LoopF).CoarseGridLoop();
          
          Ratio = VSPGeom().Grid(0).LoopList(LoopF).Area() / VSPGeom().Grid(MGLevel_).LoopList(LoopC).Area();
    
          Normal[0] = VSPGeom().Grid(MGLevel_).LoopList(LoopC).Normal()[0];
          Normal[1] = VSPGeom().Grid(MGLevel_).LoopList(LoopC).Normal()[1];
          Normal[2] = VSPGeom().Grid(MGLevel_).LoopList(LoopC).Normal()[2];

          VSPGeom().ControlSurface(k).RotateNormal(Normal);
    
          RightHandSide_[LoopC] = -Ratio * vector_dot(Normal, VSPGeom().Grid(MGLevel_).LoopList(LoopC).LocalFreeStreamVelocity());
  
       }
       
    }

    if ( VSPGeom().ModelType() == PANEL_MODEL ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
          if ( LoopIsOnBaseRegion_[i] ) RightHandSide_[i] = 0.;
                    
       }     

    }    
    
    // Engine faces
    
    for ( i = 1 ; i <= NumberOfEngineFaces_ ; i++ ) {

       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; j++ ) {
          
          if ( VSPGeom().Grid(MGLevel_).LoopList(j).SurfaceID() == EngineFace_[i].SurfaceID() ) {

             RightHandSide_[j] += EngineFace_[i].NormalVelocity();
	   
          }
          
       }

    }   


}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER SolveForwardLinearSystem                #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::SolveForwardLinearSystem(void)
{

    int k, i, j, Node, Iters, NumEq;
    double ResMax, ResRed, ResFin;
    double x1, y1, z1, x2, y2, z2, x3, y3, z3;
    double dx, dy, dz, ds_old, ds_new, Scale, WakeRelax;

    for ( i = 0 ; i <= NumberOfEquations_ ; i++ ) {
   
       Delta_[i] = 0.;
       
    }

    // Calculate the initial, preconditioned, residual

    CalculateResidual();
  
    // Update vortex loop matrix preconditioners
    
    if ( UpdateMatrixPreconditioner_ ) CreateVortexLoopMatrixPreconditioners();
 
    // Update wake node preconditioner
    
    if ( UseWakeNodeMatrixPreconditioner_ ) CreateWakeNodeMatrixPreconditioners();       
       
    DoForwardSolvePrecondition(Residual_);

    // Convergence criteria

    ResRed = 0.1;

    // Force tight convergence, this usually set for running 0 wing wake iterations
    // ... since the default is 3 wake iterations and we drive the residual down 1 order
    // of magnitude per iteration... so while that not's exactly a 3 order drop in 1
    // iteration... it is similar.
    
    if ( GMRESTightConvergence_  ) ResRed = 0.001;       
  
    ResMax = 0.1*Vref_;
    
    // Apply user reduction factor
    
    ResRed *= ForwardGMRESConvergenceFactor_;

    // Use preconditioned GMRES to solve the linear system
    
    AdjointMatrixSolve_ = 0;

    //NumEq = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + VSPGeom().NumberOfWakeResidualEquations() + VSPGeom().NumberOfStallResidualEquations();

    NumEq = NumberOfEquations_;
    
    GMRES_Solver(NumEq+1,    // Number of Equations, 0 <= i < Neq
                 3,          // Max number of outer iterations
                 500,        // Max number of inner (restart) iterations
                 1,          // Output flag, verbose = 0, or 1
                 Delta_,     // Initial guess and solution vector
                 Residual_,  // Right hand side of Ax = b
                 ResMax,     // Maximum error tolerance
                 ResRed,     // Residual reduction factor
                 ResFin,     // Final log10 of residual reduction   
                 Iters);     // Final iteration count      
                 
    AdjointMatrixSolve_ = 0;                 

    // Update surface vorticity

    for ( i = 0 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {

       Gamma(i) += Delta_[i];

    }

    // Update the wakes
    
    if ( WakeIterations_ > 0 ) UpdateWakeLocations();
    
    // Update all the multi-grid meshes

    VSPGeom().UpdateMeshes();
    
    // If time accurate, apply vortex stretching corrections
    
    if ( TimeAccurate_ ) ApplyVortexStretchingModel();

    if ( Verbose_ ) {
       
       double KelvinSum = 0.;
   
       for ( i = 0 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
   
          KelvinSum += Gamma(i);
   
       }
       
       printf("\n\nKelvin Sum: %f \n",KelvinSum);
       
    }
    
    L2Residual_ = sqrt(L2Residual_/NumberOfEquations_);
    
    if ( Verbose_) printf("\n\n\nL2Residual_: %lf \n\n\n",log10(L2Residual_));
 
}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER CalculateDiagonal                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateDiagonal(void)
{

    int i, j, Edge, Node1, Node2, Loop2;
    double q[4];
    
    zero_double_array(Diagonal_,VSPGeom().Grid(MGLevel_).NumberOfLoops());
     
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {

       // Loop 1
       
       VSPGeom().Grid(MGLevel_).EdgeList(j).Gamma() = 1.;
       
       i = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL();

       VSPGeom().Grid(MGLevel_).EdgeList(j).InducedVelocity(VSPGeom().Grid(MGLevel_).LoopList(i).xyz_c(), q);

       Diagonal_[i] += vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(), q);
       
       // Loop 2
       
       VSPGeom().Grid(MGLevel_).EdgeList(j).Gamma() = -1.;
       
       i = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR();
     
       VSPGeom().Grid(MGLevel_).EdgeList(j).InducedVelocity(VSPGeom().Grid(MGLevel_).LoopList(i).xyz_c(), q);
  
       Diagonal_[i] += vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(), q);
       
    }
 
    // If flow is supersonic add in generalized principart part of downwash
    
    if ( Mach_ > 1. ) {

//       SmoothPrincipalPart();

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {

          Diagonal_[i] += VSPGeom().Grid(MGLevel_).LoopList(i).Ws();
          
       }
       
       // Regularization terms
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);
             
             Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop2() + VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop1() - i;
   
             if ( i != Loop2 && vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(),VSPGeom().Grid(MGLevel_).LoopList(Loop2).Normal()) > 0. ) {

                Diagonal_[i] += SmoothFactor_*Vinf_;
                
             }
                                       
          }

       }   
        
    }
  
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       if ( ABS(Diagonal_[i]) == 0. ) {
        
          printf("Loop: %d on surface: %d has zero diagonal... \n",i,VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceID());fflush(NULL);
         
          printf("Area: %e \n",VSPGeom().Grid(MGLevel_).LoopList(i).Area());
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);
             
             Node1 = VSPGeom().Grid(MGLevel_).EdgeList(j).Node1();
             Node2 = VSPGeom().Grid(MGLevel_).EdgeList(j).Node2();
             
             printf("Edge: %d --> Node 1: %d @ %lf %lf %lf ... Node 2: %d @ %lf %lf %lf \n",
                    Edge,
                    Node1,
                    VSPGeom().Grid(MGLevel_).NodeList(Node1).x(),
                    VSPGeom().Grid(MGLevel_).NodeList(Node1).y(),
                    VSPGeom().Grid(MGLevel_).NodeList(Node1).z(),
                    Node2,
                    VSPGeom().Grid(MGLevel_).NodeList(Node2).x(),
                    VSPGeom().Grid(MGLevel_).NodeList(Node2).y(),
                    VSPGeom().Grid(MGLevel_).NodeList(Node2).z());
          }                    
                    
       }
     
       Diagonal_[i] = 1./Diagonal_[i];
        
    }  
    
    if ( VSPGeom().ModelType() == PANEL_MODEL ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
          if ( LoopIsOnBaseRegion_[i] ) Diagonal_[i] = 1.;
        
       }       
       
    }      
    
    // Find smallest diagonal coefficient
    
    MaxDiagonal_ = -1.e9;

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       MaxDiagonal_ = MAX(MaxDiagonal_,Diagonal_[i]);

    }    
 
}

/*##############################################################################
#                                                                              #
#           VSP_SOLVER CreateMatrixPreconditionersDataStructure                #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateMatrixPreconditionersDataStructure(void)
{
   
    // Create matrix preconditioner data structure for surface loops
    
    CreateMatrixPreconditionersDataStructureForVortexLoops();
    
    // Create matrix preconditioner data structure for wakes nodes
    
    CreateMatrixPreconditionersDataStructureForWakeNodes();       
   
}

/*##############################################################################
#                                                                              #
#      VSP_SOLVER CreateMatrixPreconditionersDataStructureForVortexLoops       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateMatrixPreconditionersDataStructureForVortexLoops(void)
{

    int i, j, k, p, Done, Loops, Level, *LoopList, *NumLoops;
    int TargetLoops, MinLoops, MaxLoops, AvgLoops;
    
    printf("Creating vortex loop matrix preconditioners data structure... \n");
    
    if ( VSPGeom().NumberOfGridLevels() == 1 ) {
       
       printf("Error... mesh too coarse, or something else failed. Stopping in CreateMatrixPreconditionersDataStructure! \n");
       fflush(NULL);
  //    exit(1);
       
    }

    else {
       
       LoopList = new int[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 1];
       
       NumLoops = new int[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 1];
       
       zero_int_array(LoopList, VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
       
       zero_int_array(NumLoops, VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
       
       // Determine level to start at
       
       TargetLoops = MIN(500, VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()/5);
 
       if ( TargetLoops < 500 ) TargetLoops = MIN(500,VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
       
       Done = 0;
       
       Level = VSPGeom().NumberOfGridLevels();
       
       printf("Starting at level: %d with a target of %d loops \n",Level,TargetLoops);
       
       while ( !Done && Level >= MGLevel_ ) {
   
          Loops = 0;
   
          for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfSurfaceLoops() ; i++ ) {
     
             NumLoops[i] = CalculateNumberOfFineLoops(Level, VSPGeom().Grid(Level).LoopList(i), LoopList);
    
             Loops = MAX(Loops,NumLoops[i]);
   
          }
          
          printf("Level: %d has MaxLoops of: %d \n",Level,Loops);
          
          if ( Loops <= 1.25*TargetLoops ) Done = 1;
   
          Level--;
          
       }
       
       Level++;
       
       printf("Using level: %d to create matrix preconditioners. \n",Level); fflush(NULL);
       
       // Now group vortex loops into groups, one each per matrix preconditioner
   
       VortexLoopMatrixPreconditionerList_ = new MATPRECON[VSPGeom().Grid(Level).NumberOfSurfaceLoops() + 1];
   
       i = 1; 
   
       Done = Loops = p = 0;
       
       zero_int_array(LoopList, VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
       
       MinLoops = 1.e9;
       MaxLoops = -MinLoops;
       AvgLoops = 0;
   
       while ( i <= VSPGeom().Grid(Level).NumberOfSurfaceLoops() && !Done ) {
     
          Loops += CalculateNumberOfFineLoops(Level, VSPGeom().Grid(Level).LoopList(i), LoopList);
   
          if ( ( Loops >= TargetLoops || Loops + NumLoops[i+1] > 1.25*TargetLoops ) || i == VSPGeom().Grid(Level).NumberOfSurfaceLoops() ) {
   
             MinLoops = MIN(MinLoops,Loops);
             MaxLoops = MAX(MaxLoops,Loops);
             AvgLoops += Loops;
             
             p++;
             
             if ( Verbose_ ) { printf("Preconditioning Matrix %d contains %d fine loops \n",p,Loops); fflush(NULL); };
      
             if ( DoAdjointSolve_ ) VortexLoopMatrixPreconditionerList_[p].ThereIsTranspose() = 1;
             
             VortexLoopMatrixPreconditionerList_[p].SizeVortexLoopList(Loops);
   
             k = 0;
             
             for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; j++ ) {
                
                if ( LoopList[j] ) VortexLoopMatrixPreconditionerList_[p].VortexLoopList(++k) = j;
   
             }
             
             if ( k != Loops ) {
                
                printf("Error in creating preconditioning matrix data structure! \n");
                printf("k: %d ... Loops: %d \n",k,Loops);
                
                fflush(NULL);
                
                exit(1);
                
             }
      
             zero_int_array(LoopList, VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
             
             Loops = 0;
             
          }
   
          i++;
           
       }
       
       AvgLoops /= p;
       
       printf("Created: %d Matrix preconditioners \n",p);
       printf("Min matrix: %d Loops \n",MinLoops);
       printf("Max matrix: %d Loops \n",MaxLoops);
       printf("Avg matrix: %d Loops \n",AvgLoops);
   
       printf("\n");
       
       NumberOfVortexLoopMatrixPreconditioners_ = p;
       
       delete [] LoopList;
       delete [] NumLoops;
       
    }
    
    // Sanity check
    
    Loops = 0;
    
    for ( i = 1 ; i <= NumberOfVortexLoopMatrixPreconditioners_ ; i++ ) {
       
       Loops += VortexLoopMatrixPreconditionerList_[i].NumberOfVortexLoops();
       
    }
    
    printf("Using %d out of %d surface loops \n",Loops,VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());fflush(NULL);
    
    if ( Loops != VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ) {
       
       printf("Error in creating the preconditioning matrices! \n");
       fflush(NULL);
       exit(1);
       
    }
          
}

/*##############################################################################
#                                                                              #
#     VSP_SOLVER CreateMatrixPreconditionersDataStructureForWakeNodes          #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateMatrixPreconditionersDataStructureForWakeNodes(void)
{

    int i, j, k, p;
    
    printf("Creating wake nodes matrix preconditioners data structure... \n");
    
    if ( VSPGeom().NumberOfGridLevels() == 1 ) {
       
       printf("Error... mesh too coarse, or something else failed. Stopping in CreateMatrixPreconditionersDataStructure! \n");
       fflush(NULL);
       exit(1);
       
    }

    else {

       // Determine number of wake precondioning matrices
       
       p = 0;
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
          p += VSPGeom().VortexSheet(k).NumberOfTrailingVortices();

       }
               
       // Allocate space for the wake matrix preconditioners
   
       NumberOfWakeNodeMatrixPreconditioners_ = p;

       WakeNodeMatrixPreconditionerList_ = new MATPRECON[NumberOfWakeNodeMatrixPreconditioners_ + 1];
              
       p = 0;
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             WakeNodeMatrixPreconditionerList_[++p].SizeWakeNodeList(VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes(),
                                                                     VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes()-1);
   
          }
          
       }
       
       // Pack the wake preconditioning data structures 

       p = 0;
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
         
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             ++p;

             // Node list

             for ( j = 1 ; j <= VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes() ; j++ ) {
 
                WakeNodeMatrixPreconditionerList_[p].WakeNodeList(j) = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j);
                
             }
 
             // Edge list

             for ( j = 1 ; j < VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes() ; j++ ) {
                
                WakeNodeMatrixPreconditionerList_[p].WakeEdgeList(j) = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalEdge(j);
                                                      
             }
             
          }
          
       }
       
    }
    
}

/*##############################################################################
#                                                                              #
#                    VSP_SOLVER CreateMatrixPreconditioners                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateMatrixPreconditioners(void)
{

    // Create matrix preconditioners for vortex loops
    
    CreateVortexLoopMatrixPreconditioners();
    
}

/*##############################################################################
#                                                                              #
#            VSP_SOLVER CreateVortexLoopMatrixPreconditioners                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateVortexLoopMatrixPreconditioners(void)
{

    int i, j, k, m, p, r, t, Neq, iLoop, jLoop, Edge, EdgeI, EdgeJ, Loop2;
    int KuttaLoop1, KuttaLoop2, Sign, Loop;
    double q[3], *Diagonal, GammaSave;
    double Tolerance, NormalDistance, Vec[3], aij;

    if ( Verbose_ ) { printf("Creating vortex loop matrix preconditioners... \n");fflush(NULL); };
    
    for ( k = 1 ; k <= NumberOfVortexLoopMatrixPreconditioners_ ; k++ ) {
      
       Neq = VortexLoopMatrixPreconditionerList_[k].NumberOfVortexLoops();
       
       for ( i = 1 ; i <= Neq ; i++ ) {
          
          for ( j = 1 ; j <= Neq ; j++ ) {
          
             VortexLoopMatrixPreconditionerList_[k].A()(i,j) = 0.;
             
             if ( DoAdjointSolve_ ) VortexLoopMatrixPreconditionerList_[k].AT()(i,j) = 0.;
             
          }
          
       }
      
       // Surface loops
       
       for ( i = 1 ; i <= Neq ; i++ ) {
         
          iLoop = VortexLoopMatrixPreconditionerList_[k].VortexLoopList(i);

          if ( !LoopIsOnBaseRegion_[iLoop] ) {

             for ( j = 1 ; j <= Neq ; j++ ) {
                
                jLoop = VortexLoopMatrixPreconditionerList_[k].VortexLoopList(j);
 
                for ( m = 1 ; m <= VSPGeom().Grid(MGLevel_).LoopList(jLoop).NumberOfEdges() ; m++ ) {
                   
                    Edge = VSPGeom().Grid(MGLevel_).LoopList(jLoop).Edge(m);
   
                    GammaSave = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma();
                    
                    VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma() = 1.;
                  
                    if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL() != jLoop ) VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma() = -1.;
                    
                    VSPGeom().Grid(MGLevel_).EdgeList(Edge).InducedVelocity(VSPGeom().Grid(MGLevel_).LoopList(iLoop).xyz_c(), q);
                    
                    aij = vector_dot(VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal(), q);
                    
                    VortexLoopMatrixPreconditionerList_[k].A()(i,j) += aij;
                    
                    if ( DoAdjointSolve_ ) VortexLoopMatrixPreconditionerList_[k].AT()(j,i) += aij;
                    
                    VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma() = GammaSave;
                    
                }
                   
             }

          }
          
          else {
  
             for ( j = 1 ; j <= Neq ; j++ ) {
                
                VortexLoopMatrixPreconditionerList_[k].A()(i,j) = 0.;
         
                if ( DoAdjointSolve_ ) VortexLoopMatrixPreconditionerList_[k].AT()(j,i) = 0.;
                
             }
             
             VortexLoopMatrixPreconditionerList_[k].A()(i,i) = 1.;
                
             if ( DoAdjointSolve_ ) VortexLoopMatrixPreconditionerList_[k].AT()(i,i) = 1.;
                
          }

       }

       // Wake loops
    
       for ( i = 1 ; i <= Neq ; i++ ) {
         
          iLoop = VortexLoopMatrixPreconditionerList_[k].VortexLoopList(i);
       
          for ( m = 1 ; m <= VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() ; m++ ) {
             
             EdgeI = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Edge(m);
             
             // If this loop has a trailing edge ... edge, then we need to add in wake contributions
             
             if ( VSPGeom().Grid(MGLevel_).EdgeList(EdgeI).IsTrailingEdge() ) {
                
                // Find the wake TE 
                
                for ( p = 1 ; p <= VSPGeom().NumberOfVortexSheets() ; p++ ) {
       
                   for ( t = 1 ; t <= VSPGeom().VortexSheet(p).NumberOfWakeLoops() ; t++ ) {
                     
                      // If this wake loop trails from the correct kutta edge... add in it's contribution
                      
                      EdgeJ = ABS(VSPGeom().VortexSheet(p).WakeLoopList(t).GlobalTrailingEdge());
                      
                      if ( EdgeJ == EdgeI ) {
                         
                         KuttaLoop1 = VSPGeom().Grid(MGLevel_).EdgeList(EdgeJ).LoopL();
                         
                         KuttaLoop2 = VSPGeom().Grid(MGLevel_).EdgeList(EdgeJ).LoopR();
                         
                         Sign = SGN(VSPGeom().VortexSheet(p).WakeLoopList(t).GlobalTrailingEdge());
                         
                         Loop = VSPGeom().VortexSheet(p).WakeLoopList(t).GlobalLoop();
                                
                         if ( iLoop == KuttaLoop1 ) Sign *=  1;
                         if ( iLoop == KuttaLoop2 ) Sign *= -1;
             
                         for ( r = 1 ; r <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; r++ ) {
                   
                            Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(r); 
                            
                            GammaSave = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma();
                            
                            VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma() = 1.;
                            
                            if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL() != Loop ) VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma() = -1.;
                            
                            for ( j = 1 ; j <= Neq ; j++ ) {
                              
                               jLoop = VortexLoopMatrixPreconditionerList_[k].VortexLoopList(j);
                                   
                               VSPGeom().Grid(MGLevel_).EdgeList(Edge).InducedVelocity(VSPGeom().Grid(MGLevel_).LoopList(jLoop).xyz_c(), q);
                               
                               aij = vector_dot(VSPGeom().Grid(MGLevel_).LoopList(jLoop).Normal(), q);
                               
                               VortexLoopMatrixPreconditionerList_[k].A()(j,i) += Sign * aij;
                               
                               if ( DoAdjointSolve_ ) VortexLoopMatrixPreconditionerList_[k].AT()(i,j) += Sign * aij;
                               
                            }
                            
                            VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma() = GammaSave;
                            
                         }
                      
                      }
                
                   }
                
                }
             
             }
              
          }
       
       }
                
    }
    
    // If flow is supersonic add in generalized principal part of downwash
    
    if ( Mach_ > 1. ) {
       
//       SmoothPrincipalPart();
       
       Diagonal = new double[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 1];
       
       zero_double_array(Diagonal, VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
      
          Diagonal[i] += VSPGeom().Grid(MGLevel_).LoopList(i).Ws();
          
       }
       
       // Regularization terms
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);
             
             Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop2() + VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop1() - i;
          
             if ( i != Loop2 && vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(),VSPGeom().Grid(MGLevel_).LoopList(Loop2).Normal()) > 0. ) {

                Diagonal_[i] += SmoothFactor_*Vinf_;
                
             }
                                       
          }

       }          
       
       for ( k = 1 ; k <= NumberOfVortexLoopMatrixPreconditioners_ ; k++ ) {
          
          Neq = VortexLoopMatrixPreconditionerList_[k].NumberOfVortexLoops();
          
          for ( i = 1 ; i <= Neq ; i++ ) {
             
             iLoop = VortexLoopMatrixPreconditionerList_[k].VortexLoopList(i);

             if ( !LoopIsOnBaseRegion_[iLoop] ) {
   
                VortexLoopMatrixPreconditionerList_[k].A()(i,i) += Diagonal[iLoop];
               
                if ( DoAdjointSolve_ ) VortexLoopMatrixPreconditionerList_[k].AT()(i,i) += Diagonal[iLoop];

             }
          
          }

       }
   
       delete [] Diagonal;
       
    }

    // Kelvin constraints nad regularization
       
    if ( NumberOfKelvinConstraints_ > 0 ) {

       // Kelvin constraints
       
       for ( k = 1 ; k <= NumberOfVortexLoopMatrixPreconditioners_ ; k++ ) {
         
          Neq = VortexLoopMatrixPreconditionerList_[k].NumberOfVortexLoops();
          
          for ( i = 1 ; i <= Neq ; i++ ) {

             for ( j = 1 ; j <= Neq ; j++ ) {
             
                VortexLoopMatrixPreconditionerList_[k].A()(i,j) += KelvinLambda_ * Vref_;
                
                if ( DoAdjointSolve_ ) VortexLoopMatrixPreconditionerList_[k].AT()(i,j) += KelvinLambda_ * Vref_;
                
             }

          }
          
       }
       
    }

    // Testing code
    
    if ( 0 ) { TestMatrixPreconditioner(); fflush(NULL); exit(1); };
         
    // Form LU decomposition of J

    if ( Verbose_ ) { printf("Creating LU decomposition of wake node forward matrix preconditioners... \n");fflush(NULL); };
    
#pragma omp parallel for schedule(dynamic)
    for ( k = 1 ; k <= NumberOfVortexLoopMatrixPreconditioners_ ; k++ ) {
       
       VortexLoopMatrixPreconditionerList_[k].LU();

    }

    // Form LU decomposition of J^T

    if ( DoAdjointSolve_ ) {

       if ( Verbose_ ) { printf("Creating LU decomposition of wake node adjoint matrix preconditioners... \n");fflush(NULL); };
    
#pragma omp parallel for schedule(dynamic)
       for ( k = 1 ; k <= NumberOfVortexLoopMatrixPreconditioners_ ; k++ ) {
          
          VortexLoopMatrixPreconditionerList_[k].LUT();
      
       }
       
    }
                           
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER CreateWakeNodeMatrixPreconditioners                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateWakeNodeMatrixPreconditioners(void)
{

    int i, j, p, iEdge, jEdge, iNode, jNode1, jNode2, *MapGlobalNodeToLocalNode;
    int ii, jj1, jj2, Neq;
    double Coef[3][9];
    
    double dq0_dx1;
    double dq0_dy1;
    double dq0_dz1;
    double dq0_dx2;
    double dq0_dy2;
    double dq0_dz2;
                          
    double dq1_dx1;
    double dq1_dy1;
    double dq1_dz1;
    double dq1_dx2;
    double dq1_dy2;
    double dq1_dz2;
                          
    double dq2_dx1;
    double dq2_dy1;
    double dq2_dz1;
    double dq2_dx2;
    double dq2_dy2;
    double dq2_dz2;

    double dq0_dxp;
    double dq0_dyp;
    double dq0_dzp;
                          
    double dq1_dxp;
    double dq1_dyp;
    double dq1_dzp;
                          
    double dq2_dxp;
    double dq2_dyp;
    double dq2_dzp;   

    double dq0_dMach;
    double dq1_dMach;
    double dq2_dMach;   

    if ( Verbose_ ) { printf("Creating wake node matrix preconditioners... \n");fflush(NULL); };
        
    MapGlobalNodeToLocalNode = new int[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    zero_int_array(MapGlobalNodeToLocalNode, VSPGeom().Grid(MGLevel_).NumberOfNodes());    
 
    for ( p = 1 ; p <= NumberOfWakeNodeMatrixPreconditioners_ ; p++ ) {
    
       Neq = 3*WakeNodeMatrixPreconditionerList_[p].NumberOfWakeNodes();
       
       for ( i = 1 ; i <= Neq ; i++ ) {
          
          for ( j = 1 ; j <= Neq ; j++ ) {
          
             WakeNodeMatrixPreconditionerList_[p].A()(i,j) = 0.;
             
             if ( DoAdjointSolve_ ) WakeNodeMatrixPreconditionerList_[p].AT()(i,j) = 0.;
             
          }
          
       }
          
       for ( i = 1 ; i <= WakeNodeMatrixPreconditionerList_[p].NumberOfWakeNodes() ; i++ ) {
         
          MapGlobalNodeToLocalNode[WakeNodeMatrixPreconditionerList_[p].WakeNodeList(i)] = i;
             
       }
    
       for ( i = 1 ; i <= WakeNodeMatrixPreconditionerList_[p].NumberOfWakeEdges() ; i++ ) {
          
          iEdge = WakeNodeMatrixPreconditionerList_[p].WakeEdgeList(i);
          
          iNode = VSPGeom().Grid(MGLevel_).EdgeList(iEdge).Node1();
          
          if ( VSPGeom().Grid(MGLevel_).EdgeList(iEdge).WakeEdgeData().Direction() == 1 ) iNode = VSPGeom().Grid(MGLevel_).EdgeList(iEdge).Node2();           
              
          for ( j = 1 ; j <= WakeNodeMatrixPreconditionerList_[p].NumberOfWakeEdges() ; j++ ) {
             
             jEdge = WakeNodeMatrixPreconditionerList_[p].WakeEdgeList(j);
             
             jNode1 = VSPGeom().Grid(MGLevel_).EdgeList(jEdge).Node1();
             jNode2 = VSPGeom().Grid(MGLevel_).EdgeList(jEdge).Node2();
             
             // Velocities induced onto edge i from edge j
             
             VSPGeom().Grid(MGLevel_).EdgeList(jEdge).dInducedVelocity_dMesh_Transpose(VSPGeom().Grid(MGLevel_).EdgeList(iEdge).xyz_c(), 
                                                                                       dq0_dx1,
                                                                                       dq0_dy1,
                                                                                       dq0_dz1,
                                                                                       dq0_dx2,
                                                                                       dq0_dy2,
                                                                                       dq0_dz2,
                                                                                       
                                                                                       dq1_dx1,
                                                                                       dq1_dy1,
                                                                                       dq1_dz1,
                                                                                       dq1_dx2,
                                                                                       dq1_dy2,
                                                                                       dq1_dz2,
                                                                                       
                                                                                       dq2_dx1,
                                                                                       dq2_dy1,
                                                                                       dq2_dz1,
                                                                                       dq2_dx2,
                                                                                       dq2_dy2,
                                                                                       dq2_dz2,
                                                                                       
                                                                                       dq0_dxp,
                                                                                       dq0_dyp,
                                                                                       dq0_dzp,
                                                                                          
                                                                                       dq1_dxp,
                                                                                       dq1_dyp,
                                                                                       dq1_dzp,
                                                                                            
                                                                                       dq2_dxp,
                                                                                       dq2_dyp,
                                                                                       dq2_dzp,
                                                                                       
                                                                                       dq0_dMach,
                                                                                       dq1_dMach,
                                                                                       dq2_dMach);
                                           
             // Matrix coefficients for edge i, wrt edge j's node 1 and 2
                                                                                    
             VSPGeom().Grid(MGLevel_).EdgeList(iEdge).dInducedVelocity_dMesh_dMesh_Forward(dq0_dx1,
                                                                                           dq0_dy1,
                                                                                           dq0_dz1,
                                                                                           dq0_dx2,
                                                                                           dq0_dy2,
                                                                                           dq0_dz2,
                                                                                           
                                                                                           dq1_dx1,
                                                                                           dq1_dy1,
                                                                                           dq1_dz1,
                                                                                           dq1_dx2,
                                                                                           dq1_dy2,
                                                                                           dq1_dz2,
                                                                                               
                                                                                           dq2_dx1,
                                                                                           dq2_dy1,
                                                                                           dq2_dz1,
                                                                                           dq2_dx2,
                                                                                           dq2_dy2,
                                                                                           dq2_dz2,
                                                                                           
                                                                                           dq0_dxp,
                                                                                           dq0_dyp,
                                                                                           dq0_dzp,
                                                                                           
                                                                                           dq1_dxp,
                                                                                           dq1_dyp,
                                                                                           dq1_dzp,
                                                                                           
                                                                                           dq2_dxp,
                                                                                           dq2_dyp,
                                                                                           dq2_dzp,    
                                                                                                                                                                      
                                                                                           Coef);
                                                                                           
        
             ii  = MapGlobalNodeToLocalNode[iNode ];
             jj1 = MapGlobalNodeToLocalNode[jNode1];
             jj2 = MapGlobalNodeToLocalNode[jNode2];
             
             // X equation wrt edge j --> nodes 1 and 2
             
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*jj1-2) = Coef[0][0];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*jj1-1) = Coef[0][1];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*jj1  ) = Coef[0][2];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*jj2-2) = Coef[0][3];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*jj2-1) = Coef[0][4];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*jj2  ) = Coef[0][5];
          
             // Y equation wrt edge j --> nodes 1 and 2
          
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*jj1-2) = Coef[1][0];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*jj1-1) = Coef[1][1];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*jj1  ) = Coef[1][2];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*jj2-2) = Coef[1][3];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*jj2-1) = Coef[1][4];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*jj2  ) = Coef[1][5];
          
             // Z equation wrt edge j --> nodes 1 and 2
          
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*jj1-2) = Coef[2][0];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*jj1-1) = Coef[2][1];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*jj1  ) = Coef[2][2];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*jj2-2) = Coef[2][3];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*jj2-1) = Coef[2][4];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*jj2  ) = Coef[2][5];
          
             // X equation wrt edge i, node iNode
             
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*ii-2) = Coef[0][6];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*ii-1) = Coef[0][7];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-2,3*ii  ) = Coef[0][8];
                                                                    
             // Y equation wrt edge i, node iNode                    
                                                                      
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*ii-2) = Coef[1][6];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*ii-1) = Coef[1][7];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii-1,3*ii  ) = Coef[1][8];             
                                                                     
             // Z equation wrt edge i, node iNode                    
                                                                      
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*ii-2) = Coef[2][6];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*ii-1) = Coef[2][7];
             WakeNodeMatrixPreconditionerList_[p].A()(3*ii  ,3*ii  ) = Coef[2][8];
                          
          }
          
       }
       
       // Add in dx/ds ... etc ... terms .. ie, +/- 1
       
       for ( i = 2 ; i <= WakeNodeMatrixPreconditionerList_[p].NumberOfWakeNodes() ; i++ ) {

          WakeNodeMatrixPreconditionerList_[p].A()(3*i-2,3*i-2  ) += 1.;
          WakeNodeMatrixPreconditionerList_[p].A()(3*i-1,3*i-1  ) += 1.;
          WakeNodeMatrixPreconditionerList_[p].A()(3*i  ,3*i    ) += 1.;

          WakeNodeMatrixPreconditionerList_[p].A()(3*i-2,3*i-2-3) -= 1.;
          WakeNodeMatrixPreconditionerList_[p].A()(3*i-1,3*i-1-3) -= 1.;
          WakeNodeMatrixPreconditionerList_[p].A()(3*i  ,3*i  -3) -= 1.;        
            
       }       

       // First equation is just the TE BC...
       
       i = 1;
         
       for ( j = 1 ; j <= 3*WakeNodeMatrixPreconditionerList_[p].NumberOfWakeNodes() ; j++ ) {
       
         WakeNodeMatrixPreconditionerList_[p].A()(3*i-2,j) = 0.;
         WakeNodeMatrixPreconditionerList_[p].A()(3*i-1,j) = 0.;
         WakeNodeMatrixPreconditionerList_[p].A()(3*i  ,j) = 0.;
         
       }    

       WakeNodeMatrixPreconditionerList_[p].A()(3*i-2,3*i-2) = 1.;
       WakeNodeMatrixPreconditionerList_[p].A()(3*i-1,3*i-1) = 1.;
       WakeNodeMatrixPreconditionerList_[p].A()(3*i  ,3*i  ) = 1.;
                                 
       // Zero out mapper
       
       for ( i = 1 ; i <= WakeNodeMatrixPreconditionerList_[p].NumberOfWakeNodes() ; i++ ) {
          
          MapGlobalNodeToLocalNode[WakeNodeMatrixPreconditionerList_[p].WakeNodeList(i)] = 0;
             
       }
       
    }
    
    delete [] MapGlobalNodeToLocalNode;

    if ( Verbose_ ) { printf("Creating LU decomposition of wake node forward matrix preconditioners... \n");fflush(NULL); };
    
#pragma omp parallel for schedule(dynamic)
    for ( p = 1 ; p <= NumberOfWakeNodeMatrixPreconditioners_ ; p++ ) {

       WakeNodeMatrixPreconditionerList_[p].LU();

    }
 
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER CalculateNumberOfFineLoops                    #
#                                                                              #
##############################################################################*/

int VSP_SOLVER::CalculateNumberOfFineLoops(int Level, VSP_LOOP &Loop, int *LoopList)
{

    int i, FineLoops;

    FineLoops = 0;

    if ( Level == MGLevel_ + 1 ) {

       for ( i = 1 ; i <= Loop.NumberOfFineGridLoops() ; i++ ) {
    
          FineLoops++;
          
          LoopList[Loop.FineGridLoop(i)] = 1;

       }
       
    }
    
    else {
  
       for ( i = 1 ; i <= Loop.NumberOfFineGridLoops() ; i++ ) {
    
          FineLoops += CalculateNumberOfFineLoops(Level-1,VSPGeom().Grid(Level-1).LoopList(Loop.FineGridLoop(i)),LoopList);

       }
       
    }
    
    return FineLoops;

}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER DoPreconditionedMatrixMultiply                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DoPreconditionedMatrixMultiply(double *vec_in, double *vec_out)
{

    if ( !AdjointMatrixSolve_ ) {
       
       DoForwardPreconditionedMatrixMultiply(vec_in,vec_out);
       
    }
    
    else {

       DoAdjointPreconditionedMatrixMultiply(vec_in,vec_out);
       
    }

}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER DoForwardPreconditionedMatrixMultiply             #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DoForwardPreconditionedMatrixMultiply(double *vec_in, double *vec_out)
{

    // Forward matrix multiply
    
    DoForwardMatrixMultiply(vec_in,vec_out);

    // Forward matrix preconditioning
    
    DoForwardSolvePrecondition(vec_out);

}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER DoAdjointPreconditionedMatrixMultiply             #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DoAdjointPreconditionedMatrixMultiply(double *vec_in, double *vec_out)
{

    // Adjoint matrix multiply

    DoAdjointMatrixMultiply(vec_in,vec_out);

    // Adjoint matrix preconditioning
    
    DoAdjointMatrixPrecondition(vec_out);      

}

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER DoForwardMatrixMultiply                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DoForwardMatrixMultiply(double *vec_in, double *vec_out)
{

    int i, j, k, m, Node, Edge, Level, Loop, LoopL, LoopR, Loop1, Loop2, Sign, KelvinEquationOffSet;
    int Node1, Node2, Eqn1X, Eqn2X, VortexStretchingRatioEquationNumber;
    double EdgeGamma;
    double GammaTE, Chord, Velocity, DeltaGamma, StallFactor, Ratio;
    double dStallFactor, Cl_Ratio, dCl_Ratio_dGamma;
    double dCl_Ratio_dGammaTE, dABS_Cl_Ratio_dCl_Ratio, dR_dGamma, dR_dStallFactor; 
    double Fstall, pFstall_pX;

    double pCircumference_pLength;
    double pResidual_pRatio;
    double pResidual_pCircumference;
                               
    double dLength_dX1; 
    double dLength_dY1;
    double dLength_dZ1;
                      
    double dLength_dX2;
    double dLength_dY2;
    double dLength_dZ2;
    
    double dVecX_dX1;
    double dVecX_dY1;
    double dVecX_dZ1;
                     
    double dVecY_dX1;
    double dVecY_dY1;
    double dVecY_dZ1;
                      
    double dVecZ_dX1;
    double dVecZ_dY1;
    double dVecZ_dZ1;
                      
    double dVecX_dX2;
    double dVecX_dY2;
    double dVecX_dZ2;
                     
    double dVecY_dX2;
    double dVecY_dY2;
    double dVecY_dZ2;
                       
    double dVecZ_dX2;
    double dVecZ_dY2;
    double dVecZ_dZ2; 
                            
    // Zero out solution vectors
    
    zero_double_array(vec_out,NumberOfEquations_);

    zero_double_array(DeltaGamma_ ,VSPGeom().Grid(MGLevel_).NumberOfLoops());

    zero_double_array(DeltaXYZ_,3*VSPGeom().Grid(MGLevel_).NumberOfNodes());
    
    // Initialize dgamma
    
    dGamma(0) = 0.;

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {

       dGamma(i) = vec_in[i];
       
    }

    // Initialize dxyz
    
    dXYZ(0) = 0.;

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
        
          for ( j = 1 ; j <= VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes() ; j++ ) {
 
             // Wake node on MGLevel_ mesh
             
             Node = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j);
      
             dXYZ(3*Node-2) = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberX(j)];
             dXYZ(3*Node-1) = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberY(j)];
             dXYZ(3*Node  ) = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberZ(j)];
 
          }
 
       }
       
    }

    if ( StallModelIsOn_ ) {

       // Initialize stall delta factors
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
           
             VSPGeom().VortexSheet(k).TrailingVortex(i).dStallFactor() = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];
   
          }
          
       }
       
    }
    
    else {
       
       // Initialize stall delta factors
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
           
             VSPGeom().VortexSheet(k).TrailingVortex(i).dStallFactor() = 0.;
   
          }
          
       }
       
    }

    // Propagate stall factors for each trailing vortex loop
           
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
          
          j = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaEdge();
                
          VSPGeom().VortexSheet(k).WakeLoopList(i).dStallFactor() = VSPGeom().VortexSheet(k).TrailingVortex(j).dStallFactor();
    
       }
    
    }      

    if ( TimeAccurate_ ) {
       
      for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
         for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
            
            Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
            
            if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {

               VSPGeom().VortexSheet(k).WakeLoopList(i).dVortexStretchingRatio() = vec_in[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()];

            }
            
            else {
               
               VSPGeom().VortexSheet(k).WakeLoopList(i).dVortexStretchingRatio() = 0.;
               
            }
            
         }
          
      }
      
    }
            
    // Restrict the current solution to the coarser grids

    UpdatePerturbationVortexEdgeStrengths(MGLevel_);
     
    for ( Level = MGLevel_ ; Level < NumberOfMGLevels_ ; Level++ ) {
       
       RestrictPerturbationSolutionFromGrid(Level);
           
       UpdatePerturbationVortexEdgeStrengths(Level+1);
  
    }

    // Update the vortex core widths

    UpdateVortexCoreWidths(MGLevel_, ALL_WAKE_GAMMAS);
    
    for ( Level = MGLevel_ ; Level < NumberOfMGLevels_ ; Level++ ) {
        
       RestrictVortexCoreWidthFromGrid(Level);
       
       UpdateVortexCoreWidths(Level+1, ALL_WAKE_GAMMAS);

    }
    
    // Zero out the perturbation velocities
    
    ZeroLoopPerturbationVelocities();

    // Zero edge perturbation velocities
    
    ZeroEdgePerturbationVelocities();
    
    // Explicit steady or unsteady matrix structure:
    
           //  [SurfGammas] ( dGamma ) = -( Residual )
           
           
           
    // Implicit steady state matrix structure:
    
          //  [SurfGammas][          ][          ] ( dGamma   )    ( Residual )
          //  [          ][ WakeXYZs ][          ] ( dWakeXYZ ) = -( Residual )
          //  [          ][          ][ StallEqns] ( dStall   )    ( Residual )



    // Implicit unsteady matrix structure:
    
          //  [   SurfGammas    ][                 ][                 ][                 ] ( dGamma   )    ( Residual )
          //  [                 ][    WakeXYZs     ][                 ][                 ] ( dWakeXYZ ) = -( Residual )
          //  [                 ][                 ][    StallEqns    ][                 ] ( dStall   )    ( Residual )
          //  [                 ][                 ][                 ][VortexStretchEqns] ( dRatio   )    ( Residual ) 
    
    // (1) Surface and wake, gamma induced perturbation velocities across surface loops
    
    //  [J  ][   ][   ][   ]
    //  [   ][   ][   ][   ]
    //  [   ][   ][   ][   ]
    //  [   ][   ][   ][   ]
    
    CalculateGammaPerturbationLoopVelocities();

    if ( ImplicitWake_ && CurrentWakeIteration_ >= ImplicitWakeStartIteration_ ) {
       
       // (2) Wake surface, mesh induced perturbation velocities across surface loops
       
       //  [   ][J  ][   ][   ] 
       //  [   ][   ][   ][   ]
       //  [   ][   ][   ][   ]
       //  [   ][   ][   ][   ]
        
       CalculateMeshPerturbationLoopVelocities();
    
       // (3) Wake surface, gamma induced perturbation velocities across wake edges
       
       //  [   ][   ][   ][   ] 
       //  [J  ][   ][   ][   ]
       //  [   ][   ][   ][   ] 
       //  [   ][   ][   ][   ]
              
       CalculateGammaPerturbationEdgeVelocities();

       // (4) Wake surface, mesh induced perturbation velocities across wake edges
       
       //  [   ][   ][   ][   ] 
       //  [   ][J  ][   ][   ]
       //  [   ][   ][   ][   ]
       //  [   ][   ][   ][   ]
            
       CalculateMeshPerturbationEdgeVelocities();

       // (5) Surface,stall gamma induced perturbation velocities across surface loops
       
       //  [   ][   ][J  ][   ]
       //  [   ][   ][   ][   ]
       //  [   ][   ][   ][   ]
       //  [   ][   ][   ][   ]

       CalculateStallGammaPerturbationLoopVelocities();

       // (6) Wake surface, stall gamma induced perturbation velocities across wake edges
       
       //  [   ][   ][   ][   ]
       //  [   ][   ][J  ][   ] 
       //  [   ][   ][   ][   ]
       //  [   ][   ][   ][   ]
              
       CalculateStallGammaPerturbationEdgeVelocities();

       if ( TimeAccurate_ ) {

          // (7) Surface, vortex stretching gamma induced perturbation velocities across surface loops
          
          //  [   ][   ][   ][J  ]
          //  [   ][   ][   ][   ]
          //  [   ][   ][   ][   ]
          //  [   ][   ][   ][   ]      
          
          CalculateVortexStretchingRatioGammaPerturbationLoopVelocities();
       
          // (8) Surface, vortex stretching gamma induced perturbation velocities across surface loops
          
          //  [   ][   ][   ][J  ]
          //  [   ][   ][   ][   ]
          //  [   ][   ][   ][   ]
          //  [   ][   ][   ][   ]      

           CalculateVortexStretchingRatioGammaPerturbationEdgeVelocities();
   
       } 

       // Prolongate the gamma and mesh perturbation velocities
    
       ProlongateEdgePerturbationVelocity();
             
    }

    // Prolongate perturbation velocities
    
    ProlongateLoopPerturbationVelocity();
 
    // (1+2+5) Jxv for vorticity equation... ie q.n = 0

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {

       vec_out[i] = vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(), VSPGeom().Grid(MGLevel_).LoopList(i).dVelocity_dGamma())
                  + vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(), VSPGeom().Grid(MGLevel_).LoopList(i).dVelocity_dMesh() )
                  + vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(), VSPGeom().Grid(MGLevel_).LoopList(i).dVelocity_dStall())
                  + vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(), VSPGeom().Grid(MGLevel_).LoopList(i).dVelocity_dRatio());

    }

    vec_out[0] = vec_in[0];
    
    // (9) JxV for wake equations... ie wakes are streamlines
    
    //  [   ][   ][   ][   ] 
    //  [J  ][J  ][   ][   ]
    //  [   ][   ][   ][   ] 
    //  [   ][   ][   ][   ] 

    if ( ImplicitWake_ && CurrentWakeIteration_ >= ImplicitWakeStartIteration_  ) {

       // Wake residuals
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
          VSPGeom().VortexSheet(k).WakeMatrixMultiply(vec_in, vec_out);
          
       }

       // (10) JxV for Kutta stall equations

       //  [   ][   ][   ][   ] 
       //  [   ][   ][   ][   ]
       //  [J  ][   ][J  ][   ] 
       //  [   ][   ][   ][   ] 
            
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
             
             Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
             
             GammaTE = Sign * VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma();
             
             Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
             
             Velocity = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[0], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[1], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[2], 2.) );

             vec_out[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()] = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];

             if ( StallModelIsOn_ > 0. && Velocity > 0. ) {
                
                DeltaGamma = Sign * VSPGeom().Grid(MGLevel_).EdgeList(Edge).dGamma();
                
                dStallFactor = VSPGeom().VortexSheet(k).TrailingVortex(i).dStallFactor();

                Cl_Ratio = GammaTE / ( 0.5 * Chord * Velocity * Clmax_2d_ );
                
                dCl_Ratio_dGammaTE = 1./( 0.5 * Chord * Velocity * Clmax_2d_ );
                
                dCl_Ratio_dGamma = dCl_Ratio_dGammaTE;

                StallFunction(ABS(Cl_Ratio),Fstall,pFstall_pX);
                
                dABS_Cl_Ratio_dCl_Ratio = 1.;
                
                if ( Cl_Ratio < 0. ) dABS_Cl_Ratio_dCl_Ratio = -1.;
            
                dR_dGamma = -pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dGamma;

                dR_dStallFactor = 1.;
     
                vec_out[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()] = dR_dStallFactor * dStallFactor + dR_dGamma * DeltaGamma;    
  
             }
             
          }
          
       }
       
       // (11) JxV for vortex stretching ratio equations
       
       //  [   ][   ][   ][   ] 
       //  [   ][   ][   ][   ]
       //  [   ][   ][   ][   ] 
       //  [   ][J  ][   ][J  ] 
              
       if ( TimeAccurate_ ) {
          
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
                
                if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
  
                 // Ratio = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio();
                 // 
                 // 
                 // 
                 // Residual_[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()] = -(Ratio * VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1) - VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(0));

                   pResidual_pRatio = VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1);
                   
                   pResidual_pCircumference = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio();
            
                   pCircumference_pLength = 1.;
                   
                   VortexStretchingRatioEquationNumber = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
                   
                   vec_out[VortexStretchingRatioEquationNumber] = pResidual_pRatio * vec_in[VortexStretchingRatioEquationNumber];
                   
                   for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; j++ ) {
                      
                      Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(j);
       
                      Node1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node1() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
                                                                          
                      Node2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node2() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
                      
                      Eqn1X = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*Node1 - 2;

                      Eqn2X = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*Node2 - 2;
                      
                      VSPGeom().Grid(MGLevel_).EdgeList(Edge).SetupGradients(dLength_dX1, 
                                                                             dLength_dY1,
                                                                             dLength_dZ1,
                                                                             
                                                                             dLength_dX2,
                                                                             dLength_dY2,
                                                                             dLength_dZ2,
                                                                             
                                                                             dVecX_dX1,
                                                                             dVecX_dY1,
                                                                             dVecX_dZ1,
                                                                                             
                                                                             dVecY_dX1,
                                                                             dVecY_dY1,
                                                                             dVecY_dZ1,
                                                                                            
                                                                             dVecZ_dX1,
                                                                             dVecZ_dY1,
                                                                             dVecZ_dZ1,
                                                                                            
                                                                             dVecX_dX2,
                                                                             dVecX_dY2,
                                                                             dVecX_dZ2,
                                                                                            
                                                                             dVecY_dX2,
                                                                             dVecY_dY2,
                                                                             dVecY_dZ2,
                                                                                            
                                                                             dVecZ_dX2,
                                                                             dVecZ_dY2,
                                                                             dVecZ_dZ2);   
                                                                           
                      vec_out[VortexStretchingRatioEquationNumber] += pResidual_pCircumference * pCircumference_pLength * dLength_dX1 * vec_in[Eqn1X  ]
                                                                    + pResidual_pCircumference * pCircumference_pLength * dLength_dY1 * vec_in[Eqn1X+1]   
                                                                    + pResidual_pCircumference * pCircumference_pLength * dLength_dZ1 * vec_in[Eqn1X+2]  
                                                                    
                                                                    + pResidual_pCircumference * pCircumference_pLength * dLength_dX2 * vec_in[Eqn2X  ]
                                                                    + pResidual_pCircumference * pCircumference_pLength * dLength_dY2 * vec_in[Eqn2X+1]   
                                                                    + pResidual_pCircumference * pCircumference_pLength * dLength_dZ2 * vec_in[Eqn2X+2];
                                                                    
                   }                                                                      
                   
                }
                
                else {
                   
                   vec_out[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()] = vec_in[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()];
                   
                }
                
             }
             
          }          
          
       }

    }
    
    else {
           
       if ( VSPGeom().NumberOfWakeResidualEquations() > 0 ){
          
          for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 1 ; i <= NumberOfEquations_ ; i++ ) {
          
             vec_out[i] = vec_in[i];
          
          }    
          
       }
       
    }   

    // If flow is supersonic add in generalized principal part of downwash
    
    if ( Mach_ > 1. ) {
       
        // SmoothPrincipalPart();
       
#pragma omp parallel for private(i,Loop1,Loop2,EdgeGamma)      
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; j++ ) {

          if ( !VSPGeom().Grid(MGLevel_).EdgeList(j).IsTrailingEdge() ) {   

             Loop1 = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL();

             Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR();
           
             // Loop 1
              
             if ( VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopLIsDownWind() ) {
              
                i = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL();
      
                EdgeGamma = VSPGeom().Grid(MGLevel_).LoopList(Loop1).dGamma();
                
                if ( !VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopRIsDownWind() ) EdgeGamma -= VSPGeom().Grid(MGLevel_).LoopList(Loop2).dGamma();
            
                EdgeGamma *= VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopLDownWindWeight();
                
                vec_out[i] += VSPGeom().Grid(MGLevel_).LoopList(i).Ws() * EdgeGamma;

             }

             // Loop 2

             if ( VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopRIsDownWind() ) {
              
                i = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR();
   
                EdgeGamma = VSPGeom().Grid(MGLevel_).LoopList(Loop2).dGamma();
                
                if ( !VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopLIsDownWind() ) EdgeGamma -= VSPGeom().Grid(MGLevel_).LoopList(Loop1).dGamma();
           
                EdgeGamma *= VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopRDownWindWeight();
                
                vec_out[i] += VSPGeom().Grid(MGLevel_).LoopList(i).Ws() * EdgeGamma;
                
             }
            
          }

       }
       
       // Regularization terms
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);
             
             Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop2() + VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop1() - i;
 
             if ( i != Loop2 && vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(),VSPGeom().Grid(MGLevel_).LoopList(Loop2).Normal()) > 0. ) {
   
                vec_out[i] += SmoothFactor_*Vinf_*( vec_in[i] - vec_in[Loop2] );
                
             }
                                       
          }

       }       
       
    }    
    
    // Base region

    if ( VSPGeom().ModelType() == PANEL_MODEL ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
          if ( LoopIsOnBaseRegion_[i] ) vec_out[i] = vec_in[i];
          
       }       
       
    }

    // Kelvin regularization
    
    if ( NumberOfKelvinConstraints_ > 0 ) {

       // Kelvin regularization
       
       for ( k = 0 ; k <= NumberOfKelvinConstraints_ ; k++ ) {
          
          KelvinGroupSum_[k] = 0.;
          
       }
       
       // Surface vorticity
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
   
          if ( LoopInKelvinConstraintGroup_[i] > 0 ) KelvinGroupSum_[LoopInKelvinConstraintGroup_[i]] += KelvinLambda_ * Vref_ * dGamma(i);
          
       }

       //// Trailing vorticity
       //
       //for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       //
       //   for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
       //      
       //      Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
       //      
       //      Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
       //
       //      LoopL = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
       //
       //      LoopR = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();
       //      
       //      KelvinGroupSum_[LoopInKelvinConstraintGroup_[LoopL]] += KelvinLambda_ * Vref_ * Sign * ( dGamma(LoopL) - dGamma(LoopR) );;
       //      
       //   }
       //   
       //}
              
       // Add in regularization terms
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
       
          if ( LoopInKelvinConstraintGroup_[i] > 0 ) vec_out[i] += KelvinGroupSum_[LoopInKelvinConstraintGroup_[i]];
       
       }

    }
         
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER CalculateGammaPerturbationLoopVelocities              #
#                                                                              #
# [J  ][   ]                                                                   # 
# [   ][   ]                                                                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateGammaPerturbationLoopVelocities(void)
{
   
    int i, j, MaxLoopTypes, LoopType, Level, Loop;
    double dU_dGamma, dV_dGamma, dW_dGamma, xyz[3], q[3];
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(dU_dGamma,dV_dGamma,dW_dGamma,j,Level,Loop,xyz,q,VortexEdge) schedule(dynamic)
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {
 
          Level = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();

          Loop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          dU_dGamma = dV_dGamma = dW_dGamma = 0.;
 
          // Only need to calculate perturbation velocities wrt gamma for loops on surface

          if ( VSPGeom().Grid(Level).LoopList(Loop).SurfaceID() > 0 ) {
   
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
   
                // Calculate gamma perturbation influence of this edge

                VortexEdge->dInducedVelocity_dGamma(VSPGeom().Grid(Level).LoopList(Loop).xyz_c(),q);
        
                dU_dGamma += q[0];
                dV_dGamma += q[1];
                dW_dGamma += q[2];
                              
                // If there is ground effects, z plane...
                
                if ( DoGroundEffectsAnalysis() ) {
      
                   xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                  
                   xyz[2] *= -1.;
                  
                   VortexEdge->dInducedVelocity_dGamma(xyz, q);
            
                   q[2] *= -1.;
                
                   dU_dGamma += q[0];
                   dV_dGamma += q[1];
                   dW_dGamma += q[2];
        
                }    
                             
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
      
                   xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                  
                   xyz[1] *= -1.;
                  
                   VortexEdge->dInducedVelocity_dGamma(xyz, q);
            
                   q[1] *= -1.;
        
                   dU_dGamma += q[0];
                   dV_dGamma += q[1];
                   dW_dGamma += q[2];
                     
                   if ( DoGroundEffectsAnalysis() ) {
      
                      xyz[2] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dGamma(xyz, q);
               
                      q[1] *= -1.;
                      q[2] *= -1.;
      
                      dU_dGamma += q[0];
                      dV_dGamma += q[1];
                      dW_dGamma += q[2];
                     
                   }                   
                  
                }             
      
             }
           
          }
          
          VSPGeom().Grid(Level).LoopList(Loop).dU_dGamma() += dU_dGamma;
          VSPGeom().Grid(Level).LoopList(Loop).dV_dGamma() += dV_dGamma;   
          VSPGeom().Grid(Level).LoopList(Loop).dW_dGamma() += dW_dGamma;

       }   
       
    }
       
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER CalculateMeshPerturbationLoopVelocities               #
#                                                                              #
# [   ][J  ]                                                                   #
# [   ][   ]                                                                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateMeshPerturbationLoopVelocities(void)
{
   
    int i, j, k, MaxLoopTypes, LoopType, Level, Loop, Node;
    double dU_dMesh, dV_dMesh, dW_dMesh, xyz[3], dxyz_i[3], q[3];
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;
    
    // Mesh perturbation induced gamma perturbation velocities across wake loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(dU_dMesh,dV_dMesh,dW_dMesh,j,Level,Loop,xyz,dxyz_i,q,VortexEdge,k,Node) schedule(dynamic)
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {
 
          Level = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();

          Loop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          dxyz_i[0] = 0.;
          dxyz_i[1] = 0.;
          dxyz_i[2] = 0.;

          dU_dMesh = dV_dMesh = dW_dMesh = 0.;
 
          // Only need to calculate perturbation velocities wrt mesh for loops on surface

          if ( VSPGeom().Grid(Level).LoopList(Loop).SurfaceID() > 0 ) {
   
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                if ( VortexEdge->SurfaceID() == 0 ) {
                 
                   // Calculate mesh perturbation influence of this edge
        
                   VortexEdge->dInducedVelocity_dMesh(VSPGeom().Grid(Level).LoopList(Loop).xyz_c(), dxyz_i, q);
          
                   dU_dMesh += q[0];
                   dV_dMesh += q[1];
                   dW_dMesh += q[2];
                                 
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                      xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                     
                      xyz[2] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dMesh(xyz, dxyz_i, q);
               
                      q[2] *= -1.;
     
                      dU_dMesh += q[0];
                      dV_dMesh += q[1];
                      dW_dMesh += q[2];
           
                   }    
                                
                   // If there is a symmetry plane, calculate influence of the reflection
                   
                   if ( DoSymmetryPlaneSolve_ ) {
         
                      xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                     
                      xyz[1] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dMesh(xyz, dxyz_i, q);
               
                      q[1] *= -1.;
           
                      dU_dMesh += q[0];
                      dV_dMesh += q[1];
                      dW_dMesh += q[2];
                        
                      if ( DoGroundEffectsAnalysis() ) {
         
                         xyz[2] *= -1.;
                        
                         VortexEdge->dInducedVelocity_dMesh(xyz, dxyz_i, q);
                  
                         q[1] *= -1.;
                         q[2] *= -1.;
     
                         dU_dMesh += q[0];
                         dV_dMesh += q[1];
                         dW_dMesh += q[2];
                        
                      }                   
                     
                   }    
                
                } 
      
             }
           
          }
          
          VSPGeom().Grid(Level).LoopList(Loop).dU_dMesh() += dU_dMesh;
          VSPGeom().Grid(Level).LoopList(Loop).dV_dMesh() += dV_dMesh;   
          VSPGeom().Grid(Level).LoopList(Loop).dW_dMesh() += dW_dMesh;

       }   
       
    }    
    
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER CalculateGammaPerturbationEdgeVelocities              #
#                                                                              #
#  [   ][   ]                                                                  #
#  [J  ][   ]                                                                  #
*                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateGammaPerturbationEdgeVelocities(void)
{
   
    int i, j, Edge, MaxLoopTypes, LoopType, Level;
    double dU_dGamma, dV_dGamma, dW_dGamma, xyz[3], q[3];
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across wake edges

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(dU_dGamma,dV_dGamma,dW_dGamma,j,Edge,Level,q,VortexEdge,xyz) schedule(dynamic)          
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
   
          Level = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          Edge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          if ( VSPGeom().Grid(Level).EdgeList(Edge).SurfaceID() == 0 ) {
           
             dU_dGamma = dV_dGamma = dW_dGamma = 0.;
 
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
       
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                VortexEdge->dInducedVelocity_dGamma(VSPGeom().Grid(Level).EdgeList(Edge).xyz_c(), q);

                dU_dGamma += q[0];
                dV_dGamma += q[1];
                dW_dGamma += q[2];

                // If there is ground effects, z plane...
                
                if ( DoGroundEffectsAnalysis() ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
         
                   xyz[2] *= -1.;
                  
                   VortexEdge->dInducedVelocity_dGamma(xyz, q);        
         
                   q[2] *= -1.;
                  
                   dU_dGamma += q[0];
                   dV_dGamma += q[1];
                   dW_dGamma += q[2];
                  
                }     
                          
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
         
                   xyz[1] *= -1.;
                  
                   VortexEdge->dInducedVelocity_dGamma(xyz, q);        
         
                   q[1] *= -1.;
                  
                   dU_dGamma += q[0];
                   dV_dGamma += q[1];
                   dW_dGamma += q[2];
                   
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                      xyz[2] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dGamma(xyz, q);        
            
                      q[1] *= -1.;         
                      q[2] *= -1.;
                     
                      dU_dGamma += q[0];
                      dV_dGamma += q[1];
                      dW_dGamma += q[2];
                     
                   }                     
                  
                }                

             }
             
             VSPGeom().Grid(Level).EdgeList(Edge).dU_dGamma() += dU_dGamma;
             VSPGeom().Grid(Level).EdgeList(Edge).dV_dGamma() += dV_dGamma;   
             VSPGeom().Grid(Level).EdgeList(Edge).dW_dGamma() += dW_dGamma; 
                
          }

       }
       
    }
    
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER CalculateMeshPerturbationEdgeVelocities               #
#                                                                              #
# [   ][    ]                                                                  # 
# [   ][J   ]                                                                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateMeshPerturbationEdgeVelocities(void)
{
   
    int i, j, MaxLoopTypes, LoopType, Level, Edge;
    double dU_dMesh, dV_dMesh, dW_dMesh, xyz[3], dxyz_i[3], dxyz_j[3], q[3];
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;
 
    // Surface mesh induced gamma perturbation velocities across wake edges

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(dU_dMesh,dV_dMesh,dW_dMesh,j,Edge,Level,q,VortexEdge,xyz,dxyz_i) schedule(dynamic)          
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
   
          Level = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          Edge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          if ( VSPGeom().Grid(Level).EdgeList(Edge).SurfaceID() == 0 ) {

             dxyz_i[0] = 0.;
             dxyz_i[1] = 0.;
             dxyz_i[2] = 0.;

             dxyz_i[0] = 0.5*( VSPGeom().Grid(Level).EdgeList(Edge).dXYZ1()[0] + VSPGeom().Grid(Level).EdgeList(Edge).dXYZ2()[0] );
             dxyz_i[2] = 0.5*( VSPGeom().Grid(Level).EdgeList(Edge).dXYZ1()[2] + VSPGeom().Grid(Level).EdgeList(Edge).dXYZ2()[2] );
 
             if ( !VSPGeom().Grid(Level).EdgeList(Edge).Node1_IsOnSymmetryPlane() ) {

                dxyz_i[1] += 0.5*VSPGeom().Grid(Level).EdgeList(Edge).dXYZ1()[1];
                
             }
                
             if ( !VSPGeom().Grid(Level).EdgeList(Edge).Node2_IsOnSymmetryPlane() ) {

                dxyz_i[1] += 0.5*VSPGeom().Grid(Level).EdgeList(Edge).dXYZ2()[1];
                
             }
 
             if ( VSPGeom().Grid(Level).EdgeList(Edge).IsSymmetryPlaneEdge() ) dxyz_i[1] = 0.;

             dU_dMesh = dV_dMesh = dW_dMesh = 0.;
 
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
       
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
   
                VortexEdge->dInducedVelocity_dMesh(VSPGeom().Grid(Level).EdgeList(Edge).xyz_c(), dxyz_i, q);
       
                dU_dMesh += q[0];
                dV_dMesh += q[1];
                dW_dMesh += q[2];
                      
                // If there is ground effects, z plane...
                
                if ( DoGroundEffectsAnalysis() ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
         
                   xyz[2] *= -1.;
                  
                   VortexEdge->dInducedVelocity_dMesh(xyz, dxyz_i, q);
         
                   q[2] *= -1.;                   
                  
                   dU_dMesh += q[0];
                   dV_dMesh += q[1];
                   dW_dMesh += q[2];
                  
                }     
                          
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
         
                   xyz[1] *= -1.;    
                   
                   VortexEdge->dInducedVelocity_dMesh(xyz, dxyz_i, q);
       
                   q[1] *= -1.;
          
                   dU_dMesh += q[0];
                   dV_dMesh += q[1];
                   dW_dMesh += q[2];
 
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                      xyz[2] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dMesh(xyz, dxyz_i, q);
            
                      q[1] *= -1.;         
                      q[2] *= -1.;

                      dU_dMesh += q[0];
                      dV_dMesh += q[1];
                      dW_dMesh += q[2];
                     
                   }                     
                  
                }     
                
             }

             VSPGeom().Grid(Level).EdgeList(Edge).dU_dMesh() += dU_dMesh;
             VSPGeom().Grid(Level).EdgeList(Edge).dV_dMesh() += dV_dMesh;   
             VSPGeom().Grid(Level).EdgeList(Edge).dW_dMesh() += dW_dMesh; 
             
          }

       }
       
    }
    
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER CalculateStallGammaPerturbationLoopVelocities         #
#                                                                              #
# [J  ][   ]                                                                   # 
# [   ][   ]                                                                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateStallGammaPerturbationLoopVelocities(void)
{
   
    int i, j, MaxLoopTypes, LoopType, Level, Loop;
    double dU_dStall, dV_dStall, dW_dStall, xyz[3], q[3];
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(dU_dStall,dV_dStall,dW_dStall,j,Level,Loop,xyz,q,VortexEdge) schedule(dynamic)
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {
 
          Level = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();

          Loop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          dU_dStall = dV_dStall = dW_dStall = 0.;
 
          // Only need to calculate perturbation velocities wrt gamma for loops on surface

          if ( VSPGeom().Grid(Level).LoopList(Loop).SurfaceID() > 0 ) {
   
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
   
                if ( VortexEdge->SurfaceID() == 0 ) {
                   
                   // Calculate gamma perturbation influence of this edge
        
                   VortexEdge->dInducedVelocity_dStallGamma(VSPGeom().Grid(Level).LoopList(Loop).xyz_c(), q);
           
                   dU_dStall += q[0];
                   dV_dStall += q[1];
                   dW_dStall += q[2];
                                 
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                      xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                     
                      xyz[2] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dStallGamma(xyz, q);
               
                      q[2] *= -1.;
                   
                      dU_dStall += q[0];
                      dV_dStall += q[1];
                      dW_dStall += q[2];
           
                   }    
                                
                   // If there is a symmetry plane, calculate influence of the reflection
                   
                   if ( DoSymmetryPlaneSolve_ ) {
         
                      xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                     
                      xyz[1] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dStallGamma(xyz, q);
               
                      q[1] *= -1.;
           
                      dU_dStall += q[0];
                      dV_dStall += q[1];
                      dW_dStall += q[2];
                        
                      if ( DoGroundEffectsAnalysis() ) {
         
                         xyz[2] *= -1.;
                        
                         VortexEdge->dInducedVelocity_dStallGamma(xyz, q);
                  
                         q[1] *= -1.;
                         q[2] *= -1.;
         
                         dU_dStall += q[0];
                         dV_dStall += q[1];
                         dW_dStall += q[2];
                        
                      }                   
                     
                   }             
                   
                }
      
             }
           
          }
          
          VSPGeom().Grid(Level).LoopList(Loop).dU_dStall() += dU_dStall;
          VSPGeom().Grid(Level).LoopList(Loop).dV_dStall() += dV_dStall;   
          VSPGeom().Grid(Level).LoopList(Loop).dW_dStall() += dW_dStall;

       }   
       
    }
       
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER CalculateStallGammaPerturbationEdgeVelocities         #
#                                                                              #
#  [   ][   ]                                                                  #
#  [J  ][   ]                                                                  #
*                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateStallGammaPerturbationEdgeVelocities(void)
{
   
    int i, j, Edge, MaxLoopTypes, LoopType, Level;
    double dU_dStall, dV_dStall, dW_dStall, xyz[3], q[3];
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across wake edges

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(dU_dStall,dV_dStall,dW_dStall,j,Edge,Level,q,VortexEdge,xyz) schedule(dynamic)          
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
   
          Level = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          Edge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          if ( VSPGeom().Grid(Level).EdgeList(Edge).SurfaceID() == 0 ) {
           
             dU_dStall = dV_dStall = dW_dStall = 0.;
 
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
       
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
                
                if ( VortexEdge->SurfaceID() == 0 ) {

                   VortexEdge->dInducedVelocity_dStallGamma(VSPGeom().Grid(Level).EdgeList(Edge).xyz_c(), q);
   
                   dU_dStall += q[0];
                   dV_dStall += q[1];
                   dW_dStall += q[2];
   
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
                      
                      xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
            
                      xyz[2] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dStallGamma(xyz, q);        
            
                      q[2] *= -1.;
                     
                      dU_dStall += q[0];
                      dV_dStall += q[1];
                      dW_dStall += q[2];
                     
                   }     
                             
                   // If there is a symmetry plane, calculate influence of the reflection
                   
                   if ( DoSymmetryPlaneSolve_ ) {
                      
                      xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
            
                      xyz[1] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dStallGamma(xyz, q);        
            
                      q[1] *= -1.;
                     
                      dU_dStall += q[0];
                      dV_dStall += q[1];
                      dW_dStall += q[2];
                      
                      // If there is ground effects, z plane...
                      
                      if ( DoGroundEffectsAnalysis() ) {
            
                         xyz[2] *= -1.;
                        
                         VortexEdge->dInducedVelocity_dStallGamma(xyz, q);        
               
                         q[1] *= -1.;         
                         q[2] *= -1.;
                        
                         dU_dStall += q[0];
                         dV_dStall += q[1];
                         dW_dStall += q[2];
                        
                      }                     
                     
                   } 
                   
                }               

             }
             
             VSPGeom().Grid(Level).EdgeList(Edge).dU_dStall() += dU_dStall;
             VSPGeom().Grid(Level).EdgeList(Edge).dV_dStall() += dV_dStall;   
             VSPGeom().Grid(Level).EdgeList(Edge).dW_dStall() += dW_dStall; 
                
          }

       }
       
    }
    
}

/*##############################################################################
#                                                                              #
#   VSP_SOLVER CalculateVortexStretchingRatioGammaPerturbationLoopVelocities   #
#                                                                              #
# [J  ][   ]                                                                   # 
# [   ][   ]                                                                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateVortexStretchingRatioGammaPerturbationLoopVelocities(void)
{
   
    int i, j, MaxLoopTypes, LoopType, Level, Loop;
    double dU_dRatio, dV_dRatio, dW_dRatio, xyz[3], q[3];
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(dU_dRatio,dV_dRatio,dW_dRatio,j,Level,Loop,xyz,q,VortexEdge) schedule(dynamic)
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {
 
          Level = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();

          Loop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          dU_dRatio = dV_dRatio = dW_dRatio = 0.;
 
          // Only need to calculate perturbation velocities wrt gamma for loops on surface

          if ( VSPGeom().Grid(Level).LoopList(Loop).SurfaceID() > 0 ) {
   
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
   
                if ( VortexEdge->SurfaceID() == 0 ) {
                   
                   // Calculate gamma perturbation influence of this edge
        
                   VortexEdge->dInducedVelocity_dVortexStretchingRatio(VSPGeom().Grid(Level).LoopList(Loop).xyz_c(), q);
           
                   dU_dRatio += q[0];
                   dV_dRatio += q[1];
                   dW_dRatio += q[2];
                                 
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                      xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                     
                      xyz[2] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dVortexStretchingRatio(xyz, q);
               
                      q[2] *= -1.;
                   
                      dU_dRatio += q[0];
                      dV_dRatio += q[1];
                      dW_dRatio += q[2];
           
                   }    
                                
                   // If there is a symmetry plane, calculate influence of the reflection
                   
                   if ( DoSymmetryPlaneSolve_ ) {
         
                      xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                     
                      xyz[1] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dVortexStretchingRatio(xyz, q);
               
                      q[1] *= -1.;
           
                      dU_dRatio += q[0];
                      dV_dRatio += q[1];
                      dW_dRatio += q[2];
                        
                      if ( DoGroundEffectsAnalysis() ) {
         
                         xyz[2] *= -1.;
                        
                         VortexEdge->dInducedVelocity_dVortexStretchingRatio(xyz, q);
                  
                         q[1] *= -1.;
                         q[2] *= -1.;
         
                         dU_dRatio += q[0];
                         dV_dRatio += q[1];
                         dW_dRatio += q[2];
                        
                      }                   
                     
                   }             
                   
                }
      
             }
           
          }
          
          VSPGeom().Grid(Level).LoopList(Loop).dU_dRatio() += dU_dRatio;
          VSPGeom().Grid(Level).LoopList(Loop).dV_dRatio() += dV_dRatio;   
          VSPGeom().Grid(Level).LoopList(Loop).dW_dRatio() += dW_dRatio;

       }   
       
    }
       
}

/*##############################################################################
#                                                                              #
#   VSP_SOLVER CalculateVortexStretchingRatioGammaPerturbationEdgeVelocities   #
#                                                                              #
#  [   ][   ]                                                                  #
#  [J  ][   ]                                                                  #
*                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateVortexStretchingRatioGammaPerturbationEdgeVelocities(void)
{
   
    int i, j, Edge, MaxLoopTypes, LoopType, Level;
    double dU_dRatio, dV_dRatio, dW_dRatio, xyz[3], q[3];
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across wake edges

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(dU_dRatio,dV_dRatio,dW_dRatio,j,Edge,Level,q,VortexEdge,xyz) schedule(dynamic)          
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
   
          Level = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          Edge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          if ( VSPGeom().Grid(Level).EdgeList(Edge).SurfaceID() == 0 ) {
           
             dU_dRatio = dV_dRatio = dW_dRatio = 0.;
 
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
       
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
                
                if ( VortexEdge->SurfaceID() == 0 ) {

                   VortexEdge->dInducedVelocity_dVortexStretchingRatio(VSPGeom().Grid(Level).EdgeList(Edge).xyz_c(), q);
   
                   dU_dRatio += q[0];
                   dV_dRatio += q[1];
                   dW_dRatio += q[2];
   
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
                      
                      xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
            
                      xyz[2] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dVortexStretchingRatio(xyz, q);        
            
                      q[2] *= -1.;
                     
                      dU_dRatio += q[0];
                      dV_dRatio += q[1];
                      dW_dRatio += q[2];
                     
                   }     
                             
                   // If there is a symmetry plane, calculate influence of the reflection
                   
                   if ( DoSymmetryPlaneSolve_ ) {
                      
                      xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                      xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                      xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
            
                      xyz[1] *= -1.;
                     
                      VortexEdge->dInducedVelocity_dVortexStretchingRatio(xyz, q);        
            
                      q[1] *= -1.;
                     
                      dU_dRatio += q[0];
                      dV_dRatio += q[1];
                      dW_dRatio += q[2];
                      
                      // If there is ground effects, z plane...
                      
                      if ( DoGroundEffectsAnalysis() ) {
            
                         xyz[2] *= -1.;
                        
                         VortexEdge->dInducedVelocity_dVortexStretchingRatio(xyz, q);        
               
                         q[1] *= -1.;         
                         q[2] *= -1.;
                        
                         dU_dRatio += q[0];
                         dV_dRatio += q[1];
                         dW_dRatio += q[2];
                        
                      }                     
                     
                   } 
                   
                }               

             }
             
             VSPGeom().Grid(Level).EdgeList(Edge).dU_dRatio() += dU_dRatio;
             VSPGeom().Grid(Level).EdgeList(Edge).dV_dRatio() += dV_dRatio;   
             VSPGeom().Grid(Level).EdgeList(Edge).dW_dRatio() += dW_dRatio; 
                
          }

       }
       
    }
    
}
 
/*##############################################################################
#                                                                              #
#                      VSP_SOLVER ZeroLoopVelocities                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroLoopVelocities(void) 
{
 
    int Level, i;

    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfLoops() ; i++ ) {

          VSPGeom().Grid(Level).LoopList(i).U() = 0.;
          VSPGeom().Grid(Level).LoopList(i).V() = 0.;
          VSPGeom().Grid(Level).LoopList(i).W() = 0.;

       }
       
    }          
            
}

/*##############################################################################
#                                                                              #
#                      VSP_SOLVER ZeroEdgeVelocities                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroEdgeVelocities(void) 
{
 
    int Level, i;

    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {
          
          VSPGeom().Grid(Level).EdgeList(i).U() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).V() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).W() = 0.;

          VSPGeom().Grid(Level).EdgeList(i).DownWash_U() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).DownWash_V() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).DownWash_W() = 0.;
          
       }
       
    }          
            
}

/*##############################################################################
#                                                                              #
#                      VSP_SOLVER ProlongateLoopVelocity                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateLoopVelocity(void) 
{
 
    int Level, i_c, i_f, j;

    for ( Level = NumberOfMGLevels_ ; Level > 1; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfLoops() ; i_c++ ) {
         
          for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfFineGridLoops() ; j++ ) {
             
             i_f = VSPGeom().Grid(Level).LoopList(i_c).FineGridLoop(j);

             VSPGeom().Grid(Level-1).LoopList(i_f).U() += VSPGeom().Grid(Level).LoopList(i_c).U();
             VSPGeom().Grid(Level-1).LoopList(i_f).V() += VSPGeom().Grid(Level).LoopList(i_c).V();
             VSPGeom().Grid(Level-1).LoopList(i_f).W() += VSPGeom().Grid(Level).LoopList(i_c).W();

          }
          
       }
       
    }          
                  
}

/*##############################################################################
#                                                                              #
#                      VSP_SOLVER ProlongateEdgeVelocity                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateEdgeVelocity(void) 
{
 
    int Level, j, k, i_c, i_f, edge_c, edge_f;
    double U, V, W, Uw, Vw, Ww, Fact;

    for ( Level = NumberOfMGLevels_ ; Level > 1; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfLoops() ; i_c++ ) {

          // Create averaged velocity across loop, based on edge values
          
          U = V = W = 0.;
          
          Uw = Vw = Ww = 0.;
          
          for ( k = 1 ; k <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges() ; k++ ) {
             
             edge_c = VSPGeom().Grid(Level).LoopList(i_c).Edge(k);
             
             U += VSPGeom().Grid(Level).EdgeList(edge_c).U();
             V += VSPGeom().Grid(Level).EdgeList(edge_c).V();
             W += VSPGeom().Grid(Level).EdgeList(edge_c).W();

             Uw += VSPGeom().Grid(Level).EdgeList(edge_c).DownWash_U();
             Vw += VSPGeom().Grid(Level).EdgeList(edge_c).DownWash_V();
             Ww += VSPGeom().Grid(Level).EdgeList(edge_c).DownWash_W();
                  
          }
          
          U /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          V /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          W /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();

          Uw /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          Vw /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          Ww /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
                       
          for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfFineGridLoops() ; j++ ) {
             
             i_f = VSPGeom().Grid(Level).LoopList(i_c).FineGridLoop(j);
             
             for ( k = 1 ; k <= VSPGeom().Grid(Level-1).LoopList(i_f).NumberOfEdges() ; k++ ) {
                
                edge_f = VSPGeom().Grid(Level-1).LoopList(i_f).Edge(k);
                
                edge_c = VSPGeom().Grid(Level-1).EdgeList(edge_f).CoarseGridEdge();

                Fact = 0.5;
                
                if ( VSPGeom().Grid(Level-1).EdgeList(edge_f).LoopL() == 0 ||
                     VSPGeom().Grid(Level-1).EdgeList(edge_f).LoopR() == 0 ) Fact = 1.;
                                        
                // Edge does not exist on coarse grid
                
                if ( edge_c == 0 ) {

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).U() += Fact*U;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).V() += Fact*V;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).W() += Fact*W;

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).DownWash_U() += Fact*Uw;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).DownWash_V() += Fact*Vw;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).DownWash_W() += Fact*Ww;
                                      
                }
                
                else {
    
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).U() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).U();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).V() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).V();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).W() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).W();

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).DownWash_U() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).DownWash_U();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).DownWash_V() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).DownWash_V();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).DownWash_W() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).DownWash_W();
                                      
                }   
                
             }

          }
          
       }
       
    }          
                  
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER ZeroLoopPerturbationVelocities                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroLoopPerturbationVelocities(void) 
{
 
    int Level, i;

    for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfLoops() ; i++ ) {

          VSPGeom().Grid(Level).LoopList(i).dU_dGamma() = 0.;
          VSPGeom().Grid(Level).LoopList(i).dV_dGamma() = 0.;
          VSPGeom().Grid(Level).LoopList(i).dW_dGamma() = 0.;

          VSPGeom().Grid(Level).LoopList(i).dU_dMesh()  = 0.;
          VSPGeom().Grid(Level).LoopList(i).dV_dMesh()  = 0.;
          VSPGeom().Grid(Level).LoopList(i).dW_dMesh()  = 0.;

          VSPGeom().Grid(Level).LoopList(i).dU_dStall() = 0.;
          VSPGeom().Grid(Level).LoopList(i).dV_dStall() = 0.;
          VSPGeom().Grid(Level).LoopList(i).dW_dStall() = 0.;

          VSPGeom().Grid(Level).LoopList(i).dU_dRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).dV_dRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).dW_dRatio() = 0.;
                              
       }
       
    }          
            
}

/*##############################################################################
#                                                                              #
#                      VSP_SOLVER ZeroEdgePerturbationVelocities               #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroEdgePerturbationVelocities(void) 
{
 
    int Level, i;

    for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {
          
          VSPGeom().Grid(Level).EdgeList(i).dU_dGamma() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dV_dGamma() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dW_dGamma() = 0.;

          VSPGeom().Grid(Level).EdgeList(i).dU_dMesh()  = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dV_dMesh()  = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dW_dMesh()  = 0.;

          VSPGeom().Grid(Level).EdgeList(i).dU_dStall() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dV_dStall() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dW_dStall() = 0.;

          VSPGeom().Grid(Level).EdgeList(i).dU_dRatio() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dV_dRatio() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dW_dRatio() = 0.;
                    
       }
       
    }          
            
}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER ProlongateLoopPerturbationVelocity                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateLoopPerturbationVelocity(void) 
{
 
    int Level, i_c, i_f, j;

    for ( Level = NumberOfMGLevels_ ; Level > 1; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfLoops() ; i_c++ ) {
         
          for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfFineGridLoops() ; j++ ) {
             
             i_f = VSPGeom().Grid(Level).LoopList(i_c).FineGridLoop(j);

             // wrt gamma
             
             VSPGeom().Grid(Level-1).LoopList(i_f).dU_dGamma() += VSPGeom().Grid(Level).LoopList(i_c).dU_dGamma();
             VSPGeom().Grid(Level-1).LoopList(i_f).dV_dGamma() += VSPGeom().Grid(Level).LoopList(i_c).dV_dGamma();
             VSPGeom().Grid(Level-1).LoopList(i_f).dW_dGamma() += VSPGeom().Grid(Level).LoopList(i_c).dW_dGamma();

             // wrt Mesh
             
             VSPGeom().Grid(Level-1).LoopList(i_f).dU_dMesh()  += VSPGeom().Grid(Level).LoopList(i_c).dU_dMesh();
             VSPGeom().Grid(Level-1).LoopList(i_f).dV_dMesh()  += VSPGeom().Grid(Level).LoopList(i_c).dV_dMesh();
             VSPGeom().Grid(Level-1).LoopList(i_f).dW_dMesh()  += VSPGeom().Grid(Level).LoopList(i_c).dW_dMesh();

             // wrt Stall 
             
             VSPGeom().Grid(Level-1).LoopList(i_f).dU_dStall() += VSPGeom().Grid(Level).LoopList(i_c).dU_dStall();
             VSPGeom().Grid(Level-1).LoopList(i_f).dV_dStall() += VSPGeom().Grid(Level).LoopList(i_c).dV_dStall();
             VSPGeom().Grid(Level-1).LoopList(i_f).dW_dStall() += VSPGeom().Grid(Level).LoopList(i_c).dW_dStall();

             // wrt Vortex Stretching Ratio 
             
             VSPGeom().Grid(Level-1).LoopList(i_f).dU_dRatio() += VSPGeom().Grid(Level).LoopList(i_c).dU_dRatio();
             VSPGeom().Grid(Level-1).LoopList(i_f).dV_dRatio() += VSPGeom().Grid(Level).LoopList(i_c).dV_dRatio();
             VSPGeom().Grid(Level-1).LoopList(i_f).dW_dRatio() += VSPGeom().Grid(Level).LoopList(i_c).dW_dRatio();
                                       
          }
          
       }
       
    }          
                  
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER ProlongateEdgePerturbationVelocity               #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateEdgePerturbationVelocity(void) 
{
 
    int Level, j, k, i_c, i_f, edge_c, edge_f;
    double dU_dGamma, dV_dGamma, dW_dGamma;
    double dU_dMesh, dV_dMesh, dW_dMesh, Fact;
    double dU_dStall, dV_dStall, dW_dStall;
    double dU_dRatio, dV_dRatio, dW_dRatio;

    for ( Level = NumberOfMGLevels_ ; Level > 1; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfLoops() ; i_c++ ) {

          // Create averaged velocity across loop, based on edge values
          
          dU_dGamma = dV_dGamma = dW_dGamma = 0.;

          dU_dMesh = dV_dMesh = dW_dMesh = 0.;
          
          dU_dStall = dV_dStall = dW_dStall = 0.;
          
          dU_dRatio = dV_dRatio = dW_dRatio = 0.;
          
          for ( k = 1 ; k <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges() ; k++ ) {
             
             edge_c = VSPGeom().Grid(Level).LoopList(i_c).Edge(k);
             
             dU_dGamma += VSPGeom().Grid(Level).EdgeList(edge_c).dU_dGamma();
             dV_dGamma += VSPGeom().Grid(Level).EdgeList(edge_c).dV_dGamma();
             dW_dGamma += VSPGeom().Grid(Level).EdgeList(edge_c).dW_dGamma();

             dU_dMesh  += VSPGeom().Grid(Level).EdgeList(edge_c).dU_dMesh();
             dV_dMesh  += VSPGeom().Grid(Level).EdgeList(edge_c).dV_dMesh();
             dW_dMesh  += VSPGeom().Grid(Level).EdgeList(edge_c).dW_dMesh();

             dU_dStall += VSPGeom().Grid(Level).EdgeList(edge_c).dU_dStall();
             dV_dStall += VSPGeom().Grid(Level).EdgeList(edge_c).dV_dStall();
             dW_dStall += VSPGeom().Grid(Level).EdgeList(edge_c).dW_dStall();

             dU_dRatio += VSPGeom().Grid(Level).EdgeList(edge_c).dU_dRatio();
             dV_dRatio += VSPGeom().Grid(Level).EdgeList(edge_c).dV_dRatio();
             dW_dRatio += VSPGeom().Grid(Level).EdgeList(edge_c).dW_dRatio();
                                            
          }
          
          dU_dGamma /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          dV_dGamma /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          dW_dGamma /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();

          dU_dMesh  /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          dV_dMesh  /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          dW_dMesh  /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();

          dU_dStall /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          dV_dStall /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          dW_dStall /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();

          dU_dRatio /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          dV_dRatio /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          dW_dRatio /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
                                           
          for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfFineGridLoops() ; j++ ) {
             
             i_f = VSPGeom().Grid(Level).LoopList(i_c).FineGridLoop(j);
             
             for ( k = 1 ; k <= VSPGeom().Grid(Level-1).LoopList(i_f).NumberOfEdges() ; k++ ) {
                
                edge_f = VSPGeom().Grid(Level-1).LoopList(i_f).Edge(k);
                
                edge_c = VSPGeom().Grid(Level-1).EdgeList(edge_f).CoarseGridEdge();
                
                Fact = 0.5;
                
                if ( VSPGeom().Grid(Level-1).EdgeList(edge_f).LoopL() == 0 ||
                     VSPGeom().Grid(Level-1).EdgeList(edge_f).LoopR() == 0 ) Fact = 1.;
                                           
                // Edge does not exist on coarse grid
                
                if ( edge_c == 0 ) {

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dGamma() += Fact*dU_dGamma;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dGamma() += Fact*dV_dGamma;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dGamma() += Fact*dW_dGamma;

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dMesh()  += Fact*dU_dMesh;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dMesh()  += Fact*dV_dMesh;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dMesh()  += Fact*dW_dMesh;

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dStall() += Fact*dU_dStall;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dStall() += Fact*dV_dStall;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dStall() += Fact*dW_dStall;

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dRatio() += Fact*dU_dRatio;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dRatio() += Fact*dV_dRatio;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dRatio() += Fact*dW_dRatio;
                                                                            
                }
                
                else {
    
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dGamma() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dU_dGamma();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dGamma() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dV_dGamma();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dGamma() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dW_dGamma();

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dMesh()  += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dU_dMesh();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dMesh()  += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dV_dMesh();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dMesh()  += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dW_dMesh();

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dStall() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dU_dStall();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dStall() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dV_dStall();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dStall() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dW_dStall();

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dRatio() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dU_dRatio();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dRatio() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dV_dRatio();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dRatio() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dW_dRatio();
                                      
                }   
                
             }

          }
          
       }
       
    }          
                  
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER DoForwardSolvePrecondition                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DoForwardSolvePrecondition(double *vec_in)
{

    int i, j, k, p, Loop;

    // Jacobi preconditioner

    if ( Preconditioner_ == JACOBI ) {

#pragma omp parallel for
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
  
          vec_in[i] *= JacobiRelaxationFactor_*Diagonal_[i];
   
       }
       
    }

    // Matrix precondtioner
    
    else if ( Preconditioner_ == MATCON ) {

       // Wake preconditioning
       
       if ( ImplicitWake_ && CurrentWakeIteration_ >= ImplicitWakeStartIteration_ ) {

          if ( !UseWakeNodeMatrixPreconditioner_ ) {
             
             if ( !TimeAccurate_ ) {
                
                for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
                   
                   VSPGeom().VortexSheet(k).DoWakeForwardMatrixPrecondition(vec_in);
                   
                }
                
             }
             
          }
          
          else {

#pragma omp parallel for private(i,j) schedule(dynamic)          
             for ( k = 1 ; k <= NumberOfWakeNodeMatrixPreconditioners_ ; k++ ) {
             
                for ( i = 1 ; i <= WakeNodeMatrixPreconditionerList_[k].NumberOfWakeNodes() ; i++ ) {
             
                   j = WakeNodeMatrixPreconditionerList_[k].WakeNodeList(i) - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
                
                   WakeNodeMatrixPreconditionerList_[k].x(3*i-2) = vec_in[3*j-2 + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()];
                   WakeNodeMatrixPreconditionerList_[k].x(3*i-1) = vec_in[3*j-1 + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()];
                   WakeNodeMatrixPreconditionerList_[k].x(3*i  ) = vec_in[3*j   + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()];
                   
                }
                
                // Forward approximate solve
                
                WakeNodeMatrixPreconditionerList_[k].Solve();
                
                for ( i = 1 ; i <= WakeNodeMatrixPreconditionerList_[k].NumberOfWakeNodes() ; i++ ) {
             
                   j = WakeNodeMatrixPreconditionerList_[k].WakeNodeList(i) - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
             
                   vec_in[3*j-2 + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()] = WakeNodeMatrixPreconditionerList_[k].x(3*i-2);
                   vec_in[3*j-1 + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()] = WakeNodeMatrixPreconditionerList_[k].x(3*i-1);
                   vec_in[3*j   + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()] = WakeNodeMatrixPreconditionerList_[k].x(3*i  );
             
                }     
             
             }
             
          }
       
       }
       
       // Vortex stretching ratio equations
       
       if ( TimeAccurate_ && ImplicitWake_ && CurrentWakeIteration_ >= ImplicitWakeStartIteration_ ) {
          
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
                
                if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
  
                   j = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
               
                   vec_in[j] = vec_in[j] / VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1);
                   
                }
                
             }
             
          }
          
       }
           
#pragma omp parallel for private(i) schedule(dynamic)          
       for ( k = 1 ; k <= NumberOfVortexLoopMatrixPreconditioners_ ; k++ ) {

          for ( i = 1 ; i <= VortexLoopMatrixPreconditionerList_[k].NumberOfVortexLoops() ; i++ ) {

             VortexLoopMatrixPreconditionerList_[k].x(i) = vec_in[VortexLoopMatrixPreconditionerList_[k].VortexLoopList(i)];
             
          }
          
          // Forward approximate solve
          
          VortexLoopMatrixPreconditionerList_[k].Solve();
          
          for ( i = 1 ; i <= VortexLoopMatrixPreconditionerList_[k].NumberOfVortexLoops() ; i++ ) {
      
             vec_in[VortexLoopMatrixPreconditionerList_[k].VortexLoopList(i)] = VortexLoopMatrixPreconditionerList_[k].x(i);
 
          }     

       }

    }

    else {
       
       printf("Unknown forward matrix preconditioner! \n");fflush(NULL);
       exit(1);
       
    }

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER DoAdjointMatrixPrecondition                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DoAdjointMatrixPrecondition(double *vec_in)
{

    int i, j, k, p;

    // Matrix preconditioner

    if ( Preconditioner_ == MATCON ) {

       // Vorticity equations
       
#pragma omp parallel for private(i) schedule(dynamic)                    
       for ( k = 1 ; k <= NumberOfVortexLoopMatrixPreconditioners_ ; k++ ) {

          for ( i = 1 ; i <= VortexLoopMatrixPreconditionerList_[k].NumberOfVortexLoops() ; i++ ) {

             VortexLoopMatrixPreconditionerList_[k].x(i) = vec_in[VortexLoopMatrixPreconditionerList_[k].VortexLoopList(i)];
                            
          }
          
          // Adjoint approximate solve
          
          VortexLoopMatrixPreconditionerList_[k].SolveT();
          
          for ( i = 1 ; i <= VortexLoopMatrixPreconditionerList_[k].NumberOfVortexLoops() ; i++ ) {
      
             vec_in[VortexLoopMatrixPreconditionerList_[k].VortexLoopList(i)] = VortexLoopMatrixPreconditionerList_[k].x(i);
 
          }          
          
       }
       
       // Wake equations
       
       if ( !TimeAccurate_ ) {

          for ( i = 1 ; i <= VSPGeom().NumberOfVortexSheets(); i++ ) {
            
             for ( j = 1 ; j <= VSPGeom().VortexSheet(i).NumberOfTrailingVortices() ; j++ ) {
               
                if ( !VSPGeom().VortexSheet(i).TrailingVortex(j).IsFrozenTrailingEdge() ) {
               
                   k = VSPGeom().VortexSheet(i).TrailingVortex(j).NumberOfNodes();
                   
                   p = VSPGeom().VortexSheet(i).TrailingVortex(j).WakeResidualEquationNumberX(k);
                         
                   vec_in[p    ] = vec_in[p    ];     
                   vec_in[p + 1] = vec_in[p + 1];     
                   vec_in[p + 2] = vec_in[p + 2];     
                   
                   for ( k = VSPGeom().VortexSheet(i).TrailingVortex(j).NumberOfNodes() - 1 ; k >= 1 ; k-- ) {
                   
                      p = VSPGeom().VortexSheet(i).TrailingVortex(j).WakeResidualEquationNumberX(k);
                   
                      vec_in[p + 0] = vec_in[p + 3 + 0] + vec_in[p + 0];     
                      vec_in[p + 1] = vec_in[p + 3 + 1] + vec_in[p + 1];     
                      vec_in[p + 2] = vec_in[p + 3 + 2] + vec_in[p + 2];     
                   
                   }
                   
                }
         
             }
               
          }
          
       }
                 
    }

    else {
       
       printf("Unknown adjoint matrix preconditioner! \n");fflush(NULL);
       exit(1);
       
    }

}

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER CalculateVelocities                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateVelocities(int UpdateType)
{

    int Level;
    
    // Update the vortex strengths

    UpdateVortexEdgeStrengths(MGLevel_, UpdateType);
    
    for ( Level = MGLevel_ ; Level < NumberOfMGLevels_ ; Level++ ) {
        
       RestrictSolutionFromGrid(Level);
       
       UpdateVortexEdgeStrengths(Level+1, UpdateType);

    }

    // Update the vortex core widths

    UpdateVortexCoreWidths(MGLevel_, UpdateType);
    
    for ( Level = MGLevel_ ; Level < NumberOfMGLevels_ ; Level++ ) {
        
       RestrictVortexCoreWidthFromGrid(Level);
       
       UpdateVortexCoreWidths(Level+1, UpdateType);

    }
    
    // Calculate loop and edge velocities
       
    CalculateLoopVelocities();
    
    CalculateEdgeVelocities();
      
}

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER CalculateLoopVelocities                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateLoopVelocities(void)
{

    int i, j, k, v, Level, Loop, Loop1, Loop2, LoopType, MaxLoopTypes, cpu, NumberOfSheets;
    double q[3], xyz[3], Ws, U, V, W, WsMag, EdgeGamma;
    VSP_EDGE *VortexEdge;
    VORTEX_SHEET_ENTRY *VortexSheetList;

    // Freestream component... includes rotor wash, and any rotational rates
 
    ZeroLoopVelocities();
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       VSPGeom().Grid(MGLevel_).LoopList(i).U() = VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(0);
       VSPGeom().Grid(MGLevel_).LoopList(i).V() = VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(1);
       VSPGeom().Grid(MGLevel_).LoopList(i).W() = VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(2); 

    }

    // Surface vortex induced velocities

    MaxLoopTypes = 0;
    
    U = V = W = 0.;
    
    MaxLoopTypes = 0;

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(Level,Loop,U,V,W,j,VortexEdge,xyz,q) schedule(dynamic)          
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {

          Level  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();

          Loop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();
       
          U = V = W = 0.;
          
          // Only calculate velocities for surface loops

          if ( VSPGeom().Grid(Level).LoopList(Loop).SurfaceID() > 0 ) {

             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {

                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
   
                VortexEdge->InducedVelocity(VSPGeom().Grid(Level).LoopList(Loop).xyz_c(), q);
            
                U += q[0];
                V += q[1];
                W += q[2];

                // If there is ground effects, z plane...
                
                if ( DoGroundEffectsAnalysis() ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
         
                   xyz[2] *= -1.;
                  
                   VortexEdge->InducedVelocity(xyz, q);        
         
                   q[2] *= -1.;
                  
                   U += q[0];
                   V += q[1];
                   W += q[2];
                  
                }     
                          
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
         
                   xyz[1] *= -1.;
                  
                   VortexEdge->InducedVelocity(xyz, q);        
         
                   q[1] *= -1.;
                  
                   U += q[0];
                   V += q[1];
                   W += q[2];
                   
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                      xyz[2] *= -1.;
                     
                      VortexEdge->InducedVelocity(xyz, q);        
            
                      q[1] *= -1.;         
                      q[2] *= -1.;
                     
                      U += q[0];
                      V += q[1];
                      W += q[2];
                     
                   }                     
                  
                }                
      
             }
             
          }
          
          VSPGeom().Grid(Level).LoopList(Loop).U() += U;
          VSPGeom().Grid(Level).LoopList(Loop).V() += V;   
          VSPGeom().Grid(Level).LoopList(Loop).W() += W;

       }
       
    }

    ProlongateLoopVelocity();
       
    // If flow is supersonic add in generalized principal part part of downwash
    
    if ( Mach_ > 1. ) {
       
      // SmoothPrincipalPart();

#pragma omp parallel for private(i,j,Ws,WsMag,Loop1,Loop2,EdgeGamma)
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; j++ ) {

   //       Ws = VSPGeom().Grid(MGLevel_).EdgeList(j).GeneralizedPrincipalPartOfDownWash();

          Loop1 = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL();
          Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR();
                    
          // Loop 1
           
          if ( VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopLIsDownWind() ) {
           
             i = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL();
                     
             EdgeGamma = VSPGeom().Grid(MGLevel_).LoopList(Loop1).Gamma();
             
             if ( !VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopRIsDownWind() ) EdgeGamma -= VSPGeom().Grid(MGLevel_).LoopList(Loop2).Gamma();
       
             WsMag = VSPGeom().Grid(MGLevel_).LoopList(i).Ws() * EdgeGamma * VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopLDownWindWeight();
             
             VSPGeom().Grid(MGLevel_).LoopList(i).U() += WsMag * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[0];
             VSPGeom().Grid(MGLevel_).LoopList(i).V() += WsMag * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[1];
             VSPGeom().Grid(MGLevel_).LoopList(i).W() += WsMag * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[2];

          }

          // Loop 2

          if ( VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopRIsDownWind() ) {
           
             i = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR();
           
             EdgeGamma = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Gamma();
             
             if ( !VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopLIsDownWind() ) EdgeGamma -= VSPGeom().Grid(MGLevel_).LoopList(Loop1).Gamma();
     
             WsMag = VSPGeom().Grid(MGLevel_).LoopList(i).Ws() * EdgeGamma * VSPGeom().Grid(MGLevel_).EdgeList(j).VortexLoopRDownWindWeight();

             VSPGeom().Grid(MGLevel_).LoopList(i).U() += WsMag * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[0];
             VSPGeom().Grid(MGLevel_).LoopList(i).V() += WsMag * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[1];
             VSPGeom().Grid(MGLevel_).LoopList(i).W() += WsMag * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[2];
            
          }

       }
       
    }   

}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER CalculateEdgeVelocities                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateEdgeVelocities(void)
{

    int i, j, k, m, p, v, Level, Edge, Loop, Loop1, Loop2, LoopType, MaxLoopTypes, cpu, NumberOfSheets;
    double q[3], xyz[3], Ws, U, V, W, dU, dV, dW, Uw, Vw, Ww, WsMag, EdgeGamma;
    double Area1, Area2, Wgt1, Wgt2;
    VSP_EDGE *VortexEdge;
    
    // Initialize to free stream values

    ZeroEdgeVelocities();

    // For supersonic flows we just average the loop velocities
    
    if ( Mach_ > 1. ) {

       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
  
          Area1 = VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL()).Area();
          Area2 = VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR()).Area();
          
          Wgt1 = Area2/(Area1 + Area2);
          Wgt2 = 1. - Wgt1;

          VSPGeom().Grid(MGLevel_).EdgeList(j).U() = Wgt1*VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL()).U() + Wgt2*VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR()).U();
          VSPGeom().Grid(MGLevel_).EdgeList(j).V() = Wgt1*VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL()).V() + Wgt2*VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR()).V();
          VSPGeom().Grid(MGLevel_).EdgeList(j).W() = Wgt1*VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL()).W() + Wgt2*VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR()).W();

          if ( VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL() == 0 ) {
             
             VSPGeom().Grid(MGLevel_).EdgeList(j).U() = VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR()).U();
             VSPGeom().Grid(MGLevel_).EdgeList(j).V() = VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR()).V();
             VSPGeom().Grid(MGLevel_).EdgeList(j).W() = VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR()).W();
             
          }
          
          if ( VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR() == 0 ) {
             
             VSPGeom().Grid(MGLevel_).EdgeList(j).U() = VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL()).U();
             VSPGeom().Grid(MGLevel_).EdgeList(j).V() = VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL()).V();
             VSPGeom().Grid(MGLevel_).EdgeList(j).W() = VSPGeom().Grid(MGLevel_).LoopList(VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL()).W();
             
          }             
      
       }
       
    }
    
    // For subsonic flows we take the time to get more accurate edge velocities
    
    else {
                  
       // Update the vortex strengths
   
       UpdateVortexEdgeStrengths(MGLevel_, ALL_WAKE_GAMMAS);
       
       for ( Level = MGLevel_ ; Level < NumberOfMGLevels_ ; Level++ ) {
           
          RestrictSolutionFromGrid(Level);
          
          UpdateVortexEdgeStrengths(Level+1, ALL_WAKE_GAMMAS);
   
       }
 
       // Surface vortex induced velocities
   
       MaxLoopTypes = 0;
  
       for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {
   
#pragma omp parallel for private(Level,Edge,U,V,W,Uw,Vw,Ww,j,dU,dV,dW,q,VortexEdge,xyz) schedule(dynamic)          
          for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
      
             Level = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();
   
             Edge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

             U = V = W = 0.;

             Uw = Vw = Ww = 0.;

             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
       
                dU = dV = dW = 0.; 
                
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                VortexEdge->InducedVelocity(VSPGeom().Grid(Level).EdgeList(Edge).xyz_c(), q);
      
                dU += q[0];
                dV += q[1];
                dW += q[2];
                      
                // If there is ground effects, z plane...
                
                if ( DoGroundEffectsAnalysis() ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
         
                   xyz[2] *= -1.;
                  
                   VortexEdge->InducedVelocity(xyz, q);        
         
                   q[2] *= -1.;
                  
                   dU += q[0];
                   dV += q[1];
                   dW += q[2];
                  
                }     
                          
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
         
                   xyz[1] *= -1.;
                  
                   VortexEdge->InducedVelocity(xyz, q);        
         
                   q[1] *= -1.;
                  
                   dU += q[0];
                   dV += q[1];
                   dW += q[2];
                   
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                      xyz[2] *= -1.;
                     
                      VortexEdge->InducedVelocity(xyz, q);        
            
                      q[1] *= -1.;         
                      q[2] *= -1.;
                     
                      dU += q[0];
                      dV += q[1];
                      dW += q[2];
                     
                   }                     
                  
                }  
                
                // Total induced velocity
                
                U += dU;
                V += dV;
                W += dW;
                
                // Wake induced velocities
                
                if ( VortexEdge->SurfaceID() == 0 ) {
                   
                   Uw += dU;
                   Vw += dV;
                   Ww += dW;
                   
                }   
   
             }
             
             // Total induced velocities
   
             VSPGeom().Grid(Level).EdgeList(Edge).U() += U;
             VSPGeom().Grid(Level).EdgeList(Edge).V() += V;   
             VSPGeom().Grid(Level).EdgeList(Edge).W() += W; 

             // Wake induced velocities
             
             VSPGeom().Grid(Level).EdgeList(Edge).DownWash_U() += Uw;
             VSPGeom().Grid(Level).EdgeList(Edge).DownWash_V() += Vw;   
             VSPGeom().Grid(Level).EdgeList(Edge).DownWash_W() += Ww;      
     
          }
          
       }
   
       ProlongateEdgeVelocity();

       // Add in local free stream velocities
      
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
   
          VSPGeom().Grid(MGLevel_).EdgeList(j).U() += VSPGeom().Grid(MGLevel_).EdgeList(j).LocalFreeStreamVelocity(0);
          VSPGeom().Grid(MGLevel_).EdgeList(j).V() += VSPGeom().Grid(MGLevel_).EdgeList(j).LocalFreeStreamVelocity(1); 
          VSPGeom().Grid(MGLevel_).EdgeList(j).W() += VSPGeom().Grid(MGLevel_).EdgeList(j).LocalFreeStreamVelocity(2); 

          VSPGeom().Grid(MGLevel_).EdgeList(j).DownWash_U() += VSPGeom().Grid(MGLevel_).EdgeList(j).LocalFreeStreamVelocity(0);
          VSPGeom().Grid(MGLevel_).EdgeList(j).DownWash_V() += VSPGeom().Grid(MGLevel_).EdgeList(j).LocalFreeStreamVelocity(1); 
          VSPGeom().Grid(MGLevel_).EdgeList(j).DownWash_W() += VSPGeom().Grid(MGLevel_).EdgeList(j).LocalFreeStreamVelocity(2); 
       
       }

    }
      
}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER UpdateWakeLocations                         #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdateWakeLocations(void)
{

    int i, j, k, m, p, Node, Edge, Loop, Level, NumWakeNodes;
    double x1, y1, z1, x2, y2, z2, x3, y3, z3;
    double dx, dy, dz, Res, ds_old, ds_new, Ratio, ResMax, ResL2;

    // Implicit wake update 

    if ( ImplicitWake_ && CurrentWakeIteration_ >= ImplicitWakeStartIteration_ ) {

       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
    
             NumWakeNodes = VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes();
             
             if ( TimeAccurate_ ) NumWakeNodes = MIN(NumWakeNodes, Time_ + 1);
             
             for ( j = 2 ; j <= NumWakeNodes ; j++ ) {
            
                // xyz coordinates of current wake location at node j... note j-1 has already been updated
                
                x1 = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j-1);
                y1 = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j-1);
                z1 = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j-1);
   
                x2 = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j  );
                y2 = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j  );
                z2 = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j  );
                
                // Full newton correction values

                dx = Delta_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberX(j)];
                dy = Delta_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberY(j)];
                dz = Delta_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberZ(j)];

                // For steady cases that are not a rotor
                
                if ( !TimeAccurate_ && !VSPGeom().VortexSheet(k).IsARotor() ) {
                   
                   // Defined spacing
                   
                   ds_old = VSPGeom().VortexSheet(k).TrailingVortex(i).dS(j-1);
                   
                   // New spacing... which really should equal old spacing, just with new xyz values
                   
                   ds_new = sqrt( pow(x2 + dx - x1,2.) + pow(y2 + dy - y1,2.) + pow(z2 + dz - z1,2.) );
                   
                   // Ratio of old and new spacing
                   
                   Ratio = ds_old / ds_new;
                   
                   // Adjust correction ratios to match old spacing 
                   
                   dx *= Ratio;
                   dy *= Ratio;
                   dz *= Ratio;
                                   
                }

                // Relax the corrections 
                   
                dx *= WakeRelax_;
                dy *= WakeRelax_;
                dz *= WakeRelax_;
                           
                // Update the wake data

                VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j) += dx;
                VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j) += dy;
                VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j) += dz;

                // Wake node on MGLevel_ mesh
                
                Node = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j);
                
                // Corresponding node on finest mesh
                
                Node = VSPGeom().Grid(MGLevel_).NodeList(Node).FineGridNode();
                             
                // Update the mesh 0
   
                VSPGeom().Grid(0).NodeList(Node).x() += dx;
                VSPGeom().Grid(0).NodeList(Node).y() += dy;
                VSPGeom().Grid(0).NodeList(Node).z() += dz;
             
             }
   
          }
          
       }
              
       // Update stall factors
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() += WakeRelax_*Delta_[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];
   
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() = MAX(MIN(VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor(),1.),0.);
          }
          
       }    

       // Propagate stall factors for each trailing vortex loop
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             j = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaEdge();
                   
             VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor() = VSPGeom().VortexSheet(k).TrailingVortex(j).StallFactor();
       
          }
       
       }      
       
       // Update vorticity stretching ratio
       
       if ( TimeAccurate_ ) {
          
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
                
                if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
                
                    VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() += WakeRelax_*Delta_[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()];
                  
                    VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() = MAX( VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio(),0.5);
                    
                    VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() = MIN( VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio(), 1.5);

                }

             }
             
          }          
          
       }     
       
    }
    
    // Explicit wake
    
    else {

       // Now update the location of the wake
          
       WakeResidual_ = -1.e9;
                
       if ( !TimeAccurate_ ) {
                   
          for ( m = 1 ; m <= VSPGeom().NumberOfVortexSheets() ; m++ ) {     
          
             VSPGeom().VortexSheet(m).UpdateWakeLocation(WakeRelax_,ResMax,ResL2);
                    
             MaxResidual_ = MAX(MaxResidual_,ResMax);
             
             L2Residual_ += ResL2;
          
          }
          
       }
       
       else {

          for ( m = 1 ; m <= VSPGeom().NumberOfVortexSheets() ; m++ ) {     

             VSPGeom().VortexSheet(m).UpdateUnsteadyWakeLocation(WakeRelax_,ResMax,ResL2);
                    
             MaxResidual_ = MAX(MaxResidual_,ResMax);
             
             L2Residual_ += ResL2;
                       
          }
          
       }
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
    
             NumWakeNodes = VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes();
             
             if ( TimeAccurate_ ) NumWakeNodes = MIN(NumWakeNodes, Time_ + 1);
              
             for ( j = 2 ; j <= NumWakeNodes ; j++ ) {

                // Wake node on MGLevel_ mesh
                
                Node = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j);
                
                // Corresponding node on finest mesh
                
                Node = VSPGeom().Grid(MGLevel_).NodeList(Node).FineGridNode();
                             
                // Update the mesh 0
   
                VSPGeom().Grid(0).NodeList(Node).x() = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j);
                VSPGeom().Grid(0).NodeList(Node).y() = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j);
                VSPGeom().Grid(0).NodeList(Node).z() = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j);
   
             }
   
          }
          
       }
   
    }

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER CreateSavedStateStack                         #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateSavedStateStack(int StackSize)
{
   
    MaxNumberOfSavedStates_ = StackSize;
    
    SavedState_ = new SAVE_STATE[MaxNumberOfSavedStates_ + 1];
 
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER SaveCurrentState                              #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::SaveCurrentState(int SaveStateTime)
{
   
    int i, j, k, NumberOfKuttaEdges;

    NumberOfKuttaEdges = 0;
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
       NumberOfKuttaEdges += VSPGeom().VortexSheet(k).NumberOfKuttaEdges();
       
    }
       
    SavedState(SaveStateTime).SizeLists(VSPGeom().Grid(0       ).NumberOfNodes(),
                                               VSPGeom().Grid(MGLevel_).NumberOfLoops(),
                                               VSPGeom().NumberOfComponentGroups(),
                                               NumberOfKuttaEdges);

    // Save current time
    
    SavedState(SaveStateTime).Time() = Time_;
              
    // Copy over mesh nodal data
    
    for ( i = 1 ; i <= VSPGeom().Grid(0).NumberOfNodes() ; i++ ) {
     
       // Save current state
              
       SavedState(SaveStateTime).x(i) = VSPGeom().Grid(0).NodeList(i).x();
       SavedState(SaveStateTime).y(i) = VSPGeom().Grid(0).NodeList(i).y();
       SavedState(SaveStateTime).z(i) = VSPGeom().Grid(0).NodeList(i).z();

    }

    // Copy over group data
    
    for ( i = 1 ; i <= VSPGeom().NumberOfComponentGroups() ; i++ ) {
       
       SavedState(SaveStateTime).Group(i).TotalRotationAngle() = VSPGeom().ComponentGroupList(i).TotalRotationAngle();
       
       SavedState(SaveStateTime).Group(i).TotalQuat() = VSPGeom().ComponentGroupList(i).TotalQuat();
       
    }
    
    // Copy over gamma and vortex stretching data
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       SavedState(SaveStateTime).Gamma(i) = VSPGeom().Grid(MGLevel_).LoopList(i).Gamma();

       SavedState(SaveStateTime).VortexStretchingRatio(i) = VSPGeom().Grid(MGLevel_).LoopList(i).VortexStretchingRatio();
       
       SavedState(SaveStateTime).VortexCircumference(i) = VSPGeom().Grid(MGLevel_).LoopList(i).Circumference(0);
       
    }

    // Copy over stall factor data

    j = 0;
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfKuttaEdges() ; i++ ) {
          
          j++;
          
          SavedState(SaveStateTime).StallFactor(j) = VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor();
          
       }
       
    }

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER RestoreStateToTime                            #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestoreStateToTime(int SaveStateTime)
{
   
    int Case, i, j, k, Node, Loop, Node1, Node2, Level, NumWakeNodes;
    
    Case = SaveStateTime;
   
    if ( Case > MaxNumberOfSavedStates_ ) {
       
       printf("Attempt to restore to a case beyond the save state MAX stack size! \n");
       
       printf("MaxNumberOfSavedStates_ is: %d \n",MaxNumberOfSavedStates_);
       
       fflush(NULL);exit(1);
       
    }

    // Copy over mesh nodal data
    
    for ( i = 1 ; i <= VSPGeom().Grid(0).NumberOfNodes() ; i++ ) {
       
      VSPGeom().Grid(0).NodeList(i).x() = SavedState(Case).x(i);
      VSPGeom().Grid(0).NodeList(i).y() = SavedState(Case).y(i);
      VSPGeom().Grid(0).NodeList(i).z() = SavedState(Case).z(i);

    }
    
    // Update wake xm,ym, and zm data ... ie xyz locations at previous time step
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
       
       Node1 = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
       Node2 = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();
       
       if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsWakeEdge() ) {
         
          if ( VSPGeom().Grid(MGLevel_).EdgeList(i).WakeEdgeData().Direction() > 0 ) {
             
              if ( Case >= 2 ) {
          
                 VSPGeom().Grid(MGLevel_).EdgeList(i).X2m() = SavedState(Case-1).x(Node1);
                 VSPGeom().Grid(MGLevel_).EdgeList(i).Y2m() = SavedState(Case-1).y(Node1);
                 VSPGeom().Grid(MGLevel_).EdgeList(i).Z2m() = SavedState(Case-1).z(Node1);
                 
              }
              
              else {
                 
                 VSPGeom().Grid(MGLevel_).EdgeList(i).X2m() = SavedState(Case).x(Node1);
                 VSPGeom().Grid(MGLevel_).EdgeList(i).Y2m() = SavedState(Case).y(Node1);
                 VSPGeom().Grid(MGLevel_).EdgeList(i).Z2m() = SavedState(Case).z(Node1);
                 
              }                 
                
          }
          
          else {
              
              if ( Case >= 2 ) {
              
                 VSPGeom().Grid(MGLevel_).EdgeList(i).X1m() = SavedState(Case-1).x(Node2);
                 VSPGeom().Grid(MGLevel_).EdgeList(i).Y1m() = SavedState(Case-1).y(Node2);
                 VSPGeom().Grid(MGLevel_).EdgeList(i).Z1m() = SavedState(Case-1).z(Node2);
              
              }
              
              else {
                 
                 VSPGeom().Grid(MGLevel_).EdgeList(i).X1m() = SavedState(Case).x(Node2);
                 VSPGeom().Grid(MGLevel_).EdgeList(i).Y1m() = SavedState(Case).y(Node2);
                 VSPGeom().Grid(MGLevel_).EdgeList(i).Z1m() = SavedState(Case).z(Node2);
              
              }
                               
          }
          
       }
       
    }

    // Copy over group data
    
    for ( i = 1 ; i <= VSPGeom().NumberOfComponentGroups() ; i++ ) {
       
       VSPGeom().ComponentGroupList(i).TotalRotationAngle() = SavedState(Case).Group(i).TotalRotationAngle();
       
    }
    
    // Copy over gamma and vortex stretching data
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       // Loop level vorticity
       
       VSPGeom().Grid(MGLevel_).LoopList(i).Gamma() = SavedState(Case).Gamma(i);
       
       // Current solution state on surface loops
       
       if ( VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceID() > 0  ) {
       
          Gamma(i)= SavedState(Case).Gamma(i);
          
          if ( Case - 1 > 0 ) GammaNM1(i) = SavedState(Case-1).Gamma(i);
          if ( Case - 2 > 0 ) GammaNM2(i) = SavedState(Case-2).Gamma(i);
          
       }
       
       else {
          
          Gamma(i) = GammaNM1(i) = GammaNM2(i) = 0.;
          
       }

       // Current solution state on the one kutta wake loop
       
       if ( VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceID() == 0 && VSPGeom().Grid(MGLevel_).LoopList(i).MinValidTimeStep() == 1 ) {
       
          Gamma(i) = SavedState(Case).Gamma(i);
          
          GammaNM1(i) = 0.;
          
          GammaNM2(i) = 0.;
          
       }
       
       // Vortex stretching factor
              
       VSPGeom().Grid(MGLevel_).LoopList(i).VortexStretchingRatio() = SavedState(Case).VortexStretchingRatio(i);

       // Vortex circumference
       
       VSPGeom().Grid(MGLevel_).LoopList(i).Circumference(0) = SavedState(Case).VortexCircumference(i);

    }

    // Copy over stall factor data

    j = 0;
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfKuttaEdges() ; i++ ) {
          
          j++;
          
          VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() = SavedState(Case).StallFactor(j);
          
       }
       
    }

    // Propagate stall factors for each trailing vortex loop
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
          
          j = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaEdge();
                
          VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor() = VSPGeom().VortexSheet(k).TrailingVortex(j).StallFactor();
    
       }
    
    }      
    
    // Update wake data

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
 
          NumWakeNodes = VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes();

          for ( j = 1 ; j <= NumWakeNodes ; j++ ) {
         
             // Wake node on MGLevel_ mesh
             
             Node = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j);
             
             // Corresponding node on finest mesh
             
             Node = VSPGeom().Grid(MGLevel_).NodeList(Node).FineGridNode();

             // Update the wake data

             VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j) = SavedState(Case).x(Node);
             VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j) = SavedState(Case).y(Node);
             VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j) = SavedState(Case).z(Node);

             if ( Case - 1 > 0 ) {
                
                VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX_TM1(j) = SavedState(Case-1).x(Node);
                VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY_TM1(j) = SavedState(Case-1).y(Node);
                VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ_TM1(j) = SavedState(Case-1).z(Node);
                
             }
                                                                     
          }

       }
       
    }

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
          
          Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
          
          if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= SavedState(Case).Time() ) {
             
             VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() = VSPGeom().Grid(MGLevel_).LoopList(Loop).VortexStretchingRatio();
             
          }
          
          else {
             
             VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() = 1.;
             
          }
          
       }
       
    }

    // Initialize vortex sheets to current time, time step
    // and store the current wake location
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       VSPGeom().VortexSheet(k).Time() = SavedState(Case).Time();

       VSPGeom().VortexSheet(k).DeltaTime() = DeltaTime_;
       
       VSPGeom().VortexSheet(k).UpdateConvectedDistance();

    }
    
    // Update all the edges to the current time    

    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfEdges() ; j++ ) {
       
          VSPGeom().Grid(Level).EdgeList(j).TimeAccurate() = TimeAccurate_;

          VSPGeom().Grid(Level).EdgeList(j).Time() = SavedState(Case).Time();
                                                  
       }
       
    }
            
    // Update all the mesh data

    VSPGeom().UpdateMeshes();
      
    for ( i = 1 ; i <= VSPGeom().NumberOfComponentGroups() ; i++ ) {
    
       CalculateLocalBodyVelocitiesFromMovingGeometries(i);
             
    }

    if ( SavedState(Case).Time() <= VSPGeom().NumberOfWakeTrailingNodes() ) CreateSurfaceVorticesInteractionList();
 
    // Update the free stream conditions

    InitializeFreeStream();

    // Update the velocities
    
    CalculateVelocities(ALL_WAKE_GAMMAS);
    
    // Calculate the forces
    
    CalculateForces();

    // Update vortex loop matrix preconditioners
    
    if ( UpdateMatrixPreconditioner_ ) CreateVortexLoopMatrixPreconditioners();
 
    // Update wake node preconditioner
    
    if ( UseWakeNodeMatrixPreconditioner_ ) CreateWakeNodeMatrixPreconditioners();       
                         
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER UpdateWakeConvectedDistance                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdateWakeConvectedDistance(void)
{
   
    int j, k, Level;
    
    // Initialize vortex sheets to current time, time step
    // and store the current wake location
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       VSPGeom().VortexSheet(k).Time() = Time_;

       VSPGeom().VortexSheet(k).DeltaTime() = DeltaTime_;
       
       VSPGeom().VortexSheet(k).UpdateConvectedDistance();
       
       VSPGeom().VortexSheet(k).StoreWakeLocation();
     
    }
    
    // Update all the edges to the current time    

    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfEdges() ; j++ ) {
       
          VSPGeom().Grid(Level).EdgeList(j).TimeAccurate() = TimeAccurate_;

          VSPGeom().Grid(Level).EdgeList(j).Time() = Time_;
                                                  
       }
       
    }
     
}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER UpdateGeometryLocation                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdateGeometryLocation(void)
{
  
    int i, j, k, m, c, p, v, w, t, NumberOfSheets, jMax, Level;
    int *ComponentInThisGroup, cpu, Node, Edge, Found;
    double OVec[3], TVec[3], RVec[3], CoreWidth;
    double xyz[3], xyz_te[3], q[5], U, V, W, x, y, z, dx, dy, dz;
    QUAT Quat, InvQuat, Vec1, Vec2, DQuatDt, Omega, BodyVelocity, WQuat;
     
    // Loop over any unsteady component groups and update geometry

    ComponentInThisGroup = new int[VSPGeom().NumberOfComponents() + 1];

    for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
       
       if ( Time_ == 0  ) {

          VSPGeom().ComponentGroupList(c).ZeroOutTotals();

       }
        
       VSPGeom().ComponentGroupList(c).Update(DeltaTime_, CurrentTime_);
         
       OVec[0] = VSPGeom().ComponentGroupList(c).OVec(0); // Rotation origin
       OVec[1] = VSPGeom().ComponentGroupList(c).OVec(1);
       OVec[2] = VSPGeom().ComponentGroupList(c).OVec(2);
       
       RVec[0] = VSPGeom().ComponentGroupList(c).RVec(0); // Rotation vector
       RVec[1] = VSPGeom().ComponentGroupList(c).RVec(1);
       RVec[2] = VSPGeom().ComponentGroupList(c).RVec(2);
       
       TVec[0] = VSPGeom().ComponentGroupList(c).TVec(0); // Translation vector
       TVec[1] = VSPGeom().ComponentGroupList(c).TVec(1);
       TVec[2] = VSPGeom().ComponentGroupList(c).TVec(2);
       
       Quat = VSPGeom().ComponentGroupList(c).Quat();
       
       InvQuat = VSPGeom().ComponentGroupList(c).InvQuat();
       
       WQuat = VSPGeom().ComponentGroupList(c).WQuat();
       
       zero_int_array(ComponentInThisGroup, VSPGeom().NumberOfComponents());
       
       for ( j = 1 ; j <= VSPGeom().ComponentGroupList(c).NumberOfComponents() ; j++ ) {

          ComponentInThisGroup[VSPGeom().ComponentGroupList(c).ComponentList(j)] = 1;
          
       }
                        
       // If component group is not fixed... update it's location
   
       if ( !VSPGeom().ComponentGroupList(c).GeometryIsFixed() ) {
     
          // Update acuator disk locations
       
          for ( i = 1 ; i <= NumberOfRotors_ ; i++ ) {
           
           // this is broken    RotorDisk(i).UpdateGeometryLocation(TVec,OVec,Quat,InvQuat);
             
          }
     
          // Update engine locations
     
          for ( i = 1 ; i <= NumberOfEngineFaces_ ; i++ ) {
           
           // this is broken    EngineFace(i).UpdateGeometryLocation(TVec,OVec,Quat,InvQuat);
             
          }	     
     
          // Update grids
          
          for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {
      
             VSPGeom().Grid(Level).UpdateGeometryLocation(TVec,OVec,Quat,InvQuat,ComponentInThisGroup);
      
          }
          
          // Shift the wakes for any moving components
          
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
             
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
                
                if ( i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ) {
                   
                   Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
                   
                }
                
                else {
                   
                   Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i-1).TE_Edge());
                   
                }                   
       
                if ( ComponentInThisGroup[VSPGeom().Grid(MGLevel_).EdgeList(Edge).ComponentID()] ) {

                   for ( j = MIN(Time_ + 1,VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes()) ; j > 1 ; j-- ) {
                      
                      x = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j-1);
                      y = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j-1);
                      z = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j-1);

                      VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j) = x;
                      VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j) = y;
                      VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j) = z;           
          
                      Node = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j); 
                  
                      Node = VSPGeom().Grid(MGLevel_).NodeList(Node).FineGridNode();
                      
                      VSPGeom().Grid(0).NodeList(Node).x() = x;
                      VSPGeom().Grid(0).NodeList(Node).y() = y;
                      VSPGeom().Grid(0).NodeList(Node).z() = z;
                      
                   }
                   
                   // TE node location and xyz
                   
                   Node = VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Node();
                   
                   x = VSPGeom().Grid(MGLevel_).NodeList(Node).x();
                   y = VSPGeom().Grid(MGLevel_).NodeList(Node).y();
                   z = VSPGeom().Grid(MGLevel_).NodeList(Node).z();
                   
                   // Update wake nodes that connect to the trailing edge
                   
                   j = 1;

                   VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j) = x;
                   VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j) = y;
                   VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j) = z;         
                    
                }
                
             }

          }
       
          // Update the least squares coefficients for the panel solver
          
          if ( VSPGeom().ModelType() == PANEL_MODEL ) {
             
             for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
                
                if ( ComponentInThisGroup[VSPGeom().Grid(MGLevel_).LoopList(i).ComponentID()] ) CalculateLeastSquaresCoefficients(i);
                
             }
             
          }
           
          // Calculate body velocities for this group
          
          CalculateLocalBodyVelocitiesFromMovingGeometries(c);
           
       }

       // Update component group rotation location if there was a translation
       
       VSPGeom().ComponentGroupList(c).OVec(0) += VSPGeom().ComponentGroupList(c).TVec(0);
       VSPGeom().ComponentGroupList(c).OVec(1) += VSPGeom().ComponentGroupList(c).TVec(1);
       VSPGeom().ComponentGroupList(c).OVec(2) += VSPGeom().ComponentGroupList(c).TVec(2);

    }

    delete [] ComponentInThisGroup;

    // Update the wakes
    
    ConvectUnsteadyWakes();

    // Update the mesh data
    
    VSPGeom().UpdateMeshes();   
    
    // Update free stream velocities
    
    InitializeFreeStream();

}

/*##############################################################################
#                                                                              #
#        VSP_SOLVER CalculateLocalBodyVelocitiesFromMovingGeometries           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateLocalBodyVelocitiesFromMovingGeometries(int Group)
{

    int i, *ComponentInThisGroup;   
    double OVec[3], RVec[3], TVec[3];
    QUAT Quat, InvQuat, WQuat, Vec1, Vec2, BodyVelocity;

    // If component group is not fixed... update it's location

    if ( !VSPGeom().ComponentGroupList(Group).GeometryIsFixed() ) {

       ComponentInThisGroup = new int[VSPGeom().NumberOfComponents() + 1];
       
       zero_int_array(ComponentInThisGroup, VSPGeom().NumberOfComponents());
      
       for ( i = 1 ; i <= VSPGeom().ComponentGroupList(Group).NumberOfComponents() ; i++ ) {

          ComponentInThisGroup[VSPGeom().ComponentGroupList(Group).ComponentList(i)] = 1;
          
       }
          
  //  not needed, and borked for unsteady periodic rates...  
  
       VSPGeom().ComponentGroupList(Group).Update();

       OVec[0] = VSPGeom().ComponentGroupList(Group).OVec(0); // Rotation origin
       OVec[1] = VSPGeom().ComponentGroupList(Group).OVec(1);
       OVec[2] = VSPGeom().ComponentGroupList(Group).OVec(2);
                                              
       RVec[0] = VSPGeom().ComponentGroupList(Group).RVec(0); // Rotation vector
       RVec[1] = VSPGeom().ComponentGroupList(Group).RVec(1);
       RVec[2] = VSPGeom().ComponentGroupList(Group).RVec(2);
                                              
       TVec[0] = VSPGeom().ComponentGroupList(Group).TVec(0); // Translation vector
       TVec[1] = VSPGeom().ComponentGroupList(Group).TVec(1);
       TVec[2] = VSPGeom().ComponentGroupList(Group).TVec(2);
       
       Quat = VSPGeom().ComponentGroupList(Group).Quat();
       
       InvQuat = VSPGeom().ComponentGroupList(Group).InvQuat();
       
       WQuat = VSPGeom().ComponentGroupList(Group).WQuat();
       
       // Calculate surface velocity
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
          if ( ComponentInThisGroup[VSPGeom().Grid(MGLevel_).LoopList(i).ComponentID()] ) {

             Vec1(0) = VSPGeom().Grid(MGLevel_).LoopList(i).Xc() - OVec[0];
             Vec1(1) = VSPGeom().Grid(MGLevel_).LoopList(i).Yc() - OVec[1];
             Vec1(2) = VSPGeom().Grid(MGLevel_).LoopList(i).Zc() - OVec[2];
         
             // Body point location after rotation
     
             Vec2 = Quat * Vec1 * InvQuat;

             // Body point velocity
              
             BodyVelocity = WQuat * Vec2;

             LocalBodySurfaceVelocityForLoop_[i][0] = BodyVelocity(0) + VSPGeom().ComponentGroupList(Group).Velocity(0);
             LocalBodySurfaceVelocityForLoop_[i][1] = BodyVelocity(1) + VSPGeom().ComponentGroupList(Group).Velocity(1);
             LocalBodySurfaceVelocityForLoop_[i][2] = BodyVelocity(2) + VSPGeom().ComponentGroupList(Group).Velocity(2);
          
          }
   
       }

       // Calculate surface velocity for edge centroids
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; i++ ) {
          
          if ( ComponentInThisGroup[VSPGeom().Grid(MGLevel_).EdgeList(i).ComponentID()] ) {

             Vec1(0) = VSPGeom().Grid(MGLevel_).EdgeList(i).Xc() - OVec[0];
             Vec1(1) = VSPGeom().Grid(MGLevel_).EdgeList(i).Yc() - OVec[1];
             Vec1(2) = VSPGeom().Grid(MGLevel_).EdgeList(i).Zc() - OVec[2];
         
             // Body point location after rotation
             
             Vec2 = Quat * Vec1 * InvQuat;
 
             // Body point velocity
             
             BodyVelocity = WQuat * Vec2;

             LocalBodySurfaceVelocityForEdge_[i][0] = BodyVelocity(0) + VSPGeom().ComponentGroupList(Group).Velocity(0);
             LocalBodySurfaceVelocityForEdge_[i][1] = BodyVelocity(1) + VSPGeom().ComponentGroupList(Group).Velocity(1);
             LocalBodySurfaceVelocityForEdge_[i][2] = BodyVelocity(2) + VSPGeom().ComponentGroupList(Group).Velocity(2);
          
          }
   
       }
       
       delete [] ComponentInThisGroup;
       
    }
 
}


/*##############################################################################
#                                                                              #
#                        VSP_SOLVER UpdateMeshes                               #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdateMeshes(void)
{
   
    VSPGeom().UpdateMeshes();

}

/*##############################################################################
#                                                                              #
#                   VSP_SOLVER SolveAdjointLinearSystem                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::SolveAdjointLinearSystem(void)
{

    int i, j, k, p, c, *ComponentInThisGroup, Loop, Dir, Iters;
    int Case, NumberOfForceCases, ForceCase;
    int UnsteadyAdjointCase, SaveStateCase;    
    double ResMax, ResRed, ResFin, pfMax, Fx, Fy, Fz;
    double WgtInviscid, WgtWake, WgtViscous;
    QUAT Vec, Quat, InvQuat;

    NumberOfUnsteadyAdjointCases_ = 1;
    
    if ( TimeAccurate_ ) NumberOfUnsteadyAdjointCases_ = NumberOfTimeSteps_ - StartAveragingTimeStep_ + 1;

    if ( FirstTimeGradientSetup_  ) {
    
       // Adjoint solution vector
   
       Psi_ = new double**[NumberOfUnsteadyAdjointCases_ + 1];
       
       for ( i = 1 ; i <= NumberOfUnsteadyAdjointCases_ ; i++ ) {
          
          Psi_[i] = new double*[21 + 1];
       
          for ( j = 1 ; j <= 21 ; j++ ) {
          
             Psi_[i][j] = new double[NumberOfEquations_ + 1];
             
             zero_double_array(Psi_[i][j], NumberOfEquations_);
             
          }
                    
       }
       
       // Gradients with respect to mesh
       
       PsiT_pR_pMesh_ = new double[3*VSPGeom().Grid(0).NumberOfNodes() + 1];
       
       pF_pMesh_ = new double[3*VSPGeom().Grid(0).NumberOfNodes() + 1];

       pF_pSoln_ = new double[NumberOfEquations_ + 1];
       
       zero_double_array(PsiT_pR_pMesh_, 3*VSPGeom().Grid(0).NumberOfNodes());
       
       zero_double_array(pF_pMesh_, 3*VSPGeom().Grid(0).NumberOfNodes());
      
       zero_double_array(pF_pSoln_, NumberOfEquations_);
       
       if ( TimeAccurate_ ) {
          
          // Storage for partials of forces wrt gamma at Time_ + 1 for unsteady cases
          
          pF_pSoln_NP1_[1] = new double[NumberOfEquations_ + 1]; // Forces 
          pF_pSoln_NP1_[2] = new double[NumberOfEquations_ + 1];
          pF_pSoln_NP1_[3] = new double[NumberOfEquations_ + 1];
          pF_pSoln_NP1_[4] = new double[NumberOfEquations_ + 1]; // Moments
          pF_pSoln_NP1_[5] = new double[NumberOfEquations_ + 1];
          pF_pSoln_NP1_[6] = new double[NumberOfEquations_ + 1];

          zero_double_array(pF_pSoln_NP1_[1], NumberOfEquations_);
          zero_double_array(pF_pSoln_NP1_[2], NumberOfEquations_);
          zero_double_array(pF_pSoln_NP1_[3], NumberOfEquations_);
          zero_double_array(pF_pSoln_NP1_[4], NumberOfEquations_);
          zero_double_array(pF_pSoln_NP1_[5], NumberOfEquations_);
          zero_double_array(pF_pSoln_NP1_[6], NumberOfEquations_);
          
       }

       // Edge adjoint data structures
       
       CreateAdjointCoarseEdgeList();

       FirstTimeGradientSetup_ = 0;
              
    }
    
    // Mark components in adjoint force and moment evaluation list
    
    ComponentIsInAdjointForceAndMomentList_ = new int[VSPGeom().NumberOfComponents() + 1];
    
    zero_int_array(ComponentIsInAdjointForceAndMomentList_, VSPGeom().NumberOfComponents());     
           
    for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {  
       
       for ( i = 1 ; i <= VSPGeom().ComponentGroupList(c).NumberOfComponents() ; i++ ) {
          
          if ( UserAdjointComponentList_[c] == 1 ) ComponentIsInAdjointForceAndMomentList_[VSPGeom().ComponentGroupList(c).ComponentList(i)] = 1;

       }
       
    }    
    
    // Zero out total gradients wrt mesh and user inputs
    
    ZeroForceAndMomentGradients();     
    
    // We need to be in implicit mode
        
    ImplicitWake_ = 1;
    
    // Starting with current solve case
    
    SaveStateCase = NumberOfTimeSteps_;

    for ( UnsteadyAdjointCase = NumberOfUnsteadyAdjointCases_ ; UnsteadyAdjointCase >= 1 ; UnsteadyAdjointCase-- ) {
       
       SaveStateCase = NumberOfTimeSteps_ - ( NumberOfUnsteadyAdjointCases_ - UnsteadyAdjointCase ) - StartAveragingTimeStep_ + 1;
 
       if ( TimeAccurate_) {
       
          CalculateTimeAccurateForceCouplingTerms_wrt_Gamma();
          
          RestoreStateToTime(SaveStateCase);

       }
       
       // Calculate raw force gradients with respect to gamma and the mesh
   
       printf("Calculating velocities ... \n");
       
       CalculateVelocities(ALL_WAKE_GAMMAS);

       printf("Calculating residual ... \n");

       CalculateResidual();
      
       printf("Calculating Mach perturbation ... \n");
   
       CalculateMachPerturbationVelocities();
  
       printf("Calculating Force gradients ... \n");
            
       CalculateForceGradients();

       // ADJOINT_INVISCID_AND_VISCOUS_FORCES          0
       // ADJOINT_WAKE_AND_VISCOUS_FORCES              1
       // ADJOINT_INVISCID_AND_WAKE_AND_VISCOUS_FORCES 3
       // ADJOINT_INVISCID_FORCES                      4
       // ADJOINT_VISCOUS_FORCES                       5
       // ADJOINT_WAKE_FORCES                          6
       // ADJOINT_TOTAL_FORCES                         7
       // ADJOINT_TOTAL_FORCES_USING_WAKE_FORCES       8
              
       // Solve adjoint system... 
       // ForceCase 1 --> Invisicid / Wake induced
       // ForceCase 2 --> Viscous
       // ForceCase 3 --> Total forces = inviscid + viscous

       NumberOfForceCases = 1;
       
       if ( AdjointSolutionForceType_ == ADJOINT_INVISCID_AND_VISCOUS_FORCES          ) NumberOfForceCases = 2;
                                                                                      
       if ( AdjointSolutionForceType_ == ADJOINT_WAKE_AND_VISCOUS_FORCES              ) NumberOfForceCases = 2;

       if ( AdjointSolutionForceType_ == ADJOINT_INVISCID_AND_WAKE_AND_VISCOUS_FORCES ) NumberOfForceCases = 3;

       for ( Case = 1 ; Case <= NumberOfForceCases ; Case++ ) {

          // Solve for forces in x, y, z --> Dir = 1,2,3 ... and moments in x,y,z --> Dir = 4,5,6
        
          Dir = 1;
   
          while ( Dir <= 6 ) {

             // Cases using inviscid forces
             
             if ( AdjointSolutionForceType_ == ADJOINT_INVISCID_FORCES                                                ) { WgtInviscid = 1.; WgtWake = 0.; WgtViscous = 0.; ForceCase = 1; };
             if ( AdjointSolutionForceType_ == ADJOINT_VISCOUS_FORCES                                                 ) { WgtInviscid = 0.; WgtWake = 0.; WgtViscous = 1.; ForceCase = 2; };
             if ( AdjointSolutionForceType_ == ADJOINT_TOTAL_FORCES                                                   ) { WgtInviscid = 1.; WgtWake = 0.; WgtViscous = 1.; ForceCase = 3; };
             if ( AdjointSolutionForceType_ == ADJOINT_INVISCID_AND_VISCOUS_FORCES           && Case == 1             ) { WgtInviscid = 1.; WgtWake = 0.; WgtViscous = 0.; ForceCase = 1; };
             if ( AdjointSolutionForceType_ == ADJOINT_INVISCID_AND_VISCOUS_FORCES           && Case == 2             ) { WgtInviscid = 0.; WgtWake = 0.; WgtViscous = 1.; ForceCase = 2; };
             
             // Cases using wake forces
             
             if ( AdjointSolutionForceType_ == ADJOINT_WAKE_FORCES                                        && Dir <= 3 ) { WgtInviscid = 0.; WgtWake = 1.; WgtViscous = 0.; ForceCase = 1; };
             if ( AdjointSolutionForceType_ == ADJOINT_WAKE_FORCES                                        && Dir >  3 ) { WgtInviscid = 1.; WgtWake = 0.; WgtViscous = 0.; ForceCase = 1; };

             if ( AdjointSolutionForceType_ == ADJOINT_WAKE_AND_VISCOUS_FORCES               && Case == 1 && Dir <= 3 ) { WgtInviscid = 0.; WgtWake = 1.; WgtViscous = 0.; ForceCase = 1; };
             if ( AdjointSolutionForceType_ == ADJOINT_WAKE_AND_VISCOUS_FORCES               && Case == 1 && Dir >  3 ) { WgtInviscid = 1.; WgtWake = 0.; WgtViscous = 0.; ForceCase = 1; };
             
             if ( AdjointSolutionForceType_ == ADJOINT_WAKE_AND_VISCOUS_FORCES               && Case == 2 && Dir <= 3 ) { WgtInviscid = 0.; WgtWake = 0.; WgtViscous = 1.; ForceCase = 2; };
             if ( AdjointSolutionForceType_ == ADJOINT_WAKE_AND_VISCOUS_FORCES               && Case == 2 && Dir >  3 ) { WgtInviscid = 0.; WgtWake = 0.; WgtViscous = 1.; ForceCase = 2; };
             
             if ( AdjointSolutionForceType_ == ADJOINT_TOTAL_FORCES_USING_WAKE_FORCES                     && Dir <= 3 ) { WgtInviscid = 0.; WgtWake = 1.; WgtViscous = 1.; ForceCase = 3; };
             if ( AdjointSolutionForceType_ == ADJOINT_TOTAL_FORCES_USING_WAKE_FORCES                     && Dir >  3 ) { WgtInviscid = 1.; WgtWake = 0.; WgtViscous = 1.; ForceCase = 3; };
             
             if ( AdjointSolutionForceType_ == ADJOINT_INVISCID_AND_WAKE_AND_VISCOUS_FORCES  && Case == 1 && Dir <= 3 ) { WgtInviscid = 1.; WgtWake = 0.; WgtViscous = 0.; ForceCase = 1; };
             if ( AdjointSolutionForceType_ == ADJOINT_INVISCID_AND_WAKE_AND_VISCOUS_FORCES  && Case == 2 && Dir <= 3 ) { WgtInviscid = 0.; WgtWake = 1.; WgtViscous = 0.; ForceCase = 1; };
             if ( AdjointSolutionForceType_ == ADJOINT_INVISCID_AND_WAKE_AND_VISCOUS_FORCES  && Case == 3 && Dir <= 3 ) { WgtInviscid = 0.; WgtWake = 0.; WgtViscous = 1.; ForceCase = 2; };
             
             if ( DoAdjointSolveForThisForceMomentCase_[Dir] ) {
             
                // Set current Psi
                
                CurrentPsi_ = Psi_[UnsteadyAdjointCase][(Case-1)*6 + Dir];
   
                for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
                
                   if ( Dir == 1 ) {
                   
                       pF_pSoln_[i] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(i).pFx_pGamma() + WgtWake * VSPGeom().Grid(MGLevel_).LoopList(i).pFwx_pGamma() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(i).pFxo_pGamma();
                       
                   }
                   
                   else if ( Dir == 2 ) {
                   
                       pF_pSoln_[i] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(i).pFy_pGamma() + WgtWake * VSPGeom().Grid(MGLevel_).LoopList(i).pFwy_pGamma() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(i).pFyo_pGamma();
                       
                   }
                       
                   else if ( Dir == 3 ) {
                   
                       pF_pSoln_[i] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(i).pFz_pGamma() + WgtWake * VSPGeom().Grid(MGLevel_).LoopList(i).pFwz_pGamma() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(i).pFzo_pGamma();
                       
                   }           
         
                   else if ( Dir == 4 ) {
                   
                       pF_pSoln_[i] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pGamma() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(i).pMxo_pGamma();
                       
                   }
                   
                   else if ( Dir == 5 ) {
                   
                       pF_pSoln_[i] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pGamma() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(i).pMyo_pGamma();
                       
                   }
                       
                   else if ( Dir == 6 ) {
                   
                       pF_pSoln_[i] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pGamma() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(i).pMzo_pGamma();
                       
                   }     
                      
                   else {
                      
                      printf("1... Unknown direction! \n");fflush(NULL);exit(1);
                      
                   }    
                          
                }
             
                for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() + 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
            
                   // wrt x
                   
                   j = i - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
                   
                   if ( Dir == 1 ) {
             
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ();
                      
                   }
                                                                                                                                          
                   else if ( Dir == 2 ) {
             
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pX() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pY() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pZ() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ();
                                                                                                                                    
                   }
            
                   else if ( Dir == 3 ) {
             
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ();
                      
                   }
          
                   else if ( Dir == 4 ) {
             
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ();
                      
                   }
                                                                                                                                          
                   else if ( Dir == 5 ) {
             
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ();
                                                                                                                                    
                   }
            
                   else if ( Dir == 6 ) {
             
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX(); 
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY();
                      pF_pSoln_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ();
                      
                   }
                             
                   else {
                      
                      printf("2... Unknown direction! \n");fflush(NULL);exit(1);
                      
                   }     
                             
                }
         
                // Add in stall terms
                
                if ( StallModelIsOn_ ) {
                   
                   for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
                   
                      for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
                         
                         p = VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber(); 
         
                         if ( Dir == 1 ) {
                         
                            pF_pSoln_[p] = WgtInviscid * VSPGeom().VortexSheet(k).TrailingVortex(i).pFx_pStallFactor() + WgtWake * VSPGeom().VortexSheet(k).TrailingVortex(i).pFwx_pStallFactor() + WgtViscous * VSPGeom().VortexSheet(k).TrailingVortex(i).pFxo_pStallFactor();
                                                                                                         
                         }                                                                               
                                                                                                         
                         else if ( Dir == 2 ) {                                                          
                                                                                                         
                            pF_pSoln_[p] = WgtInviscid * VSPGeom().VortexSheet(k).TrailingVortex(i).pFy_pStallFactor() + WgtWake * VSPGeom().VortexSheet(k).TrailingVortex(i).pFwy_pStallFactor() + WgtViscous * VSPGeom().VortexSheet(k).TrailingVortex(i).pFyo_pStallFactor();
                                                                                                         
                         }                                                                               
                                                                                                         
                         else if ( Dir == 3 ) {                                                          
                                                                                                         
                            pF_pSoln_[p] = WgtInviscid * VSPGeom().VortexSheet(k).TrailingVortex(i).pFz_pStallFactor() + WgtWake * VSPGeom().VortexSheet(k).TrailingVortex(i).pFwz_pStallFactor() + WgtViscous * VSPGeom().VortexSheet(k).TrailingVortex(i).pFzo_pStallFactor();
                                                                                                         
                         }                                                                               
                                                                                                         
                         else if ( Dir == 4 ) {                                                          
                                                                                                         
                            pF_pSoln_[p] = WgtInviscid * VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor() + WgtViscous * VSPGeom().VortexSheet(k).TrailingVortex(i).pMxo_pStallFactor(); 
                                                                                                         
                         }                                                                               
                                                                                                         
                         else if ( Dir == 5 ) {                                                          
                                                                                                         
                            pF_pSoln_[p] = WgtInviscid * VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor() + WgtViscous * VSPGeom().VortexSheet(k).TrailingVortex(i).pMyo_pStallFactor(); 
                                                                                                         
                         }                                                                               
                                                                                                         
                         else if ( Dir == 6 ) {                                                          
                                                                                                         
                            pF_pSoln_[p] = WgtInviscid * VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor() + WgtViscous * VSPGeom().VortexSheet(k).TrailingVortex(i).pMzo_pStallFactor(); 
                            
                         }     
                            
                         else {
                            
                            printf("1... Unknown direction! \n");fflush(NULL);exit(1);
                            
                         }    
                                               
                      }
                      
                   }
                   
                }
                
                // Add in vortex stretching terms
                
                if ( TimeAccurate_ ) {
                   
                   for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
                    
                      for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                         
                         Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
      
                         p = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
                         
                         if ( Dir == 1 ) {
                         
                             pF_pSoln_[p] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFx_pRatio() + WgtWake * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwx_pRatio() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFxo_pRatio();
                                                                                                   
                         }                                                                         
                                                                                                   
                         else if ( Dir == 2 ) {                                                    
                                                                                                   
                             pF_pSoln_[p] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFy_pRatio() + WgtWake * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwy_pRatio() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFyo_pRatio();
                                                                                                   
                         }                                                                         
                                                                                                   
                         else if ( Dir == 3 ) {                                                    
                                                                                                   
                             pF_pSoln_[p] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFz_pRatio() + WgtWake * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwz_pRatio() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(Loop).pFzo_pRatio();
                                                                                                  
                         }                                                                        
                                                                                                  
                         else if ( Dir == 4 ) {                                                   
                                                                                                  
                             pF_pSoln_[p] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(Loop).pMx_pRatio() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(Loop).pMxo_pRatio();
                                                                                                   
                         }                                                                         
                                                                                                   
                         else if ( Dir == 5 ) {                                                    
                                                                                                   
                             pF_pSoln_[p] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(Loop).pMy_pRatio() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(Loop).pMyo_pRatio();
                                                                                                   
                         }                                                                         
                                                                                                   
                         else if ( Dir == 6 ) {                                                    
                                                                                                   
                             pF_pSoln_[p] = WgtInviscid * VSPGeom().Grid(MGLevel_).LoopList(Loop).pMz_pRatio() + WgtViscous * VSPGeom().Grid(MGLevel_).LoopList(Loop).pMzo_pRatio();
                             
                         }     
                            
                         else {
                            
                            printf("1... Unknown direction! \n");fflush(NULL);exit(1);
                            
                         }                 
                   
                      }
                       
                   }
                   
                }
                
                // Add in time accurate coupling terms
                
                if ( TimeAccurate_ && UnsteadyAdjointCase < NumberOfUnsteadyAdjointCases_ ) {
   
                   CalculateTimeAccurateAdjointCouplingTerms(ForceCase,Dir,UnsteadyAdjointCase);
                                   
                }
              
                // Save the partials wrt mesh on surface
                      
                for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {
          
                   if ( Dir == 1 ) {
             
                      pF_pMesh_[3*i-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX();
                      pF_pMesh_[3*i-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY();
                      pF_pMesh_[3*i  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ();
                      
                   }
                                                                                                                                         
                   else if ( Dir == 2 ) {
             
                      pF_pMesh_[3*i-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pX() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX();
                      pF_pMesh_[3*i-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pY() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY();
                      pF_pMesh_[3*i  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pZ() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ();
                                                                                                                                              
                   }
            
                   else if ( Dir == 3 ) {
             
                      pF_pMesh_[3*i-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX();
                      pF_pMesh_[3*i-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY();
                      pF_pMesh_[3*i  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ() + WgtWake * VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ();
                      
                   }
                   
                   else if ( Dir == 4 ) {
             
                      pF_pMesh_[3*i-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX();
                      pF_pMesh_[3*i-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY();
                      pF_pMesh_[3*i  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ();
                      
                   }
                                                                                                                                         
                   else if ( Dir == 5 ) {
             
                      pF_pMesh_[3*i-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX(); 
                      pF_pMesh_[3*i-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY();
                      pF_pMesh_[3*i  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ();
                                                                                                                                  
                   }
            
                   else if ( Dir == 6 ) {
             
                      pF_pMesh_[3*i-2] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX();
                      pF_pMesh_[3*i-1] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY();
                      pF_pMesh_[3*i  ] = WgtInviscid * VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ() + WgtViscous * VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ();
                      
                   }
                   
                   else {
                      
                      printf("3... Unknown direction! \n");fflush(NULL);exit(1);
                      
                   }       
                   
                }
                 
                // Find max over right hand side
                
                pfMax = 0.;
                
                for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
            
                   pfMax = MAX(pfMax, ABS(pF_pSoln_[i]));
            
                }
         
                if ( TimeAccurate_ ) {
                   
                   if ( ForceCase == 1 && Dir == 1 ) printf("Time: %d ... Inviscid Force  in x...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 1 && Dir == 2 ) printf("Time: %d ... Inviscid Force  in y...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 1 && Dir == 3 ) printf("Time: %d ... Inviscid Force  in z...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                                                                                                                                                                                                                    
                   if ( ForceCase == 2 && Dir == 1 ) printf("Time: %d ...  Viscous Force  in x...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 2 && Dir == 2 ) printf("Time: %d ...  Viscous Force  in y...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 2 && Dir == 3 ) printf("Time: %d ...  Viscous Force  in z...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                                                                                                                                                                                                                  
                   if ( ForceCase == 3 && Dir == 1 ) printf("Time: %d ...    Total Force  in x...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 3 && Dir == 2 ) printf("Time: %d ...    Total Force  in y...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 3 && Dir == 3 ) printf("Time: %d ...    Total Force  in z...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                                                                                                                                                                                                                    
                   if ( ForceCase == 1 && Dir == 4 ) printf("Time: %d ... Inviscid Moment in x...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 1 && Dir == 5 ) printf("Time: %d ... Inviscid Moment in y...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 1 && Dir == 6 ) printf("Time: %d ... Inviscid Moment in z...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                                                                                                                                                                                                                    
                   if ( ForceCase == 2 && Dir == 4 ) printf("Time: %d ...  Viscous Moment in x...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 2 && Dir == 5 ) printf("Time: %d ...  Viscous Moment in y...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 2 && Dir == 6 ) printf("Time: %d ...  Viscous Moment in z...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                                                                                                                                                                                                                   
                   if ( ForceCase == 3 && Dir == 4 ) printf("Time: %d ...    Total Moment in x...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 3 && Dir == 5 ) printf("Time: %d ...    Total Moment in y...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);
                   if ( ForceCase == 3 && Dir == 6 ) printf("Time: %d ...    Total Moment in z...                                                                        \n",SaveStateCase + StartAveragingTimeStep_ - 1);

                   fflush(NULL);
                                
                }
                
                else {
                   
                   if ( ForceCase == 1 && Dir == 1 ) printf("Inviscid Force  in x...                                                                                     \n");
                   if ( ForceCase == 1 && Dir == 2 ) printf("Inviscid Force  in y...                                                                                     \n");
                   if ( ForceCase == 1 && Dir == 3 ) printf("Inviscid Force  in z...                                                                                     \n");
                                                                                                                                                                    
                   if ( ForceCase == 2 && Dir == 1 ) printf(" Viscous Force  in x...                                                                                     \n");
                   if ( ForceCase == 2 && Dir == 2 ) printf(" Viscous Force  in y...                                                                                     \n");
                   if ( ForceCase == 2 && Dir == 3 ) printf(" Viscous Force  in z...                                                                                     \n");

                   if ( ForceCase == 3 && Dir == 1 ) printf("   Total Force  in x...                                                                                     \n");
                   if ( ForceCase == 3 && Dir == 2 ) printf("   Total Force  in y...                                                                                     \n");
                   if ( ForceCase == 3 && Dir == 3 ) printf("   Total Force  in z...                                                                                     \n");
                                                                                                                                                                   
                   if ( ForceCase == 1 && Dir == 4 ) printf("Inviscid Moment in x...                                                                                     \n");
                   if ( ForceCase == 1 && Dir == 5 ) printf("Inviscid Moment in y...                                                                                     \n");
                   if ( ForceCase == 1 && Dir == 6 ) printf("Inviscid Moment in z...                                                                                     \n");
                                                                                                                                                                  
                   if ( ForceCase == 2 && Dir == 4 ) printf(" Viscous Moment in x...                                                                                     \n");
                   if ( ForceCase == 2 && Dir == 5 ) printf(" Viscous Moment in y...                                                                                     \n");
                   if ( ForceCase == 2 && Dir == 5 ) printf(" Viscous Moment in z...                                                                                     \n");

                   if ( ForceCase == 3 && Dir == 4 ) printf("   Total Moment in x...                                                                                     \n");
                   if ( ForceCase == 3 && Dir == 5 ) printf("   Total Moment in y...                                                                                     \n");
                   if ( ForceCase == 3 && Dir == 6 ) printf("   Total Moment in z...                                                                                     \n");
                   
                   fflush(NULL);
                   
                }
                      
                for ( i = 0 ; i <= NumberOfEquations_ ; i++ ) {
                
                   CurrentPsi_[i] = 0.;
                
                }
          
                ResRed = 0.01;
            
                ResMax = 0.1*pfMax;
            
                // User residual reduction factor
                
                ResRed *= AdjointGMRESConvergenceFactor_;
            
                // Use preconditioned GMRES to solve the linear system for the adjoint, Psi
            
                Time1_ = myclock();
            
                DoAdjointMatrixPrecondition(pF_pSoln_);
                      
                AdjointMatrixSolve_ = 1;
              
                GMRES_Solver(NumberOfEquations_ + 1,     // Number of Equations, 0 <= i < Neq
                             3,                          // Max number of outer iterations
                             500,                        // Max number of inner (restart) iterations
                             1,                          // Output flag, verbose = 0, or 1
                             CurrentPsi_,                // Initial guess and solution vector
                             pF_pSoln_,                  // Right hand side of Ax = b
                             ResMax,                     // Maximum error tolerance
                             ResRed,                     // Residual reduction factor
                             ResFin,                     // Final log10 of residual reduction   
                             Iters);                     // Final iteration count      
         
                Time2_ = myclock() - Time1_;
           
                AdjointMatrixSolve_ = 0;
                
                if ( Verbose_ ) {
                      
                   for ( i = 0 ; i <= NumberOfEquations_ ; i++ ) {
               
                      printf("Psi[%d]: %e \n",i,CurrentPsi_[i]);
                      
                   } 
                   
                }

                // Calculate Psi_T x pR_pMesh
                
                Time1_ = myclock();
                
                CalculatePsiT_PartialResidualPartialMesh();
            
                Time2_ = myclock() - Time1_;
            
                // Apply quaternion transformations to the gradients if needed
                
                if ( TimeAccurate_ ) {
           
                   ComponentInThisGroup = new int[VSPGeom().NumberOfComponents() + 1];
   
                   for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
                      
                      // Transforms gradients for rotors
                      
                      if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) {
                      
                         Quat = SavedState(SaveStateCase).Group(c).TotalQuat();
                         
                         InvQuat = Quat;
                         
                         InvQuat.FormInverse();   
                         
                         zero_int_array(ComponentInThisGroup, VSPGeom().NumberOfComponents());
                         
                         for ( i = 1 ; i <= VSPGeom().ComponentGroupList(c).NumberOfComponents() ; i++ ) {
                         
                            ComponentInThisGroup[VSPGeom().ComponentGroupList(c).ComponentList(i)] = 1;
                            
                         }
                        
                         // Do coordinate transformation of gradients back to original mesh
                         
                         for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {
                            
                            if ( ComponentInThisGroup[VSPGeom().Grid(MGLevel_).NodeList(i).ComponentID()] ) {
                   
                               // PsiT_pR_pMesh_
                               
                               Vec(0) = PsiT_pR_pMesh_[3*i-2];
                               Vec(1) = PsiT_pR_pMesh_[3*i-1];
                               Vec(2) = PsiT_pR_pMesh_[3*i  ];
                            
                               Vec = InvQuat * Vec * Quat;
                            
                               PsiT_pR_pMesh_[3*i-2] = Vec(0);
                               PsiT_pR_pMesh_[3*i-1] = Vec(1);
                               PsiT_pR_pMesh_[3*i  ] = Vec(2);    
                            
                               // pF_pMesh_
                               
                               Vec(0) = pF_pMesh_[3*i-2];
                               Vec(1) = pF_pMesh_[3*i-1];
                               Vec(2) = pF_pMesh_[3*i  ];
                            
                               Vec = InvQuat * Vec * Quat;
                            
                               pF_pMesh_[3*i-2] = Vec(0);
                               pF_pMesh_[3*i-1] = Vec(1);
                               pF_pMesh_[3*i  ] = Vec(2);    
                  
                            }
                            
                         }
                         
                      }
                   
                   }
                   
                   delete [] ComponentInThisGroup;
                 
                }         
                
                // Save final gradients
        
                for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {
                   
                   // wrt x
            
                   if ( Dir == 1 ) {
                      
                      if ( ForceCase == 1 || ForceCase == 3 ) {
                                                            
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                         
                      }
         
                      else if ( ForceCase == 2  ) {
                         
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                         
                      }
                      
                   }
                   
                   // wrt y
                   
                   else if ( Dir == 2 ) {
                   
                      if ( ForceCase == 1 || ForceCase == 3 ) {
                              
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                                                
                      }                                         
                                                                
                      else if ( ForceCase == 2  ) {             
                                                                
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                         
                      }
                      
                   }       
            
                   // wrt z
                   
                   else if ( Dir == 3 ) {
                   
                      if ( ForceCase == 1 || ForceCase == 3 ) {
                              
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                                                
                      }                                         
                                                                
                      else if ( ForceCase == 2  ) {            
                                                                
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                         
                      }
                      
                   }   
                       
                   // wrt x
            
                   else if ( Dir == 4 ) {
                
                      if ( ForceCase == 1 || ForceCase == 3 ) {
                              
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                                               
                      }                                        
                                                               
                      else if ( ForceCase == 2  ) {            
                                                               
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                         
                      }
                                      
                   }
                   
                   // wrt y
                   
                   else if ( Dir == 5 ) {
                   
                      if ( ForceCase == 1 || ForceCase == 3 ) {
                              
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                                                
                      }                                         
                                                                
                      else if ( ForceCase == 2  ) {             
                                                                
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                         
                      }     
                                
                   }       
            
                   // wrt z
                   
                   else if ( Dir == 6 ) {
                   
                      if ( ForceCase == 1 || ForceCase == 3 ) {
                              
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                                                
                      }                                         
                                                                
                      else if ( ForceCase == 2  ) {             
                                                                
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DX() += pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DY() += pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                         VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DZ() += pF_pMesh_[3*i  ] - PsiT_pR_pMesh_[3*i  ];
                                         
                      }     
      
                   }       
                   
                   else {
                      
                      printf("4... Unknown direction! \n");fflush(NULL);exit(1);
                      
                   }              
         
                }
                
                // Solve for derivatives wrt free stream
              
                CalculatePsiT_PartialResidualPartialUserInputs(ForceCase, Dir, WgtInviscid, WgtViscous, WgtWake);
                             
             }             
       
             Dir++;
             
             if ( DoSymmetryPlaneSolve_ && Dir == 2 ) Dir++;
             if ( DoSymmetryPlaneSolve_ && Dir == 4 ) Dir++;          
             if ( DoSymmetryPlaneSolve_ && Dir == 6 ) Dir++;
             
          }
   
       }
       
    }

    if ( TimeAccurate_ ) {
       
       AverageForceAndMomentGradients(NumberOfUnsteadyAdjointCases_);
       
       RestoreStateToTime(0);
 
    }  
    
    // Calculate aero force and moment derivatives wrt user inputs (ie CL, CD, CS, CMl, CMm, and CMn)...
    
    CalculateForceCoefficientGradients_wrt_Inputs();
    
    // Calculate aero force and moment derivatives wrt mesh (ie CL, CD, CS, CMl, CMm, and CMn)...
    
    CalculateForceCoefficientGradients_wrt_Mesh();
    
    // Calculate control surface derivatives
    
    CalculateControlSurfaceDerivatives();
    
    // Write out the mesh gradients
    
    WriteOutMeshGradients();

}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER ZeroForceAndMomentGradients                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroForceAndMomentGradients(void)
{
   
    int i, j, g;
    
    // Zero out total gradients wrt mesh
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {
       
       // Total derivatives
       
       VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DZ() = 0.;
                                                       
       VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DZ() = 0.;
                                                       
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DZ() = 0.;
                                                      
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DZ() = 0.;
                                                       
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DZ() = 0.;
                                                       
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DZ() = 0.;
                                                       
       VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DZ() = 0.;
                                                       
       VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DZ() = 0.;
                                                     
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DZ() = 0.;
                                                      
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DZ() = 0.;
                                                      
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DZ() = 0.;
                                                      
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DZ() = 0.;

       // Partial derivatives
       
       VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ() = 0.;
                                          
       VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ() = 0.;
                                         
       VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pZ() = 0.;
                                          
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ() = 0.;
                                         
       VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ() = 0.;
                                         
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ() = 0.;
                                         
       VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ() = 0.;
                                          
       VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ() = 0.;
                                          
       VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ() = 0.;
                                         
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ() = 0.;
                                         
       VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ() = 0.;
                                          
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ() = 0.;
                     
    }    
    
    for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
       
       VSPGeom().ComponentGroupList(g).DCFxi_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCFyi_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCFzi_DOmega() = 0.;
                                                       
       VSPGeom().ComponentGroupList(g).DCFxo_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCFyo_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCFzo_DOmega() = 0.;
                                                       
       VSPGeom().ComponentGroupList(g).DCFxo_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCFyo_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCFzo_DOmega() = 0.;
                                                      
       VSPGeom().ComponentGroupList(g).DCMxi_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCMyi_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCMzi_DOmega() = 0.;
                                                      
       VSPGeom().ComponentGroupList(g).DCMxo_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCMyo_DOmega() = 0.;
       VSPGeom().ComponentGroupList(g).DCMzo_DOmega() = 0.;
       
    }
                           
    for ( i = 0 ; i <= 2 ; i++ ) {
       
       // Forces
       
       DFi_DAlpha_[i] = 0.;
       DFi_DBeta_[i]  = 0.;
       DFi_DP_[i]     = 0.;
       DFi_DQ_[i]     = 0.;
       DFi_DR_[i]     = 0.;
       DFi_DMach_[i]  = 0.;
       DFi_DCG_[0][i] = 0.;
       DFi_DCG_[1][i] = 0.;
       DFi_DCG_[2][i] = 0.;
       DFi_DRe_[i]    = 0.;
      
       DFo_DAlpha_[i] = 0.;
       DFo_DBeta_[i]  = 0.;
       DFo_DP_[i]     = 0.;
       DFo_DQ_[i]     = 0.;
       DFo_DR_[i]     = 0.;
       DFo_DMach_[i]  = 0.;
       DFo_DCG_[0][i] = 0.;
       DFo_DCG_[1][i] = 0.;
       DFo_DCG_[2][i] = 0.;
       DFo_DRe_[i]    = 0.;         
                     
       // Moments      
                       
       DMi_DAlpha_[i] = 0.;
       DMi_DBeta_[i]  = 0.;
       DMi_DP_[i]     = 0.;
       DMi_DQ_[i]     = 0.;
       DMi_DR_[i]     = 0.;
       DMi_DMach_[i]  = 0.;
       DMi_DMach_[i]  = 0.;
       DMi_DCG_[0][i] = 0.;
       DMi_DCG_[1][i] = 0.;
       DMi_DCG_[2][i] = 0.;
       DMi_DRe_[i]    = 0.;         
                              
       DMo_DAlpha_[i] = 0.;
       DMo_DBeta_[i]  = 0.;
       DMo_DP_[i]     = 0.;
       DMo_DQ_[i]     = 0.;
       DMo_DR_[i]     = 0.;
       DMo_DMach_[i]  = 0.;
       DMo_DCG_[0][i] = 0.;
       DMo_DCG_[1][i] = 0.;
       DMo_DCG_[2][i] = 0.;
       DMo_DRe_[i]    = 0.;         
                                     
       // Wake forces
       
       DFw_DAlpha_[i] = 0.;
       DFw_DBeta_[i]  = 0.;
       DFw_DP_[i]     = 0.;
       DFw_DQ_[i]     = 0.;
       DFw_DR_[i]     = 0.;
       DFw_DMach_[i]  = 0.;
       DFw_DCG_[0][i] = 0.;
       DFw_DCG_[1][i] = 0.;
       DFw_DCG_[2][i] = 0.;
       DFw_DRe_[i]    = 0.;
                            
    }

    if ( !TimeAccurate_ ) {
   
       for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
          
          for ( j = 1 ; j <= NumberOfTimeSteps_ ; j++ ) {

             VSPGeom().ComponentGroupList(g).DCFxi_DOmega(j) = 0.;
             VSPGeom().ComponentGroupList(g).DCFyi_DOmega(j) = 0.;
             VSPGeom().ComponentGroupList(g).DCFzi_DOmega(j) = 0.;

             VSPGeom().ComponentGroupList(g).DCFxo_DOmega(j) = 0.;
             VSPGeom().ComponentGroupList(g).DCFyo_DOmega(j) = 0.;
             VSPGeom().ComponentGroupList(g).DCFzo_DOmega(j) = 0.;
                                                                   
             VSPGeom().ComponentGroupList(g).DCMxi_DOmega(j) = 0.;
             VSPGeom().ComponentGroupList(g).DCMyi_DOmega(j) = 0.;
             VSPGeom().ComponentGroupList(g).DCMzi_DOmega(j) = 0.;
                                                                  
             VSPGeom().ComponentGroupList(g).DCMxo_DOmega(j) = 0.;
             VSPGeom().ComponentGroupList(g).DCMyo_DOmega(j) = 0.;
             VSPGeom().ComponentGroupList(g).DCMzo_DOmega(j) = 0.;
                
          }
          
       }
       
    }
            
}
 
/*##############################################################################
#                                                                              #
#                VSP_SOLVER AverageForceAndMomentGradients                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::AverageForceAndMomentGradients(int NumberOfCases)
{
   
    int i;
    
    // Zero out total gradients wrt mesh
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DZ() /= NumberOfCases;
                                                     
       VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DZ() /= NumberOfCases;
                                                    
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DZ() /= NumberOfCases;
                                                    
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DZ() /= NumberOfCases;
                                                    
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DZ() /= NumberOfCases;
                                                    
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DZ() /= NumberOfCases;
                                                   
       VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DZ() /= NumberOfCases;
                                                   
       VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DZ() /= NumberOfCases;
                                                    
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DZ() /= NumberOfCases;
                                                    
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DZ() /= NumberOfCases;
                                                     
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DZ() /= NumberOfCases;
                                                  
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DX() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DY() /= NumberOfCases;
       VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DZ() /= NumberOfCases;
              
    }    
                    
    for ( i = 0 ; i <= 2 ; i++ ) {
       
       // Forces
       
       DFi_DAlpha_[i] /= NumberOfCases;
       DFi_DBeta_[i]  /= NumberOfCases;
       DFi_DP_[i]     /= NumberOfCases;
       DFi_DQ_[i]     /= NumberOfCases;
       DFi_DR_[i]     /= NumberOfCases;
       DFi_DMach_[i]  /= NumberOfCases;
                   
       DFo_DAlpha_[i] /= NumberOfCases;
       DFo_DBeta_[i]  /= NumberOfCases;
       DFo_DP_[i]     /= NumberOfCases;
       DFo_DQ_[i]     /= NumberOfCases;
       DFo_DR_[i]     /= NumberOfCases;
       DFo_DMach_[i]  /= NumberOfCases;
                      
       // Moments     
                      
       DMi_DAlpha_[i] /= NumberOfCases;
       DMi_DBeta_[i]  /= NumberOfCases;
       DMi_DP_[i]     /= NumberOfCases;
       DMi_DQ_[i]     /= NumberOfCases;
       DMi_DR_[i]     /= NumberOfCases;
       DMi_DMach_[i]  /= NumberOfCases;
                    
       DMo_DAlpha_[i] /= NumberOfCases;
       DMo_DBeta_[i]  /= NumberOfCases;
       DMo_DP_[i]     /= NumberOfCases;
       DMo_DQ_[i]     /= NumberOfCases;
       DMo_DR_[i]     /= NumberOfCases;
       DMo_DMach_[i]  /= NumberOfCases;
                            
    }
  
}
 
/*##############################################################################
#                                                                              #
#          VSP_SOLVER CalculateForceCoefficientGradients_wrt_Inputs            #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateForceCoefficientGradients_wrt_Inputs(void)
{

    double CA, SA, CB, SB;
    
    // Calculate aero force and moment derivatives wrt user inputs (ie CL, CD, CS, CMl, CMm, and CMn)...
    
    CA = cos(AngleOfAttack_);
    SA = sin(AngleOfAttack_);

    CB = cos(AngleOfBeta_);
    SB = sin(AngleOfBeta_);

    // Inviscid or total forces
      
       // CL wrt alpha
       
       DAeroFi_DAlpha_[0] = -DFi_DAlpha_[0] * SA + DFi_DAlpha_[2] * CA - CFix() * CA - CFiz() * SA;
       
       // CD wrt alpha
       
       DAeroFi_DAlpha_[1] = ( DFi_DAlpha_[0] * CA + DFi_DAlpha_[2] * SA ) * CB - DFi_DAlpha_[1] * SB + ( -CFix() * SA + CFiz() * CA ) * CB;

       // CS wrt alpha
       
       DAeroFi_DAlpha_[2] = ( DFi_DAlpha_[0] * CA + DFi_DAlpha_[2] * SA ) * SB + DFi_DAlpha_[1] * CB + ( -CFix() * SA + CFiz() * CA ) * SB;
       
       // CL wrt beta
       
       DAeroFi_DBeta_[0] = -DFi_DBeta_[0] * SA + DFi_DBeta_[2] * CA;
       
       // CD wrt beta
       
       DAeroFi_DBeta_[1] = ( DFi_DBeta_[0] * CA + DFi_DBeta_[2] * SA ) * CB - DFi_DBeta_[1] * SB - ( CFix() * CA + CFiz() * SA ) * SB - CFiy() * CB;
       
       // CS wrt beta
       
       DAeroFi_DBeta_[2] = ( DFi_DBeta_[0] * CA + DFi_DBeta_[2] * SA ) * CB + DFi_DBeta_[1] * CB - (  CFix() * CA + CFiz() * SA) * SB - CFiy() * SB;
       
       // CL wrt P
       
       DAeroFi_DP_[0] = -DFi_DP_[0] * SA + DFi_DP_[2] * CA;
       
       // CD wrt to P
       
       DAeroFi_DP_[1] = ( DFi_DP_[0] * CA + DFi_DP_[2] * SA ) * CB - DFi_DP_[1] * SB;
       
       // CS wrt to P
       
       DAeroFi_DP_[2] = ( DFi_DP_[0] * CA + DFi_DP_[2] * SA ) * CB + DFi_DP_[1] * CB;
       
       // CL wrt Q
       
       DAeroFi_DQ_[0] = -DFi_DQ_[0] * SA + DFi_DQ_[2] * CA;
       
       // CD wrt Q   
       
       DAeroFi_DQ_[1] = ( DFi_DQ_[0] * CA + DFi_DQ_[2] * SA ) * CB - DFi_DQ_[1] * SB;
       
       // CS wrt Q
       
       DAeroFi_DQ_[2] = ( DFi_DQ_[0] * CA + DFi_DQ_[2] * SA ) * CB + DFi_DQ_[1] * CB;
       
       // CL wrt R
       
       DAeroFi_DR_[0] = -DFi_DR_[0] * SA + DFi_DR_[2] * CA;
       
       // CD wrt R   
       
       DAeroFi_DR_[1] = ( DFi_DR_[0] * CA + DFi_DR_[2] * SA ) * CB - DFi_DR_[1] * SB;
       
       // CS wrt R
       
       DAeroFi_DR_[2] = ( DFi_DR_[0] * CA + DFi_DR_[2] * SA ) * CB + DFi_DR_[1] * CB;
       
       // CL wrt Mach
       
       DAeroFi_DMach_[0] = -DFi_DMach_[0] * SA + DFi_DMach_[2] * CA;
       
       // CD wrt to Mach   
       
       DAeroFi_DMach_[1] = ( DFi_DMach_[0] * CA + DFi_DMach_[2] * SA ) * CB - DFi_DMach_[1] * SB;
       
       // CS wrt to Mach
       
       DAeroFi_DMach_[2] = ( DFi_DMach_[0] * CA + DFi_DMach_[2] * SA ) * CB + DFi_DMach_[1] * CB;
       
       // CL wrt x CG
       
       DAeroFi_DCG_[0][0] = -DFi_DCG_[0][0] * SA + DFi_DCG_[2][0] * CA;
       
       // CD wrt x CG   
       
       DAeroFi_DCG_[1][0] = ( DFi_DCG_[0][0] * CA + DFi_DCG_[2][0] * SA ) * CB - DFi_DCG_[1][0] * SB;
       
       // CS wrt x CG
       
       DAeroFi_DCG_[2][0] = ( DFi_DCG_[0][0] * CA + DFi_DCG_[2][0] * SA ) * CB + DFi_DCG_[1][0] * CB;
           
       // CL wrt y CG
       
       DAeroFi_DCG_[0][1] = -DFi_DCG_[0][1] * SA + DFi_DCG_[2][1] * CA;
       
       // CD wrt y CG   
       
       DAeroFi_DCG_[1][1] = ( DFi_DCG_[0][1] * CA + DFi_DCG_[2][1] * SA ) * CB - DFi_DCG_[1][1] * SB;
       
       // CS wrt y CG
       
       DAeroFi_DCG_[2][1] = ( DFi_DCG_[0][1] * CA + DFi_DCG_[2][1] * SA ) * CB + DFi_DCG_[1][1] * CB;
           
       // CL wrt z CG
       
       DAeroFi_DCG_[0][2] = -DFi_DCG_[0][2] * SA + DFi_DCG_[2][2] * CA;
       
       // CD wrt z CG   
       
       DAeroFi_DCG_[1][2] = ( DFi_DCG_[0][2] * CA + DFi_DCG_[2][2] * SA ) * CB - DFi_DCG_[1][2] * SB;
       
       // CS wrt z CG
       
       DAeroFi_DCG_[2][2] = ( DFi_DCG_[0][2] * CA + DFi_DCG_[2][2] * SA ) * CB + DFi_DCG_[1][2] * CB;
           
       // CL wrt Re
       
       DAeroFi_DRe_[0] = -DFi_DRe_[0] * SA + DFi_DRe_[2] * CA;
       
       // CD wrt Re   
       
       DAeroFi_DRe_[1] = ( DFi_DRe_[0] * CA + DFi_DRe_[2] * SA ) * CB - DFi_DRe_[1] * SB;
       
       // CS wrt Re
       
       DAeroFi_DRe_[2] = ( DFi_DRe_[0] * CA + DFi_DRe_[2] * SA ) * CB + DFi_DRe_[1] * CB;

    // Inviscid or total moments

       // CMl wrt Alpha
       
       DAeroMi_DAlpha_[0] = -DMi_DAlpha_[0];

       // CMm wrt Alpha
       
       DAeroMi_DAlpha_[1] =  DMi_DAlpha_[1];
       
       // CMn wrt Alpha
       
       DAeroMi_DAlpha_[2] = -DMi_DAlpha_[2];
       
       // CMl wrt Beta
       
       DAeroMi_DBeta_[0] = -DMi_DBeta_[0];

       // CMm wrt Beta
       
       DAeroMi_DBeta_[1] =  DMi_DBeta_[1];
       
       // CMn wrt Beta
       
       DAeroMi_DBeta_[2] = -DMi_DBeta_[2];                              

       // CMl wrt P
       
       DAeroMi_DP_[0] = -DMi_DP_[0];

       // CMm wrt P
       
       DAeroMi_DP_[1] =  DMi_DP_[1];
       
       // CMn wrt P
       
       DAeroMi_DP_[2] = -DMi_DP_[2];                              

       // CMl wrt Q
       
       DAeroMi_DQ_[0] = -DMi_DQ_[0];

       // CMm wrt Q
       
       DAeroMi_DQ_[1] =  DMi_DQ_[1];
       
       // CMn wrt Q
       
       DAeroMi_DQ_[2] = -DMi_DQ_[2];       
       
       // CMl wrt R
       
       DAeroMi_DR_[0] = -DMi_DR_[0];

       // CMm wrt R
       
       DAeroMi_DR_[1] =  DMi_DR_[1];
       
       // CMn wrt R
       
       DAeroMi_DR_[2] = -DMi_DR_[2];              
       
       // CMl wrt Mach
       
       DAeroMi_DMach_[0] = -DMi_DMach_[0];

       // CMm wrt Mach
       
       DAeroMi_DMach_[1] =  DMi_DMach_[1];
       
       // CMn wrt Mach
       
       DAeroMi_DMach_[2] = -DMi_DMach_[2];                 

       // CMl wrt x CG
       
       DAeroMi_DCG_[0][0] = -DMi_DCG_[0][0];

       // CMm wrt x CG
       
       DAeroMi_DCG_[1][0] =  DMi_DCG_[1][0];
       
       // CMn wrt x CG
       
       DAeroMi_DCG_[2][0] = -DMi_DCG_[2][0];       

       // CMl wrt y CG
       
       DAeroMi_DCG_[0][1] = -DMi_DCG_[0][1];

       // CMm wrt y CG
       
       DAeroMi_DCG_[1][1] =  DMi_DCG_[1][1];
       
       // CMn wrt y CG
       
       DAeroMi_DCG_[2][1] = -DMi_DCG_[2][1];       

       // CMl wrt z CG
       
       DAeroMi_DCG_[0][2] = -DMi_DCG_[0][2];

       // CMm wrt z CG
       
       DAeroMi_DCG_[1][2] =  DMi_DCG_[1][2];
       
       // CMn wrt z CG
       
       DAeroMi_DCG_[2][2] = -DMi_DCG_[2][2];       
       
       // CMl wrt Re
       
       DAeroMi_DRe_[0] = -DMi_DRe_[0];

       // CMm wrt Re
       
       DAeroMi_DRe_[1] =  DMi_DRe_[1];
       
       // CMn wrt Re
       
       DAeroMi_DRe_[2] = -DMi_DRe_[2];       
       
    // Viscous forces
      
       // CL wrt alpha
       
       DAeroFo_DAlpha_[0] = -DFo_DAlpha_[0] * SA + DFo_DAlpha_[2] * CA - CFox() * CA - CFoz() * SA;
       
       // CD wrt alpha
       
       DAeroFo_DAlpha_[1] = ( DFo_DAlpha_[0] * CA + DFo_DAlpha_[2] * SA ) * CB - DFo_DAlpha_[1] * SB + ( -CFox() * SA + CFoz() * CA ) * CB;

       // CS wrt alpha
       
       DAeroFo_DAlpha_[2] = ( DFo_DAlpha_[0] * CA + DFo_DAlpha_[2] * SA ) * SB + DFo_DAlpha_[1] * CB + ( -CFox() * SA + CFoz() * CA ) * SB;
       
       // CL wrt beta
       
       DAeroFo_DBeta_[0] = -DFo_DBeta_[0] * SA + DFo_DBeta_[2] * CA;
       
       // CD wrt beta
       
       DAeroFo_DBeta_[1] = ( DFo_DBeta_[0] * CA + DFo_DBeta_[2] * SA ) * CB - DFo_DBeta_[1] * SB - ( CFox() * CA + CFoz() * SA ) * SB - CFoy() * CB;
       
       // CS wrt beta
       
       DAeroFo_DBeta_[2] = ( DFo_DBeta_[0] * CA + DFo_DBeta_[2] * SA ) * CB + DFo_DBeta_[1] * CB - ( CFox() * CA + CFoz() * SA) * SB - CFoy() * SB;
       
       // CL wrt P
       
       DAeroFo_DP_[0] = -DFo_DP_[0] * SA + DFo_DP_[2] * CA;
       
       // CD wrt to P
       
       DAeroFo_DP_[1] = ( DFo_DP_[0] * CA + DFo_DP_[2] * SA ) * CB - DFo_DP_[1] * SB;
       
       // CS wrt to P
       
       DAeroFo_DP_[2] = ( DFo_DP_[0] * CA + DFo_DP_[2] * SA ) * CB + DFo_DP_[1] * CB;
       
       // CL wrt Q
       
       DAeroFo_DQ_[0] = -DFo_DQ_[0] * SA + DFo_DQ_[2] * CA;
       
       // CD wrt Q   
       
       DAeroFo_DQ_[1] = ( DFo_DQ_[0] * CA + DFo_DQ_[2] * SA ) * CB - DFo_DQ_[1] * SB;
       
       // CS wrt Q
       
       DAeroFo_DQ_[2] = ( DFo_DQ_[0] * CA + DFo_DQ_[2] * SA ) * CB + DFo_DQ_[1] * CB;
       
       // CL wrt R
       
       DAeroFo_DQ_[0] = -DFo_DR_[0] * SA + DFo_DR_[2] * CA;
       
       // CD wrt R   
       
       DAeroFo_DQ_[1] = ( DFo_DR_[0] * CA + DFo_DR_[2] * SA ) * CB - DFo_DR_[1] * SB;
       
       // CS wrt R
       
       DAeroFo_DR_[2] = ( DFo_DR_[0] * CA + DFo_DR_[2] * SA ) * CB + DFo_DR_[1] * CB;
       
       // CL wrt Mach
       
       DAeroFo_DMach_[0] = -DFo_DMach_[0] * SA + DFo_DMach_[2] * CA;
       
       // CD wrt to Mach   
       
       DAeroFo_DMach_[1] = ( DFo_DMach_[0] * CA + DFo_DMach_[2] * SA ) * CB - DFo_DMach_[1] * SB;
       
       // CS wrt to Mach
       
       DAeroFo_DMach_[2] = ( DFo_DMach_[0] * CA + DFo_DMach_[2] * SA ) * CB + DFo_DMach_[1] * CB;
       
       // CL wrt x CG
       
       DAeroFo_DCG_[0][0] = -DFo_DCG_[0][0] * SA + DFo_DCG_[2][0] * CA;
       
       // CD wrt x CG   
       
       DAeroFo_DCG_[1][0] = ( DFo_DCG_[0][0] * CA + DFo_DCG_[2][0] * SA ) * CB - DFo_DCG_[1][0] * SB;
       
       // CS wrt x CG
       
       DAeroFo_DCG_[2][0] = ( DFo_DCG_[0][0] * CA + DFo_DCG_[2][0] * SA ) * CB + DFo_DCG_[1][0] * CB;
           
       // CL wrt y CG
       
       DAeroFo_DCG_[0][1] = -DFo_DCG_[0][1] * SA + DFo_DCG_[2][1] * CA;
       
       // CD wrt y CG   
       
       DAeroFo_DCG_[1][1] = ( DFo_DCG_[0][1] * CA + DFo_DCG_[2][1] * SA ) * CB - DFo_DCG_[1][1] * SB;
       
       // CS wrt y CG
       
       DAeroFo_DCG_[2][1] = ( DFo_DCG_[0][1] * CA + DFo_DCG_[2][1] * SA ) * CB + DFo_DCG_[1][1] * CB;
           
       // CL wrt z CG
       
       DAeroFo_DCG_[0][2] = -DFo_DCG_[0][2] * SA + DFo_DCG_[2][2] * CA;
       
       // CD wrt z CG   
       
       DAeroFo_DCG_[1][2] = ( DFo_DCG_[0][2] * CA + DFo_DCG_[2][2] * SA ) * CB - DFo_DCG_[1][2] * SB;
       
       // CS wrt z CG
       
       DAeroFo_DCG_[2][2] = ( DFo_DCG_[0][2] * CA + DFo_DCG_[2][2] * SA ) * CB + DFo_DCG_[1][2] * CB;
           
       // CL wrt Re
       
       DAeroFo_DRe_[0] = -DFo_DRe_[0] * SA + DFo_DRe_[2] * CA;
       
       // CD wrt Re   
       
       DAeroFo_DRe_[1] = ( DFo_DRe_[0] * CA + DFo_DRe_[2] * SA ) * CB - DFo_DRe_[1] * SB;
       
       // CS wrt Re
       
       DAeroFo_DRe_[2] = ( DFo_DRe_[0] * CA + DFo_DRe_[2] * SA ) * CB + DFo_DRe_[1] * CB;

    // Inviscid or total moments

       // CMl wrt Alpha
       
       DAeroMo_DAlpha_[0] = -DMo_DAlpha_[0];

       // CMm wrt Alpha
       
       DAeroMo_DAlpha_[1] =  DMo_DAlpha_[1];
       
       // CMn wrt Alpha
       
       DAeroMo_DAlpha_[2] = -DMo_DAlpha_[2];
       
       // CMl wrt Beta
       
       DAeroMo_DBeta_[0] = -DMo_DBeta_[0];

       // CMm wrt Beta
       
       DAeroMo_DBeta_[1] =  DMo_DBeta_[1];
       
       // CMn wrt Beta
       
       DAeroMo_DBeta_[2] = -DMo_DBeta_[2];                              

       // CMl wrt P
       
       DAeroMo_DP_[0] = -DMo_DP_[0];

       // CMm wrt P
       
       DAeroMo_DP_[1] =  DMo_DP_[1];
       
       // CMn wrt P
       
       DAeroMo_DP_[2] = -DMo_DP_[2];                              

       // CMl wrt Q
       
       DAeroMo_DQ_[0] = -DMo_DQ_[0];

       // CMm wrt Q
       
       DAeroMo_DQ_[1] =  DMo_DQ_[1];
       
       // CMn wrt Q
       
       DAeroMo_DQ_[2] = -DMo_DQ_[2];       
       
       // CMl wrt R
       
       DAeroMo_DR_[0] = -DMo_DR_[0];

       // CMm wrt R
       
       DAeroMo_DR_[1] =  DMo_DR_[1];
       
       // CMn wrt R
       
       DAeroMo_DR_[2] = -DMo_DR_[2];              
       
       // CMl wrt Mach
       
       DAeroMo_DMach_[0] = -DMo_DMach_[0];

       // CMm wrt Mach
       
       DAeroMo_DMach_[1] =  DMo_DMach_[1];
       
       // CMn wrt Mach
       
       DAeroMo_DMach_[2] = -DMo_DMach_[2];                 

       // CMl wrt x CG
       
       DAeroMo_DCG_[0][0] = -DMo_DCG_[0][0];

       // CMm wrt x CG
       
       DAeroMo_DCG_[1][0] =  DMo_DCG_[1][0];
       
       // CMn wrt x CG
       
       DAeroMo_DCG_[2][0] = -DMo_DCG_[2][0];       

       // CMl wrt y CG
       
       DAeroMo_DCG_[0][1] = -DMo_DCG_[0][1];

       // CMm wrt y CG
       
       DAeroMo_DCG_[1][1] =  DMo_DCG_[1][1];
       
       // CMn wrt y CG
       
       DAeroMo_DCG_[2][1] = -DMo_DCG_[2][1];       

       // CMl wrt z CG
      
       DAeroMo_DCG_[0][2] = -DMo_DCG_[0][2];

       // CMm wrt z CG
       
       DAeroMo_DCG_[1][2] =  DMo_DCG_[1][2];
       
       // CMn wrt z CG
              
       DAeroMo_DCG_[2][2] = -DMo_DCG_[2][2];       
              
       // CMl wrt Re
       
       DAeroMo_DRe_[0] = -DMo_DRe_[0];

       // CMm wrt Re
       
       DAeroMo_DRe_[1] =  DMo_DRe_[1];
       
       // CMn wrt Re
       
       DAeroMo_DRe_[2] = -DMo_DRe_[2];   

}

/*##############################################################################
#                                                                              #
#          VSP_SOLVER CalculateForceCoefficientGradients_wrt_Mesh              #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateForceCoefficientGradients_wrt_Mesh(void)
{
   
    int i;
    double CA, SA, CB, SB;
    
    CA = cos(AngleOfAttack_);
    SA = sin(AngleOfAttack_);

    CB = cos(AngleOfBeta_);
    SB = sin(AngleOfBeta_);

    // Calculate aero force and moment derivatives wrt mesh (ie CL, CD, CS, CMl, CMm, and CMn)...
           
//    CLi_ = (-CFix_ * SA + CFiz_ * CA );
           
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {
   
       // Total derivatives
                 
          // Inviscid, or Inviscid + Viscous
                        
             // CL
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).DCLi_DX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DX() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DX() * CA ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCLi_DY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DY() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DY() * CA ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCLi_DZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DZ() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DZ() * CA ) / (0.5*Sref_*Vref_*Vref_);
             
             // CD
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).DCDi_DX() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DX() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DX() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DX() * SB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCDi_DY() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DY() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DY() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DY() * SB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCDi_DZ() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DZ() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DZ() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DZ() * SB ) / (0.5*Sref_*Vref_*Vref_);
                   
             // CS
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).DCSi_DX() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DX() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DX() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DX() * CB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCSi_DY() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DY() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DY() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DY() * CB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCSi_DZ() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DZ() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DZ() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DZ() * CB ) / (0.5*Sref_*Vref_*Vref_);
             
             // CMl
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMli_DX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DX() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMli_DY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DY() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMli_DZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DZ() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             
             // CMm
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMmi_DX() = (  VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DX() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMmi_DY() = (  VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DY() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMmi_DZ() = (  VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DZ() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
                                                                                                               
             // CMn
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMni_DX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DX() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMni_DY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DY() ) / (0.5*Sref_*Bref_*Vref_*Vref_); 
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMni_DZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DZ() ) / (0.5*Sref_*Bref_*Vref_*Vref_); 

          // Viscous
                 
             // CL
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).DCLo_DX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DX() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DX() * CA ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCLo_DY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DY() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DY() * CA ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCLo_DZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DZ() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DZ() * CA ) / (0.5*Sref_*Vref_*Vref_);
                                                     
             // CD                                   
                                                     
             VSPGeom().Grid(MGLevel_).NodeList(i).DCDo_DX() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DX() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DX() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DX() * SB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCDo_DY() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DY() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DY() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DY() * SB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCDo_DZ() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DZ() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DZ() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DZ() * SB ) / (0.5*Sref_*Vref_*Vref_);
                                                     
             // CS                                   
                                                     
             VSPGeom().Grid(MGLevel_).NodeList(i).DCSo_DX() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DX() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DX() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DX() * CB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCSo_DY() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DY() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DY() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DY() * CB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCSo_DZ() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DZ() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DZ() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DZ() * CB ) / (0.5*Sref_*Vref_*Vref_);
             
             // CMl
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMlo_DX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DX() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMlo_DY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DY() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMlo_DZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DZ() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
                                                                                                        
             // CMm                                                                                     
                                                                                                        
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMmo_DX() = (  VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DX() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMmo_DY() = (  VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DY() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMmo_DZ() = (  VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DZ() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
                                                                                                               
             // CMn                                                                                      
                                                                                                         
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMno_DX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DX() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMno_DY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DY() ) / (0.5*Sref_*Bref_*Vref_*Vref_); 
             VSPGeom().Grid(MGLevel_).NodeList(i).DCMno_DZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DZ() ) / (0.5*Sref_*Bref_*Vref_*Vref_); 

       // Partial derivatives
                 
          // Inviscid, or Inviscid + Viscous
                 
             // CL
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).pCLi_pX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX() * CA ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCLi_pY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY() * CA ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCLi_pZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ() * CA ) / (0.5*Sref_*Vref_*Vref_);
                         
                         
        //     printf("CA, SA, CL: %f %f %f \n",
        //     -VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ() * SA,
        //      VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ() * CA,   
        //      VSPGeom().Grid(MGLevel_).NodeList(i).pCLi_pZ()*0.5*Sref_*Vref_*Vref_);fflush(NULL);        
                                                     
             // CD                                   
                                                     
             VSPGeom().Grid(MGLevel_).NodeList(i).pCDi_pX() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pX() * SB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCDi_pY() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pY() * SB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCDi_pZ() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pZ() * SB ) / (0.5*Sref_*Vref_*Vref_);
                                                                                                
             // CS                                                                              
                                                                                                
             VSPGeom().Grid(MGLevel_).NodeList(i).pCSi_pX() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pX() * CB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCSi_pY() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pY() * CB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCSi_pZ() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pZ() * CB ) / (0.5*Sref_*Vref_*Vref_);
                                                                                                  
             // CMl                                                                               
                                                                                                  
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMli_pX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMli_pY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMli_pZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
                                                                                                    
             // CMm                                                                                 
                                                                                                    
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMmi_pX() = (  VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMmi_pY() = (  VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMmi_pZ() = (  VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
                                                                                                    
             // CMn                         
                                                                                  
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMni_pX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMni_pY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY() ) / (0.5*Sref_*Bref_*Vref_*Vref_); 
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMni_pZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ() ) / (0.5*Sref_*Bref_*Vref_*Vref_); 

          // Viscous
                 
             // CL
                    
             VSPGeom().Grid(MGLevel_).NodeList(i).pCLo_pX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX() * CA ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCLo_pY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY() * CA ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCLo_pZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ() * SA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ() * CA ) / (0.5*Sref_*Vref_*Vref_);
                                                
             // CD                              
                                                
             VSPGeom().Grid(MGLevel_).NodeList(i).pCDo_pX() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX() * SB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCDo_pY() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY() * SB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCDo_pZ() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ() * SA ) * CB - VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ() * SB ) / (0.5*Sref_*Vref_*Vref_);
                                                                                                                                                                                                        
             // CS                                                                                                                                                                                      
                                                                                                                                                                                                        
             VSPGeom().Grid(MGLevel_).NodeList(i).pCSo_pX() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX() * CB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCSo_pY() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY() * CB ) / (0.5*Sref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCSo_pZ() = ( ( VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ() * CA + VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ() * SA ) * CB + VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ() * CB ) / (0.5*Sref_*Vref_*Vref_);
                                                                                                      
             // CMl                                                                                   
                                                                                                      
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMlo_pX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMlo_pY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMlo_pZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
                                                                                                      
             // CMm                                                                                   
                                                                                                      
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMmo_pX() = (  VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMmo_pY() = (  VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMmo_pZ() = (  VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ() ) / (0.5*Sref_*Cref_*Vref_*Vref_);
                                                                                                     
             // CMn                                                                                  
                                                                                                     
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMno_pX() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX() ) / (0.5*Sref_*Bref_*Vref_*Vref_);
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMno_pY() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY() ) / (0.5*Sref_*Bref_*Vref_*Vref_); 
             VSPGeom().Grid(MGLevel_).NodeList(i).pCMno_pZ() = ( -VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ() ) / (0.5*Sref_*Bref_*Vref_*Vref_); 
                                            
    }
         
}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER CalculateControlSurfaceDerivatives                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateControlSurfaceDerivatives(void)
{
   

    int i, j, k, p, Loop, Edge, Node, *DoThisNode, *LoopIsOnControlSurface;
    double xyz[3], CA, SA, CB, SB, Eps, pX_pDelta, pY_pDelta, pZ_pDelta, Fact;
    
    CA = cos(AngleOfAttack_);
    SA = sin(AngleOfAttack_);

    CB = cos(AngleOfBeta_);
    SB = sin(AngleOfBeta_);

    Eps = 1.;
    
    DoThisNode = new int[VSPGeom().Grid(0).NumberOfNodes() + 1];
    
    LoopIsOnControlSurface = new int[VSPGeom().Grid(0).NumberOfLoops() + 1];
     
    for ( k = 1 ; k <= VSPGeom().NumberOfControlSurfaces() ; k++ ) {
    
       zero_int_array(LoopIsOnControlSurface, VSPGeom().Grid(0).NumberOfLoops());

       zero_int_array(DoThisNode, VSPGeom().Grid(0).NumberOfNodes());
    
       // Mark tris on this control surface
       
       for ( p = 1 ; p <= VSPGeom().ControlSurface(k).NumberOfLoops() ; p++ ) {
       
          LoopIsOnControlSurface[VSPGeom().ControlSurface(k).LoopList(p)] = 1;
          
       }

       // Mark nodes on control surface

       for ( p = 1 ; p <= VSPGeom().ControlSurface(k).NumberOfLoops() ; p++ ) {
       
          Loop = VSPGeom().ControlSurface(k).LoopList(p);
          
          for ( j = 1 ; j <= VSPGeom().Grid(0).LoopList(Loop).NumberOfNodes() ; j++ ) {
             
             DoThisNode[VSPGeom().Grid(0).LoopList(Loop).Node(j)] = 1;
             
          }
          
       }
                
       // Mark nodes completely on the boundaries of the control surface       

       for ( p = 1 ; p <= VSPGeom().ControlSurface(k).NumberOfLoops() ; p++ ) {
       
          Loop = VSPGeom().ControlSurface(k).LoopList(p);
          
          for ( j = 1 ; j <= VSPGeom().Grid(0).LoopList(Loop).NumberOfEdges() ; j++ ) {
             
             Edge = VSPGeom().Grid(0).LoopList(Loop).Edge(j);
             
             if ( LoopIsOnControlSurface[VSPGeom().Grid(0).EdgeList(Edge).Loop1()] +
                  LoopIsOnControlSurface[VSPGeom().Grid(0).EdgeList(Edge).Loop2()] == 1 ) {
                     
                DoThisNode[VSPGeom().Grid(0).EdgeList(Edge).Node1()] = 2;
                DoThisNode[VSPGeom().Grid(0).EdgeList(Edge).Node2()] = 2;
                
             }
             
          }
          
       }
       
       VSPGeom().ControlSurface(k).pCFix_pDelta() = 0.; 
       VSPGeom().ControlSurface(k).pCFiy_pDelta() = 0.; 
       VSPGeom().ControlSurface(k).pCFiz_pDelta() = 0.; 
     
       VSPGeom().ControlSurface(k).pCMix_pDelta() = 0.; 
       VSPGeom().ControlSurface(k).pCMiy_pDelta() = 0.; 
       VSPGeom().ControlSurface(k).pCMiz_pDelta() = 0.; 
      
       VSPGeom().ControlSurface(k).pCFox_pDelta() = 0.; 
       VSPGeom().ControlSurface(k).pCFoy_pDelta() = 0.; 
       VSPGeom().ControlSurface(k).pCFoz_pDelta() = 0.; 
    
       VSPGeom().ControlSurface(k).pCMox_pDelta() = 0.; 
       VSPGeom().ControlSurface(k).pCMoy_pDelta() = 0.; 
       VSPGeom().ControlSurface(k).pCMoz_pDelta() = 0.; 
      
       for ( p = 1 ; p <= VSPGeom().ControlSurface(k).NumberOfLoops() ; p++ ) {
       
          Loop = VSPGeom().ControlSurface(k).LoopList(p);
          
          for ( j = 1 ; j <= VSPGeom().Grid(0).LoopList(Loop).NumberOfNodes() ; j++ ) {
             
             Node = VSPGeom().Grid(0).LoopList(Loop).Node(j);
             
             if ( DoThisNode[Node] > 0 ) {
                
                // We weight the nodes on the boundaries by a factor of 1./2. 
                // This accounts for the fact that when we run the actual solve the edges of the
                // control surfaces are warped
                
                Fact = 1./DoThisNode[Node];
                
                DoThisNode[Node] = 0;
               
                // + delta
                
                xyz[0] = VSPGeom().Grid(0).NodeList(Node).x();
                xyz[1] = VSPGeom().Grid(0).NodeList(Node).y();
                xyz[2] = VSPGeom().Grid(0).NodeList(Node).z();
                
                VSPGeom().ControlSurface(k).DeflectionAngle() += Eps;
                
                VSPGeom().ControlSurface(k).RotateXYZPoint(xyz);

                pX_pDelta = xyz[0] - VSPGeom().Grid(0).NodeList(Node).x();
                pY_pDelta = xyz[1] - VSPGeom().Grid(0).NodeList(Node).y();;
                pZ_pDelta = xyz[2] - VSPGeom().Grid(0).NodeList(Node).z();

               // // - delta
               // 
               // xyz[0] = VSPGeom().Grid(0).NodeList(Node).x();
               // xyz[1] = VSPGeom().Grid(0).NodeList(Node).y();
               // xyz[2] = VSPGeom().Grid(0).NodeList(Node).z();
               // 
               // VSPGeom().ControlSurface(k).DeflectionAngle() -= 2.*Eps;
               // 
               // VSPGeom().ControlSurface(k).RotateXYZPoint(xyz);
               //
               // pX_pDelta -= xyz[0];
               // pY_pDelta -= xyz[1];
               // pZ_pDelta -= xyz[2];
               //
               // pX_pDelta /(2.*Eps);
               // pY_pDelta /(2.*Eps);
               // pZ_pDelta /(2.*Eps);
                     
                VSPGeom().ControlSurface(k).DeflectionAngle() -= Eps;
              
                VSPGeom().ControlSurface(k).pCFix_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DFix_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFix_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFix_DZ() * pZ_pDelta ); 
                VSPGeom().ControlSurface(k).pCFiy_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DFiy_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFiy_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFiy_DZ() * pZ_pDelta ); 
                VSPGeom().ControlSurface(k).pCFiz_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DFiz_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFiz_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFiz_DZ() * pZ_pDelta ); 
                                                                                                                                                                                                                                                                   
                VSPGeom().ControlSurface(k).pCMix_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DMix_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMix_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMix_DZ() * pZ_pDelta ); 
                VSPGeom().ControlSurface(k).pCMiy_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DMiy_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMiy_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMiy_DZ() * pZ_pDelta ); 
                VSPGeom().ControlSurface(k).pCMiz_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DMiz_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMiz_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMiz_DZ() * pZ_pDelta ); 
                                                                                                                                                                                                                                                                    
                VSPGeom().ControlSurface(k).pCFox_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DFox_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFox_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFox_DZ() * pZ_pDelta ); 
                VSPGeom().ControlSurface(k).pCFoy_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DFoy_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFoy_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFoy_DZ() * pZ_pDelta ); 
                VSPGeom().ControlSurface(k).pCFoz_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DFoz_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFoz_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DFoz_DZ() * pZ_pDelta ); 
                                                                                                                                                                                                                                                                   
                VSPGeom().ControlSurface(k).pCMox_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DMox_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMox_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMox_DZ() * pZ_pDelta ); 
                VSPGeom().ControlSurface(k).pCMoy_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DMoy_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMoy_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMoy_DZ() * pZ_pDelta ); 
                VSPGeom().ControlSurface(k).pCMoz_pDelta() += Fact * ( VSPGeom().Grid(MGLevel_).NodeList(Node).DMoz_DX() * pX_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMoz_DY() * pY_pDelta + VSPGeom().Grid(MGLevel_).NodeList(Node).DMoz_DZ() * pZ_pDelta ); 
    
             }
             
          }
            
       }

//       VSPGeom().ControlSurface(k).pCFix_pDelta() *= 
//       VSPGeom().ControlSurface(k).pCFiy_pDelta() *= 
//       VSPGeom().ControlSurface(k).pCFiz_pDelta() *= 
//                                               
//       VSPGeom().ControlSurface(k).pCMix_pDelta() *= 
//       VSPGeom().ControlSurface(k).pCMiy_pDelta() *= 
//       VSPGeom().ControlSurface(k).pCMiz_pDelta() *= 
//                                                  *= 
//       VSPGeom().ControlSurface(k).pCFox_pDelta() *= 
//       VSPGeom().ControlSurface(k).pCFoy_pDelta() *= 
//       VSPGeom().ControlSurface(k).pCFoz_pDelta() *= 
//                                                
//       VSPGeom().ControlSurface(k).pCMox_pDelta() *= 
//       VSPGeom().ControlSurface(k).pCMoy_pDelta() *= 
//       VSPGeom().ControlSurface(k).pCMoz_pDelta() *= 
//       
//printf("VSPGeom().ControlSurface(k).pCFix_pDelta(): %f \n",VSPGeom().ControlSurface(k).pCFix_pDelta());fflush(NULL);
//printf("VSPGeom().ControlSurface(k).pCFiy_pDelta(): %f \n",VSPGeom().ControlSurface(k).pCFiy_pDelta());fflush(NULL);
//printf("VSPGeom().ControlSurface(k).pCFiz_pDelta(): %f \n",VSPGeom().ControlSurface(k).pCFiz_pDelta());fflush(NULL);
//
//printf("VSPGeom().ControlSurface(k).pCMix_pDelta(): %f \n",VSPGeom().ControlSurface(k).pCMix_pDelta());fflush(NULL);
//printf("VSPGeom().ControlSurface(k).pCMiy_pDelta(): %f \n",VSPGeom().ControlSurface(k).pCMiy_pDelta());fflush(NULL);
//printf("VSPGeom().ControlSurface(k).pCMiz_pDelta(): %f \n",VSPGeom().ControlSurface(k).pCMiz_pDelta());fflush(NULL);
       
              
       // Non-dimensionalize

      VSPGeom().ControlSurface(k).pCFix_pDelta() /= (0.5*Sref_*Vref_*Vref_);
      VSPGeom().ControlSurface(k).pCFiy_pDelta() /= (0.5*Sref_*Vref_*Vref_);
      VSPGeom().ControlSurface(k).pCFiz_pDelta() /= (0.5*Sref_*Vref_*Vref_);
     
      VSPGeom().ControlSurface(k).pCMix_pDelta() /= (0.5*Sref_*Bref_*Vref_*Vref_);
      VSPGeom().ControlSurface(k).pCMiy_pDelta() /= (0.5*Sref_*Cref_*Vref_*Vref_);
      VSPGeom().ControlSurface(k).pCMiz_pDelta() /= (0.5*Sref_*Bref_*Vref_*Vref_);
     
      VSPGeom().ControlSurface(k).pCFox_pDelta() /= (0.5*Sref_*Vref_*Vref_);
      VSPGeom().ControlSurface(k).pCFoy_pDelta() /= (0.5*Sref_*Vref_*Vref_);
      VSPGeom().ControlSurface(k).pCFoz_pDelta() /= (0.5*Sref_*Vref_*Vref_);
     
      VSPGeom().ControlSurface(k).pCMox_pDelta() /= (0.5*Sref_*Bref_*Vref_*Vref_);
      VSPGeom().ControlSurface(k).pCMoy_pDelta() /= (0.5*Sref_*Cref_*Vref_*Vref_);
      VSPGeom().ControlSurface(k).pCMoz_pDelta() /= (0.5*Sref_*Bref_*Vref_*Vref_);
       
       // Convert into aero coefficients              
       
       VSPGeom().ControlSurface(k).pCLi_pDelta()  =  -VSPGeom().ControlSurface(k).pCFix_pDelta() * SA + VSPGeom().ControlSurface(k).pCFiz_pDelta() * CA;
       VSPGeom().ControlSurface(k).pCDi_pDelta()  = ( VSPGeom().ControlSurface(k).pCFix_pDelta() * CA + VSPGeom().ControlSurface(k).pCFiz_pDelta() * SA ) * CB - VSPGeom().ControlSurface(k).pCFiy_pDelta() * SB;
       VSPGeom().ControlSurface(k).pCSi_pDelta()  = ( VSPGeom().ControlSurface(k).pCFix_pDelta() * CA + VSPGeom().ControlSurface(k).pCFiz_pDelta() * SA ) * CB + VSPGeom().ControlSurface(k).pCFiy_pDelta() * SB; 
     
       VSPGeom().ControlSurface(k).pCMli_pDelta() = -VSPGeom().ControlSurface(k).pCMix_pDelta();
       VSPGeom().ControlSurface(k).pCMmi_pDelta() =  VSPGeom().ControlSurface(k).pCMiy_pDelta(); 
       VSPGeom().ControlSurface(k).pCMni_pDelta() = -VSPGeom().ControlSurface(k).pCMiz_pDelta(); 
     
       VSPGeom().ControlSurface(k).pCLo_pDelta()  =  -VSPGeom().ControlSurface(k).pCFox_pDelta() * SA + VSPGeom().ControlSurface(k).pCFoz_pDelta() * CA;
       VSPGeom().ControlSurface(k).pCDo_pDelta()  = ( VSPGeom().ControlSurface(k).pCFox_pDelta() * CA + VSPGeom().ControlSurface(k).pCFoz_pDelta() * SA ) * CB - VSPGeom().ControlSurface(k).pCFoy_pDelta() * SB;
       VSPGeom().ControlSurface(k).pCSo_pDelta()  = ( VSPGeom().ControlSurface(k).pCFox_pDelta() * CA + VSPGeom().ControlSurface(k).pCFoz_pDelta() * SA ) * CB + VSPGeom().ControlSurface(k).pCFoy_pDelta() * SB; 

       VSPGeom().ControlSurface(k).pCMlo_pDelta() = -VSPGeom().ControlSurface(k).pCMox_pDelta();
       VSPGeom().ControlSurface(k).pCMmo_pDelta() =  VSPGeom().ControlSurface(k).pCMoy_pDelta(); 
       VSPGeom().ControlSurface(k).pCMno_pDelta() = -VSPGeom().ControlSurface(k).pCMoz_pDelta(); 

    }
             
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER WriteOutMeshGradients                            #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteOutMeshGradients(void)
{
   
    int i;
    char AdjointGradientsFileName[MAX_CHAR_SIZE];
    FILE *AdjointGradientFile;
  
    // Write out gradients

    snprintf(AdjointGradientsFileName,sizeof(AdjointGradientsFileName)*sizeof(char),"%s.adjoint.gradient",FileName_);
       
    if ( (AdjointGradientFile = fopen(AdjointGradientsFileName, "w")) != NULL ) {

       fprintf(AdjointGradientFile,"Total force gradients \n");
       
                                  //1234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890 12345678901234567890  
       fprintf(AdjointGradientFile,"   Node             x                    y                    z                  pFxpX                pFxpY                pFxpZ                pFypX                pFypY                pFypZ                pFzpX                pFzpY                pFzpZ                pMxpX                pMxpY                pMxpZ                pMypX                pMypY               pMypZ                 pMzpX                pMzpY                pMzpZ               ");             
       fprintf(AdjointGradientFile,"pFxpX_i              pFxpY_i              pFxpZ_i              pFypX_i              pFypY_i              pFypZ_i              pFzpX_i              pFzpY_i              pFzpZ_i              pMxpX_i              pMxpY_i              pMxpZ_i              pMypX_i              pMyPyi              pMypZ_i               pMzpX_i              pMzpY_i              pMzpZ_i              ");             
       fprintf(AdjointGradientFile,"pFxpX_o              pFxpY_o              pFxpZ_o              pFypX_o              pFypY_o              pFypZ_o              pFzpX_o              pFzpY_o              pFzpZ_o              pMxpX_o              pMxpY_o              pMxpZ_o              pMypX_o              pMyPyo              pMypZ_o               pMzpX_o              pMzpY_o              pMzpZ_o              \n");             

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {
       
          fprintf(AdjointGradientFile,"%10d %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e ",
                 i,
                 VSPGeom().Grid(MGLevel_).NodeList(i).x(),
                 VSPGeom().Grid(MGLevel_).NodeList(i).y(),
                 VSPGeom().Grid(MGLevel_).NodeList(i).z(),
                 
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFtx_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFtx_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFtx_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFty_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFty_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFty_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFtz_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFtz_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFtz_DZ(),
                                                       
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMtx_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMtx_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMtx_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMty_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMty_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMty_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMtz_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMtz_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMtz_DZ());

          fprintf(AdjointGradientFile,"%20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e ",
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFix_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFiy_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFiz_DZ(),
   
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMix_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMiy_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMiz_DZ());

          fprintf(AdjointGradientFile,"%20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e %20.10e  \n",
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFox_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFoy_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DFoz_DZ(),
                                                      
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMox_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMoy_DZ(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DX(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DY(),              
                 VSPGeom().Grid(MGLevel_).NodeList(i).DMoz_DZ());
                 
       }
             
       fclose(AdjointGradientFile);
                            
    }            
     
}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER DoAdjointMatrixMultiply                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DoAdjointMatrixMultiply(double *vec_in, double *vec_out)
{

    int i, j, k, Node, Node1, Node2, Level, Edge, KuttaLoop1, KuttaLoop2;
    int Loop, LoopL, LoopR, Sign, KuttaStallEquationNumber, Eqn1X, Eqn2X;
    int VortexStretchingRatioEquationNumber;
    double GammaTE, Velocity, Cl_Ratio, dCl_Ratio_dGammaTE, dCl_Ratio_dGamma;
    double Chord, Fstall, pFstall_pX, dABS_Cl_Ratio_dCl_Ratio, dR_dGamma, dR_dStallFactor;

    double pCircumference_pLength;
    double pResidual_pRatio;
    double pResidual_pCircumference;
                               
    double dLength_dX1; 
    double dLength_dY1;
    double dLength_dZ1;
                      
    double dLength_dX2;
    double dLength_dY2;
    double dLength_dZ2;
    
    double dVecX_dX1;
    double dVecX_dY1;
    double dVecX_dZ1;
                     
    double dVecY_dX1;
    double dVecY_dY1;
    double dVecY_dZ1;
                      
    double dVecZ_dX1;
    double dVecZ_dY1;
    double dVecZ_dZ1;
                      
    double dVecX_dX2;
    double dVecX_dY2;
    double dVecX_dZ2;
                     
    double dVecY_dX2;
    double dVecY_dY2;
    double dVecY_dZ2;
                       
    double dVecZ_dX2;
    double dVecZ_dY2;
    double dVecZ_dZ2; 
    
    // Zero out solution vectors

    zero_double_array(vec_out,NumberOfEquations_);

    zero_double_array(DeltaGamma_ ,VSPGeom().Grid(MGLevel_).NumberOfLoops());

    zero_double_array(DeltaXYZ_,3*VSPGeom().Grid(MGLevel_).NumberOfNodes());
    
    // Initialize dgamma
    
    dGamma(0) = 0.;

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {

       dGamma(i) = vec_in[i];
   
    }

    // Initialize dxyz
    
    dXYZ(0) = 0.;

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {

          for ( j = 1 ; j <= VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes() ; j++ ) {
 
             // Wake node on MGLevel_ mesh
             
             Node = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j);
             
             dXYZ(3*Node-2) = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberX(j)];
             dXYZ(3*Node-1) = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberY(j)];
             dXYZ(3*Node  ) = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberZ(j)];

          }
          
       }
       
    }

    // Initialize stall delta factors
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
        
          VSPGeom().VortexSheet(k).TrailingVortex(i).dStallFactor() = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];

       }
       
    }    

    // Propagate stall factors for each trailing vortex loop
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
          
          j = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaEdge();
                
          VSPGeom().VortexSheet(k).WakeLoopList(i).dStallFactor() = VSPGeom().VortexSheet(k).TrailingVortex(j).dStallFactor();

       }
    
    } 

    if ( TimeAccurate_ ) {
       
      for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
         for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
            
            Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
            
            if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {

               VSPGeom().VortexSheet(k).WakeLoopList(i).dVortexStretchingRatio() = vec_in[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()];

            }
            
            else {
               
               VSPGeom().VortexSheet(k).WakeLoopList(i).dVortexStretchingRatio() = 0.;
               
            }
            
         }
          
      }
      
    }
    
    // Restrict the current solution to the coarser grids

    UpdatePerturbationVortexEdgeStrengths(MGLevel_);
     
    for ( Level = MGLevel_ ; Level < NumberOfMGLevels_ ; Level++ ) {
       
       RestrictPerturbationSolutionFromGrid(Level);
           
       UpdatePerturbationVortexEdgeStrengths(Level+1);
  
    }

    // Zero out the perturbation velocities
    
    ZeroLoopPerturbationVelocities();

    // Zero edge perturbation velocities
    
    ZeroEdgePerturbationVelocities();
     
    // (1) Calculate gamma perturbation induced velocities over surface loops
    //  [v^t]   [J ][  ][  ][  ]
    //  [   ] x [  ][  ][  ][  ]
    //  [   ]   [  ][  ][  ][  ]
    //  [   ]   [  ][  ][  ][  ]

    CalculateGammaPerturbationLoopVelocities_Tranpose(vec_in,vec_out);

    // (2) Calculate gamma perturbation induced velocities over wake edges
    //  [   ]   [  ][  ][  ][  ]  
    //  [v^t] x [J ][  ][  ][  ]
    //  [   ]   [  ][  ][  ][  ]
    //  [   ]   [  ][  ][  ][  ]
     
    CalculateGammaPerturbationEdgeVelocities_Tranpose(vec_in,vec_out);    

    // Redistribute the terms that were calculated for the wake loops... these need to be split over the corresponding
    // Kutta edge loops...

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
          
          Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
          
          KuttaLoop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
          
          KuttaLoop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();
          
          Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
   
          Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
          
          if ( !TimeAccurate_ || VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() == 1 ) {
   
             if ( KuttaLoop1 > 0 ) vec_out[KuttaLoop1] += Sign*vec_out[Loop];
             if ( KuttaLoop2 > 0 ) vec_out[KuttaLoop2] -= Sign*vec_out[Loop];
             
          }

          vec_out[Loop] = 0.;
   
       }
   
    }

    // Stall equations
    
    if ( StallModelIsOn_ ) {
       
       // (3) Calculate k stall perturbations over wake edges onto the surface loops
       //  [   ]   [  ][  ][J ][  ] 
       //  [   ] x [  ][  ][  ][  ]
       //  [v^t]   [  ][  ][  ][  ]
       //  [   ]   [  ][  ][  ][  ]
           
       CalculateKstallPerturbationLoopVelocities_Tranpose(vec_in, vec_out);
   
       // (4) Calculate k stall perturbations over wake edges onto the wake edges
       //  [   ]   [  ][  ][J ][  ] 
       //  [   ] x [  ][  ][  ][  ]
       //  [v^t]   [  ][  ][  ][  ]
       //  [   ]   [  ][  ][  ][  ]

       CalculateKstallPerturbationEdgeVelocities_Tranpose(vec_in, vec_out);
   
       // Redistribute the terms that were calculated for the wake loops onto the stall unknowns
   
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
   
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
             
             KuttaStallEquationNumber = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaStallEquationNumber();
   
             vec_out[KuttaStallEquationNumber] += vec_out[Loop];
  
             vec_out[Loop] = 0.;
   
          }
    
       }
       
    }

    // Vortex stretching ratio equations
    
    if ( TimeAccurate_ ) {
       
       // (3) Calculate vortex stretching ratio perturbations over wake edges onto the surface loops
       //  [   ]   [  ][  ][  ][J ] 
       //  [   ] x [  ][  ][  ][  ]
       //  [   ]   [  ][  ][  ][  ]
       //  [v^t]   [  ][  ][  ][  ]
           
       CalculateVortexStretchingRatioPerturbationLoopVelocities_Tranpose(vec_in, vec_out);
   
       // (4) Calculate vortex stretching ratio perturbations over wake edges onto the wake edges
       //  [   ]   [ ][  ][  ][J ] 
       //  [   ] x [  ][  ][  ][  ]
       //  [   ]   [  ][  ][  ][  ]
       //  [v^t]   [  ][  ][  ][  ]
          
       CalculateVortexStretchingRatioPerturbationEdgeVelocities_Tranpose(vec_in, vec_out);
   
       // Redistribute the terms that were calculated for the wake loops onto the vortex stretching ratio unknowns
   
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
   
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
             
             VortexStretchingRatioEquationNumber = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
   
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
   
                vec_out[VortexStretchingRatioEquationNumber] += vec_out[Loop];
    
             }
             
             vec_out[Loop] = 0.;
   
          }
    
       }
       
    }
    
    // (5) Calculate wake mesh perturbations over wake edges onto the surface loops
    //  [v^t]   [  ][J ][  ][  ] 
    //  [   ] x [  ][  ][  ][  ]
    //  [   ]   [  ][  ][  ][  ]
    //  [   ]   [  ][  ][  ][  ]
     
    CalculateMeshPerturbationEdgeVelocitiesOverLoops_Tranpose(vec_in,vec_out);

    // (6) Calculate wake mesh perturbations over wake edges back onto the wake edges
    //  [   ]   [  ][  ][  ][  ] 
    //  [v^t] x [  ][J ][  ][  ]
    //  [   ]   [  ][  ][  ][  ] 
    //  [   ]   [  ][  ][  ][  ] 

    CalculateMeshPerturbationEdgeVelocitiesOverEdges_Tranpose(vec_in,vec_out);

    // (7) Calculate the xyz_i+1 - xyz_i, or xyz_i+1 term(s) for steady/unsteady
    //  [   ]   [  ][  ][  ][  ] 
    //  [v^t] x [  ][J ][  ][  ]   
    //  [   ]   [  ][  ][  ][  ] 
    //  [   ]   [  ][  ][  ][  ] 

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
        
       VSPGeom().VortexSheet(k).WakeTranposeMatrixMultiplyMeshPerturbations(vec_in, vec_out);
        
    }

    // (8) Calculate the stall diagonal terms, and the pStall_pGamma_te terms
    //  [   ]   [  ][  ][  ][  ] 
    //  [   ] x [  ][  ][  ][  ]   
    //  [v^t]   [J ][  ][J ][  ] 
    //  [   ]   [  ][  ][  ][  ] 

    // Kutta stall equation 
     
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
          
          Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());

          LoopL = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
          
          LoopR = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();
                       
          GammaTE = Sign * VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma();
          
          Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
          
          Velocity = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[0], 2.)
                         + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[1], 2.)
                         + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[2], 2.) );

          if ( StallModelIsOn_ && Velocity > 0. ) {
            
             Cl_Ratio = GammaTE / ( 0.5 * Chord * Velocity * Clmax_2d_ );
             
             dCl_Ratio_dGammaTE = 1./( 0.5 * Chord * Velocity * Clmax_2d_ );
             
             dCl_Ratio_dGamma = dCl_Ratio_dGammaTE;

             StallFunction(ABS(Cl_Ratio),Fstall,pFstall_pX);
             
             dABS_Cl_Ratio_dCl_Ratio = 1.;
             
             if ( Cl_Ratio < 0. ) dABS_Cl_Ratio_dCl_Ratio = -1.;
         
             dR_dGamma = -Sign * pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dGamma;

             dR_dStallFactor = 1.;
  
             vec_out[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()] += dR_dStallFactor * vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];

             if ( LoopL > 0 ) vec_out[LoopL] += dR_dGamma * vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];

             if ( LoopR > 0 ) vec_out[LoopR] -= dR_dGamma * vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];
  
          }
          
          else {
             
             vec_out[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()] = vec_in[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];
          
          }             
          
       }
       
    }
    
    // (9) JxV for vortex stretching ratio equations
    
    //  [   ]   [   ][   ][   ][   ] 
    //  [   ] x [   ][   ][   ][   ]
    //  [   ]   [   ][   ][   ][   ] 
    //  [v^t]   [   ][J  ][   ][J  ] 
           
    if ( TimeAccurate_ ) {
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
             
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {

                pResidual_pRatio = VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1);
                
                pResidual_pCircumference = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio();
         
                pCircumference_pLength = 1.;
                
                VortexStretchingRatioEquationNumber = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
                
                vec_out[VortexStretchingRatioEquationNumber] += pResidual_pRatio * vec_in[VortexStretchingRatioEquationNumber];
                
                for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; j++ ) {
                   
                   Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(j);
    
                   Node1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node1() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
                                                                       
                   Node2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node2() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
                   
                   Eqn1X = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*Node1 - 2;

                   Eqn2X = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*Node2 - 2;
                   
                   VSPGeom().Grid(MGLevel_).EdgeList(Edge).SetupGradients(dLength_dX1, 
                                                                          dLength_dY1,
                                                                          dLength_dZ1,
                                                                          
                                                                          dLength_dX2,
                                                                          dLength_dY2,
                                                                          dLength_dZ2,
                                                                          
                                                                          dVecX_dX1,
                                                                          dVecX_dY1,
                                                                          dVecX_dZ1,
                                                                                          
                                                                          dVecY_dX1,
                                                                          dVecY_dY1,
                                                                          dVecY_dZ1,
                                                                                         
                                                                          dVecZ_dX1,
                                                                          dVecZ_dY1,
                                                                          dVecZ_dZ1,
                                                                                         
                                                                          dVecX_dX2,
                                                                          dVecX_dY2,
                                                                          dVecX_dZ2,
                                                                                         
                                                                          dVecY_dX2,
                                                                          dVecY_dY2,
                                                                          dVecY_dZ2,
                                                                                         
                                                                          dVecZ_dX2,
                                                                          dVecZ_dY2,
                                                                          dVecZ_dZ2);  
                                                                          
                   vec_out[Eqn1X  ] += pResidual_pCircumference * pCircumference_pLength * dLength_dX1 * vec_in[VortexStretchingRatioEquationNumber];                                                                      
                   vec_out[Eqn1X+1] += pResidual_pCircumference * pCircumference_pLength * dLength_dY1 * vec_in[VortexStretchingRatioEquationNumber];                                                                      
                   vec_out[Eqn1X+2] += pResidual_pCircumference * pCircumference_pLength * dLength_dZ1 * vec_in[VortexStretchingRatioEquationNumber];                                                                      

                   vec_out[Eqn2X  ] += pResidual_pCircumference * pCircumference_pLength * dLength_dX2 * vec_in[VortexStretchingRatioEquationNumber];                                                                      
                   vec_out[Eqn2X+1] += pResidual_pCircumference * pCircumference_pLength * dLength_dY2 * vec_in[VortexStretchingRatioEquationNumber];                                                                      
                   vec_out[Eqn2X+2] += pResidual_pCircumference * pCircumference_pLength * dLength_dZ2 * vec_in[VortexStretchingRatioEquationNumber];                                                                      
                                                                        
                }                                                                      
                
             }
             
             else {
                
                vec_out[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()] = vec_in[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()];
                
             }
             
          }
          
       }          
       
    }  
    
    // Kelvin regularization
    
    if ( NumberOfKelvinConstraints_ > 0 ) {

       // Kelvin regularization
       
       for ( k = 0 ; k <= NumberOfKelvinConstraints_ ; k++ ) {
          
          KelvinGroupSum_[k] = 0.;
          
       }
       
       // Surface vorticity
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
   
          if ( LoopInKelvinConstraintGroup_[i] > 0 ) KelvinGroupSum_[LoopInKelvinConstraintGroup_[i]] += KelvinLambda_ * Vref_ * vec_in[i];
          
       }
 
       // Add in symmetric regularization terms
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
       
          if ( LoopInKelvinConstraintGroup_[i] > 0 ) vec_out[i] += KelvinGroupSum_[LoopInKelvinConstraintGroup_[i]];
       
       }
              
       // Trailing vorticity
       
       //for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       //
       //   for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
       //      
       //      Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
       //      
       //      Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
       //
       //      LoopL = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
       //
       //      LoopR = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();
       //      
       //      for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; j++ ) {
       //         
       //         if ( LoopInKelvinConstraintGroup_[LoopL] == LoopInKelvinConstraintGroup_[j] ) vec_out[LoopL] += KelvinLambda_ * Vref_ * Sign * vec_in[j] ;
       //          
       //         if ( LoopInKelvinConstraintGroup_[LoopR] == LoopInKelvinConstraintGroup_[j] ) vec_out[LoopR] -= KelvinLambda_ * Vref_ * Sign * vec_in[j] ;
       //      
       //      }
       //
       //   }
       //   
       //}

    }
                    
}

/*##############################################################################
#                                                                              #
#       VSP_SOLVER CalculateGammaPerturbationLoopVelocities_Tranpose           #
#                                                                              #
#  [v^t]   [J ][  ][  ][  ]                                                    # 
#  [   ] x [  ][  ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateGammaPerturbationLoopVelocities_Tranpose(double *vec_in, double *vec_out)
{

    int i, j, k, v, Loop, Node, Node1, Node2, iLevel, iLoop, jLevel, jEdge, Edge, Level;
    int LoopType, MaxLoopTypes, NumberOfSheets, *MG_OffSet;
    int i_c, i_f, NodeC, NodeF, ArraySize;
    
    int LoopL, LoopR, LoopC, LoopF;
    double q[3], qs[3], xyz[3], Coef, *GammaT_pR_pGamma, Fact;
    VSP_EDGE *VortexEdge;

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt mesh accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    GammaT_pR_pGamma = new double[ArraySize];
    
    zero_double_array(GammaT_pR_pGamma, ArraySize-1);
          
    // Surface vortex induced velocities 

    MaxLoopTypes = 0;

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:GammaT_pR_pGamma[:ArraySize]) private(iLevel,iLoop,j,jLevel,VortexEdge,q,Coef,LoopL,LoopR,qs,xyz) schedule(dynamic)     
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {

          iLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();
                                                 
          iLoop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          if ( VSPGeom().Grid(iLevel).LoopList(iLoop).SurfaceID() > 0 ) {
             
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
             
                jLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
                
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
                   
                if ( !TimeAccurate_ || VortexEdge->MinValidTimeStep() <= 1 ) {

                   VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c(),q);   
                
                   if ( DoSymmetryPlaneSolve_ ) {
                         
                      xyz[0] =  VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[0];
                      xyz[1] = -VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[1];
                      xyz[2] =  VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[2];
                      
                      VortexEdge->pVelocity_pGamma(xyz,qs);   
                      
                      q[0] += qs[0];
                      q[1] -= qs[1];
                      q[2] += qs[2];
                      
                   }
                               
                   Coef = CalculateGammaPsiAdjointExpansionOverLoops(iLevel, iLoop, q);

                   LoopL = VortexEdge->LoopL();
                   
                   LoopR = VortexEdge->LoopR();
                                                 
                   if ( LoopL > 0 ) GammaT_pR_pGamma[LoopL + MG_OffSet[jLevel]] += VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio() * Coef;
                   
                   if ( LoopR > 0 ) GammaT_pR_pGamma[LoopR + MG_OffSet[jLevel]] -= VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio() * Coef;
                      
                }
                
             }
                          
          }
          
       }
       
    }
    
    // Prolongate
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();
          
          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             GammaT_pR_pGamma[LoopF + MG_OffSet[Level-1]] += Fact * GammaT_pR_pGamma[LoopC + MG_OffSet[Level]];
             
          }
          
       }
       
    }

    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       vec_out[i] += GammaT_pR_pGamma[i + MG_OffSet[MGLevel_]];
       
    }
    
    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] GammaT_pR_pGamma;
    
}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER CalculateMeshPiAdjointExpansionOverLoops             #
#                                                                              #
##############################################################################*/

double VSP_SOLVER::CalculateMeshPiAdjointExpansionOverLoops(int &Level, int &Loop, double q[3])
{
  
   double Coef;
   
   if ( Level == MGLevel_ ) {
      
      Coef = vector_dot(VSPGeom().Grid(Level).LoopList(Loop).Normal(), q);

   }
   
   else {

      int i, LevelF;

      Coef = 0.;

      LevelF = Level - 1;

      for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; i++ ) {
         
         Coef += CalculateMeshPiAdjointExpansionOverLoops(LevelF, VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(i), q);
         
      }
      
   }
   
   return Coef;
      
}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER CalculateMeshPiAdjointExpansionOverLoops             #
#                                                                              #
##############################################################################*/

double VSP_SOLVER::CalculateGammaPsiAdjointExpansionOverLoops(int &Level, int &Loop, double q[3])
{
  
   double Coef;
   
   if ( Level == MGLevel_ ) {
      
     //printf("Normal: %f %f %f --> dGamma: %f \n",
     //VSPGeom().Grid(Level).LoopList(Loop).Normal()[0],
     //VSPGeom().Grid(Level).LoopList(Loop).Normal()[1],
     //VSPGeom().Grid(Level).LoopList(Loop).Normal()[2],
     //VSPGeom().Grid(Level).LoopList(Loop).dGamma());
      Coef = vector_dot(VSPGeom().Grid(Level).LoopList(Loop).Normal(), q) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();

   }
   
   else {

      int i, LevelF;

      Coef = 0.;

      LevelF = Level - 1;

      for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; i++ ) {
         
         Coef += CalculateGammaPsiAdjointExpansionOverLoops(LevelF, VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(i), q);
         
      }
   
   }
   
   return Coef;
      
}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER DistributeAdjointExpansionOverLoops                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DistributeAdjointExpansionOverLoops(int &iLevel, int &iLoop, double &Coef, double *Vec)
{
  
   if ( iLevel == MGLevel_ ) {

      Vec[iLoop] += Coef;
    
   }
   
   else {
      
      int i, LevelC;
      
      LevelC = iLevel - 1;
      
      for ( i = 1 ; i <= VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfFineGridLoops() ; i++ ) {
     
         DistributeAdjointExpansionOverLoops(LevelC, VSPGeom().Grid(iLevel).LoopList(iLoop).FineGridLoop(i), Coef, Vec);
         
      }
      
   }
   
}

/*##############################################################################
#                                                                              #
#      VSP_SOLVER CalculateGammaPerturbationEdgeVelocities_Tranpose            #
#                                                                              #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [v^t] x [J ][  ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [   ]   [  ][  ][  ][  ]                                                    # 
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateGammaPerturbationEdgeVelocities_Tranpose(double *vec_in, double *vec_out)
{
   
    int i, j, k, Edge, MaxLoopTypes, LoopType, iLevel, iEdge, jLevel;
    int ArraySize, *MG_OffSet, LoopL, LoopR, LoopC, LoopF, Level;
    double Coef, q[3], qs[3], xyz[3], *GammaT_pR_pGamma, Fact;
    VSP_EDGE *VortexEdge;

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt gamma accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    GammaT_pR_pGamma = new double[ArraySize];
    
    zero_double_array(GammaT_pR_pGamma, ArraySize-1);
            
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the wake edges

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:GammaT_pR_pGamma[:ArraySize]) private(iLevel,iEdge,j,jLevel,VortexEdge,q,Coef,LoopL,LoopR,qs,xyz) schedule(dynamic)
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
 
          iLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          iEdge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          // Only need to loop over wake edges
          
          if ( VSPGeom().Grid(iLevel).EdgeList(iEdge).SurfaceID() == 0 ) {
             
             // Loop over all edges
          
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
                
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
                
                if ( !TimeAccurate_ || VortexEdge->MinValidTimeStep() <= 1 ) {
               
                   VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c(), q);
                   
                   if ( DoSymmetryPlaneSolve_ ) {
                         
                      xyz[0] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[0];
                      xyz[1] = -VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[1];
                      xyz[2] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[2];
                      
                      VortexEdge->pVelocity_pGamma(xyz,qs);   
                      
                      q[0] += qs[0];
                      q[1] -= qs[1];
                      q[2] += qs[2];
                      
                   }
                                   
                   CalculateAdjointWakeGammaMatrixMultiply(iLevel, iEdge, q, 1., Coef);

//printf("iEdge: %d --> SurfacID: %d --> q: %f %f %f --> Coef: %f \n",iEdge,VortexEdge->SurfaceID(),q[0],q[1],q[2],Coef);fflush(NULL);                              
                      
                   LoopL = VortexEdge->LoopL();
                   
                   LoopR = VortexEdge->LoopR();
                   
                   if ( LoopL > 0 ) GammaT_pR_pGamma[LoopL + MG_OffSet[jLevel]] += VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio() * Coef;
                   
                   if ( LoopR > 0 ) GammaT_pR_pGamma[LoopR + MG_OffSet[jLevel]] -= VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio() * Coef;                   

//printf("VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor(): %f \n",VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor());
//printf("VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor(): %f \n",VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor());
//
//printf("VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio(): %f \n",VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio());
//printf("VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio(): %f \n",VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio());

                }
                
             }
             
          }
  
       }   
       
    }

    // Prolongate gradients
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();

          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             GammaT_pR_pGamma[LoopF + MG_OffSet[Level-1]] += Fact * GammaT_pR_pGamma[LoopC + MG_OffSet[Level]];
             
          }
          
       }
       
    }

    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       vec_out[i] += GammaT_pR_pGamma[i + MG_OffSet[MGLevel_]];
       
    }

    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] GammaT_pR_pGamma;
           
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CalculateAdjointWakeGammaMatrixMultiply          #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateAdjointWakeGammaMatrixMultiply(int LevelC, int EdgeC, double q[3], double Fact, double &Coef) 
{
    
    // On finest level, evalulate forces

    if ( LevelC == MGLevel_  ) {
        
       if ( VSPGeom().Grid(LevelC).EdgeList(EdgeC).IsWakeEdge() && VSPGeom().Grid(LevelC).EdgeList(EdgeC).WakeEdgeData().dS() > 0. ) {
    
          double qq[3][3];

          if ( VSPGeom().Grid(LevelC).EdgeList(EdgeC).WakeEdgeData().Direction() == -1 ) {

             // Node 1
                   
             qq[0][0] = q[0] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[0];
             qq[0][1] = q[1] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[0];
             qq[0][2] = q[2] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[0];
                             
             qq[1][0] = q[0] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[1];
             qq[1][1] = q[1] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[1];
             qq[1][2] = q[2] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[1];
                              
             qq[2][0] = q[0] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[2];
             qq[2][1] = q[1] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[2];
             qq[2][2] = q[2] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ1()[2];
             
             if ( !TimeAccurate_ ) {
                 
                Coef = VSPGeom().Grid(LevelC).EdgeList(EdgeC).WakeTranposeMatrixMultiply(qq);
                
             }
             
             else {
             
                Coef = VSPGeom().Grid(LevelC).EdgeList(EdgeC).UnsteadyWakeTranposeMatrixMultiply(qq,DeltaTime_);
                
             }
                      
          }
          
          else {

             // Node 2
                   
             qq[0][0] = q[0] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[0];
             qq[0][1] = q[1] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[0];
             qq[0][2] = q[2] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[0];
                                                                      
             qq[1][0] = q[0] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[1];
             qq[1][1] = q[1] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[1];
             qq[1][2] = q[2] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[1];
                                                                      
             qq[2][0] = q[0] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[2];
             qq[2][1] = q[1] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[2];
             qq[2][2] = q[2] * Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).dXYZ2()[2];
              
             if ( !TimeAccurate_ ) {
                
                Coef = VSPGeom().Grid(LevelC).EdgeList(EdgeC).WakeTranposeMatrixMultiply(qq);
                
             }
             
             else {
             
                Coef = VSPGeom().Grid(LevelC).EdgeList(EdgeC).UnsteadyWakeTranposeMatrixMultiply(qq,DeltaTime_);
                
             }                
                
          }
             
       }
       
       else {
          
          Coef = 0.;
          
       }
                
    }
    
    // Prolongate over edges
    
    else {
       
       int j, Edge;
       
       double dCoef, NewFact;

       // Loop over adjoint edges...
       
       Coef = 0.;
                 
       for ( j = 1 ; j <= VSPGeom().Grid(LevelC).EdgeList(EdgeC).NumberOfAdjointEdges() ; j++ ) {
          
          Edge = ABS(VSPGeom().Grid(LevelC).EdgeList(EdgeC).AdjointEdgeList(j));

          NewFact = Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).AdjointEdgeFactor(j);
         
          CalculateAdjointWakeGammaMatrixMultiply(LevelC - 1, Edge, q, NewFact, dCoef);

          Coef += dCoef;

       }

    }
            
}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER CalculateAdjointExpansionOverEdges                  #
#                                                                              #
##############################################################################*/

double VSP_SOLVER::CalculateAdjointExpansionOverEdges(int &Level, int &Loop, double q[3][3])
{

   double Coef;
   
   if ( Level == MGLevel_ ) {
   
      int j, Edge;
      double Fact;
      
      Coef = 0.;
      
      for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfEdges() ; j++ ) {
         
         Edge =  VSPGeom().Grid(Level).LoopList(Loop).Edge(j);
      
         if ( VSPGeom().Grid(Level).EdgeList(Edge).IsWakeEdge() && VSPGeom().Grid(Level).EdgeList(Edge).WakeEdgeData().dS() > 0. ) {

            Fact = 0.5;
            
            if ( VSPGeom().Grid(Level).EdgeList(Edge).LoopL() == 0 ||
                 VSPGeom().Grid(Level).EdgeList(Edge).LoopR() == 0 ) Fact = 1.;
                   
            Coef += Fact*VSPGeom().Grid(Level).EdgeList(Edge).WakeTranposeMatrixMultiply(q);
                   
         }
         
      }
         
   }
   
   else {

      int j, LevelF, LoopF;
      
      Coef = 0.;
      
      LevelF = Level - 1;
      
      for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; j++ ) {
       
         LoopF = VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(j);
      
         Coef += CalculateAdjointExpansionOverEdges(LevelF, LoopF, q);
                                  
      }  
      
   }
   
   return Coef;
  
}

/*##############################################################################
#                                                                              #
#    VSP_SOLVER CalculateMeshPerturbationEdgeVelocitiesOverLoops_Tranpose      #
#                                                                              #
#  [v^t]   [  ][J ][  ][  ]                                                    # 
#  [   ] x [  ][  ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateMeshPerturbationEdgeVelocitiesOverLoops_Tranpose(double *vec_in, double *vec_out)
{

    int i, j, k, i1, i2, MaxLoopTypes, LoopType, Level, Loop, jLevel;
    double Coef[9], xyz[3];
    
    double dq0_dx1;
    double dq0_dy1;
    double dq0_dz1;
    double dq0_dx2;
    double dq0_dy2;
    double dq0_dz2;
                          
    double dq1_dx1;
    double dq1_dy1;
    double dq1_dz1;
    double dq1_dx2;
    double dq1_dy2;
    double dq1_dz2;
                          
    double dq2_dx1;
    double dq2_dy1;
    double dq2_dz1;
    double dq2_dx2;
    double dq2_dy2;
    double dq2_dz2;

    double dq0_dxp;
    double dq0_dyp;
    double dq0_dzp;
                          
    double dq1_dxp;
    double dq1_dyp;
    double dq1_dzp;
                          
    double dq2_dxp;
    double dq2_dyp;
    double dq2_dzp;   

    double dq0_dMach;
    double dq1_dMach;
    double dq2_dMach;   
     
    // Symmetry
    
    double dq0_dx1_s;
    double dq0_dy1_s;
    double dq0_dz1_s;
    double dq0_dx2_s;
    double dq0_dy2_s;
    double dq0_dz2_s;
                        
    double dq1_dx1_s;
    double dq1_dy1_s;
    double dq1_dz1_s;
    double dq1_dx2_s;
    double dq1_dy2_s;
    double dq1_dz2_s;
                          
    double dq2_dx1_s;
    double dq2_dy1_s;
    double dq2_dz1_s;
    double dq2_dx2_s;
    double dq2_dy2_s;
    double dq2_dz2_s;
                         
    double dq0_dxp_s;
    double dq0_dyp_s;
    double dq0_dzp_s;
                          
    double dq1_dxp_s;
    double dq1_dyp_s;
    double dq1_dzp_s;
                         
    double dq2_dxp_s;
    double dq2_dyp_s;
    double dq2_dzp_s;   

    double dq0_dMach_s;
    double dq1_dMach_s;
    double dq2_dMach_s;   
                                                     
    VSP_EDGE *VortexEdge;
    
    MaxLoopTypes = 0;
 
    // Mesh perturbation induced gamma perturbation velocities across surface loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:vec_out[:NumberOfEquations_+1]) private(Level,Loop,j,k,jLevel,VortexEdge,Coef,i1,i2,\
                                                                             dq0_dx1,\
                                                                             dq0_dy1,\
                                                                             dq0_dz1,\
                                                                             dq0_dx2,\
                                                                             dq0_dy2,\
                                                                             dq0_dz2,\
                                                                             dq1_dx1,\
                                                                             dq1_dy1,\
                                                                             dq1_dz1,\
                                                                             dq1_dx2,\
                                                                             dq1_dy2,\
                                                                             dq1_dz2,\
                                                                             dq2_dx1,\
                                                                             dq2_dy1,\
                                                                             dq2_dz1,\
                                                                             dq2_dx2,\
                                                                             dq2_dy2,\
                                                                             dq2_dz2,\
                                                                             dq0_dxp,\
                                                                             dq0_dyp,\
                                                                             dq0_dzp,\
                                                                             dq1_dxp,\
                                                                             dq1_dyp,\
                                                                             dq1_dzp,\
                                                                             dq2_dxp,\
                                                                             dq2_dyp,\
                                                                             dq2_dzp,\
                                                                             dq0_dMach,\
                                                                             dq1_dMach,\
                                                                             dq2_dMach,\
                                                                             dq0_dx1_s,\
                                                                             dq0_dy1_s,\
                                                                             dq0_dz1_s,\
                                                                             dq0_dx2_s,\
                                                                             dq0_dy2_s,\
                                                                             dq0_dz2_s,\
                                                                             dq1_dx1_s,\
                                                                             dq1_dy1_s,\
                                                                             dq1_dz1_s,\
                                                                             dq1_dx2_s,\
                                                                             dq1_dy2_s,\
                                                                             dq1_dz2_s,\
                                                                             dq2_dx1_s,\
                                                                             dq2_dy1_s,\
                                                                             dq2_dz1_s,\
                                                                             dq2_dx2_s,\
                                                                             dq2_dy2_s,\
                                                                             dq2_dz2_s,\
                                                                             dq0_dxp_s,\
                                                                             dq0_dyp_s,\
                                                                             dq0_dzp_s,\
                                                                             dq1_dxp_s,\
                                                                             dq1_dyp_s,\
                                                                             dq1_dzp_s,\
                                                                             dq2_dxp_s,\
                                                                             dq2_dyp_s,\
                                                                             dq2_dzp_s,\
                                                                             dq0_dMach_s,\
                                                                             dq1_dMach_s,\
                                                                             dq2_dMach_s,\
                                                                             xyz) schedule(dynamic)
#endif
#endif
                                                                             
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {
 
          Level = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();

          Loop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          // Only need to calculate perturbations on surface loops

          if ( VSPGeom().Grid(Level).LoopList(Loop).SurfaceID() > 0 ) {
   
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
      
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                // Only loop over the wakes edges
                
                if ( VortexEdge->SurfaceID() == 0 ) {

                   // Calculate gamma perturbation influence of this edge
        
                   VortexEdge->dInducedVelocity_dMesh_Transpose(VSPGeom().Grid(Level).LoopList(Loop).xyz_c(), 
                                                                dq0_dx1,
                                                                dq0_dy1,
                                                                dq0_dz1,
                                                                dq0_dx2,
                                                                dq0_dy2,
                                                                dq0_dz2,
                                                                       
                                                                dq1_dx1,
                                                                dq1_dy1,
                                                                dq1_dz1,
                                                                dq1_dx2,
                                                                dq1_dy2,
                                                                dq1_dz2,
                                                                       
                                                                dq2_dx1,
                                                                dq2_dy1,
                                                                dq2_dz1,
                                                                dq2_dx2,
                                                                dq2_dy2,
                                                                dq2_dz2,
                                                                
                                                                dq0_dxp,
                                                                dq0_dyp,
                                                                dq0_dzp,
                                                                   
                                                                dq1_dxp,
                                                                dq1_dyp,
                                                                dq1_dzp,
                                                                     
                                                                dq2_dxp,
                                                                dq2_dyp,
                                                                dq2_dzp,

                                                                dq0_dMach,
                                                                dq1_dMach,
                                                                dq2_dMach);                                               
                                                           
                   if ( DoSymmetryPlaneSolve_ ) {
                      
                      xyz[0] =  VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                      xyz[1] = -VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                      xyz[2] =  VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
                      
                      VortexEdge->dInducedVelocity_dMesh_Transpose(xyz, 
                                                                   dq0_dx1_s,
                                                                   dq0_dy1_s,
                                                                   dq0_dz1_s,
                                                                   dq0_dx2_s,
                                                                   dq0_dy2_s,
                                                                   dq0_dz2_s,
                                                                         
                                                                   dq1_dx1_s,
                                                                   dq1_dy1_s,
                                                                   dq1_dz1_s,
                                                                   dq1_dx2_s,
                                                                   dq1_dy2_s,
                                                                   dq1_dz2_s,
                                                                         
                                                                   dq2_dx1_s,
                                                                   dq2_dy1_s,
                                                                   dq2_dz1_s,
                                                                   dq2_dx2_s,
                                                                   dq2_dy2_s,
                                                                   dq2_dz2_s,
                                                                        
                                                                   dq0_dxp_s,
                                                                   dq0_dyp_s,
                                                                   dq0_dzp_s,
                                                                        
                                                                   dq1_dxp_s,
                                                                   dq1_dyp_s,
                                                                   dq1_dzp_s,
                                                                       
                                                                   dq2_dxp_s,
                                                                   dq2_dyp_s,
                                                                   dq2_dzp_s,
                      
                                                                   dq0_dMach_s,
                                                                   dq1_dMach_s,
                                                                   dq2_dMach_s);              

                      dq0_dx1 += dq0_dx1_s;
                      dq0_dy1 += dq0_dy1_s;
                      dq0_dz1 += dq0_dz1_s;
                      dq0_dx2 += dq0_dx2_s;
                      dq0_dy2 += dq0_dy2_s;
                      dq0_dz2 += dq0_dz2_s; 
                                       
                      dq1_dx1 -= dq1_dx1_s;
                      dq1_dy1 -= dq1_dy1_s;
                      dq1_dz1 -= dq1_dz1_s;
                      dq1_dx2 -= dq1_dx2_s;
                      dq1_dy2 -= dq1_dy2_s;
                      dq1_dz2 -= dq1_dz2_s;
                                       
                      dq2_dx1 += dq2_dx1_s;
                      dq2_dy1 += dq2_dy1_s;
                      dq2_dz1 += dq2_dz1_s;
                      dq2_dx2 += dq2_dx2_s;
                      dq2_dy2 += dq2_dy2_s;
                      dq2_dz2 += dq2_dz2_s;
                                    
                      dq0_dxp += dq0_dxp_s;
                      dq0_dyp += dq0_dyp_s;
                      dq0_dzp += dq0_dzp_s;
                                      
                      dq1_dxp -= dq1_dxp_s;
                      dq1_dyp -= dq1_dyp_s;
                      dq1_dzp -= dq1_dzp_s;
                                        
                      dq2_dxp += dq2_dxp_s;
                      dq2_dyp += dq2_dyp_s;
                      dq2_dzp += dq2_dzp_s;
                      
                      dq0_dMach += dq0_dMach_s;
                      dq1_dMach -= dq1_dMach_s;
                      dq2_dMach += dq2_dMach_s; 
  
                   }
                                                                                                                                                                                                                      
                   // Calculate coefficients

                   CalculateMeshAdjointExpansionOverLoops(Level, Loop, 
                                                          dq0_dx1,
                                                          dq0_dy1,
                                                          dq0_dz1,
                                                          dq0_dx2,
                                                          dq0_dy2,
                                                          dq0_dz2,
                                                                 
                                                          dq1_dx1,
                                                          dq1_dy1,
                                                          dq1_dz1,
                                                          dq1_dx2,
                                                          dq1_dy2,
                                                          dq1_dz2,
                                                                 
                                                          dq2_dx1,
                                                          dq2_dy1,
                                                          dq2_dz1,
                                                          dq2_dx2,
                                                          dq2_dy2,
                                                          dq2_dz2,
                                                          
                                                          dq0_dxp,
                                                          dq0_dyp,
                                                          dq0_dzp,
                                                             
                                                          dq1_dxp,
                                                          dq1_dyp,
                                                          dq1_dzp,
                                                                
                                                          dq2_dxp,
                                                          dq2_dyp,
                                                          dq2_dzp,
                                                          
                                                          dq0_dMach,
                                                          dq1_dMach,
                                                          dq2_dMach,  
                                                                                                                         
                                                          Coef);     
    
                   // Distribute edge delta xyz's                         

//printf("Coefs: %f %f %f %f %f %f \n",
//Coef[0],
//Coef[1],
//Coef[2],
//Coef[3],
//Coef[4],
//Coef[5]);


                   DistributeAdjointExpansionOverNodes(jLevel, VortexEdge->Node1(), &Coef[0], vec_out);
                   
                   DistributeAdjointExpansionOverNodes(jLevel, VortexEdge->Node2(), &Coef[3], vec_out);
       
                }

             }
           
          }

       }   
       
    }    
    
}

/*##############################################################################
#                                                                              #
#       VSP_SOLVER CalculateKstallPerturbationLoopVelocities_Tranpose          #
#                                                                              #
#  [v^t]   [  ][  ][J ][  ]                                                    # 
#  [   ] x [  ][  ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [   ]   [  ][  ][  ][  ]                                                    # 
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateKstallPerturbationLoopVelocities_Tranpose(double *vec_in, double *vec_out)
{

    int i, j, k, v, Loop, Node, Node1, Node2, iLevel, iLoop, jLevel, jEdge, Edge, Level;
    int LoopType, MaxLoopTypes, NumberOfSheets, *MG_OffSet;
    int i_c, i_f, NodeC, NodeF, ArraySize;
    
    int LoopL, LoopR, LoopC, LoopF;
    double q[3], qs[3], xyz[3], Coef, *GammaT_pR_pStall, Fact;
    VSP_EDGE *VortexEdge;

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt mesh accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    GammaT_pR_pStall = new double[ArraySize];
    
    zero_double_array(GammaT_pR_pStall, ArraySize-1);
          
    // Surface vortex induced velocities 

    MaxLoopTypes = 0;

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:GammaT_pR_pStall[:ArraySize]) private(iLevel,iLoop,j,jLevel,VortexEdge,q,Coef,LoopL,LoopR,xyz,qs) schedule(dynamic)     
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {

          iLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();
                                                 
          iLoop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          if ( VSPGeom().Grid(iLevel).LoopList(iLoop).SurfaceID() > 0 ) {
             
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
             
                jLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
                
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
 
                VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c(),q);   

                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] =  VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[2];
                   
                   VortexEdge->pVelocity_pGamma(xyz,qs);  
                   
                   q[0] += qs[0]; 
                   q[1] -= qs[1]; 
                   q[2] += qs[2]; 
                   
                }
                
                if ( VortexEdge->SurfaceID() == 0 ) {
                               
                   Coef = CalculateGammaPsiAdjointExpansionOverLoops(iLevel, iLoop, q);
                              
                   LoopL = VortexEdge->LoopL();
                   
                   LoopR = VortexEdge->LoopR();
                                                 
                   if ( LoopL > 0 ) GammaT_pR_pStall[LoopL + MG_OffSet[jLevel]] += Coef * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                   
                   if ( LoopR > 0 ) GammaT_pR_pStall[LoopR + MG_OffSet[jLevel]] -= Coef * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                   
                }                   
                   
             }
                          
          }
          
       }
       
    }
    
    // Prolongate
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();
          
          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             GammaT_pR_pStall[LoopF + MG_OffSet[Level-1]] += Fact * GammaT_pR_pStall[LoopC + MG_OffSet[Level]];
             
          }
          
       }
       
    }

    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       vec_out[i] += GammaT_pR_pStall[i + MG_OffSet[MGLevel_]];
       
    }
    
    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] GammaT_pR_pStall;
    
}

/*##############################################################################
#                                                                              #
#      VSP_SOLVER CalculateKstallPerturbationEdgeVelocities_Tranpose           #
#                                                                              #
#  [v^t]   [  ][  ][J ][  ]                                                    # 
#  [   ] x [  ][  ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [   ]   [  ][  ][  ][  ]                                                    # 
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateKstallPerturbationEdgeVelocities_Tranpose(double *vec_in, double *vec_out)
{
   
    int i, j, k, Edge, MaxLoopTypes, LoopType, iLevel, iEdge, jLevel;
    int ArraySize, *MG_OffSet, LoopL, LoopR, LoopC, LoopF, Level;
    double Coef, q[3], qs[3], xyz[3], *GammaT_pR_pStall, Fact;
    VSP_EDGE *VortexEdge;

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt gamma accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    GammaT_pR_pStall = new double[ArraySize];
    
    zero_double_array(GammaT_pR_pStall, ArraySize-1);
            
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:GammaT_pR_pStall[:ArraySize]) private(iLevel,iEdge,j,jLevel,VortexEdge,q,Coef,LoopL,LoopR,xyz,qs) schedule(dynamic)
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
 
          iLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          iEdge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          // Only need to loop over wake edges
          
          if ( VSPGeom().Grid(iLevel).EdgeList(iEdge).SurfaceID() == 0 ) {
             
             // Loop over all edges
          
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
                
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                if ( VortexEdge->SurfaceID() == 0 ) {
               
                   VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c(), q);

                   if ( DoSymmetryPlaneSolve_ ) {
                      
                      xyz[0] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[0];
                      xyz[1] = -VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[1];
                      xyz[2] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[2];
                      
                      VortexEdge->pVelocity_pGamma(xyz,qs);  
                      
                      q[0] += qs[0]; 
                      q[1] -= qs[1]; 
                      q[2] += qs[2]; 
                      
                   }
                                   
                   CalculateAdjointWakeGammaMatrixMultiply(iLevel, iEdge, q, 1., Coef);
                      
                   LoopL = VortexEdge->LoopL();
                   
                   LoopR = VortexEdge->LoopR();
       
                   if ( LoopL > 0 ) GammaT_pR_pStall[LoopL + MG_OffSet[jLevel]] += Coef * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                   
                   if ( LoopR > 0 ) GammaT_pR_pStall[LoopR + MG_OffSet[jLevel]] -= Coef * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();        
                   
                }           

             }
             
          }
  
       }   
       
    }

    // Prolongate gradients
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();

          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             GammaT_pR_pStall[LoopF + MG_OffSet[Level-1]] += Fact * GammaT_pR_pStall[LoopC + MG_OffSet[Level]];
             
          }
          
       }
       
    }

    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       vec_out[i] += GammaT_pR_pStall[i + MG_OffSet[MGLevel_]];
       
    }
    
    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] GammaT_pR_pStall;
           
}

/*##############################################################################
#                                                                              #
# VSP_SOLVER CalculateVortexStretchingRatioPerturbationLoopVelocities_Tranpose #
#                                                                              #
#  [v^t]   [  ][  ][  ][J ]                                                    # 
#  [   ] x [  ][  ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [   ]   [  ][  ][  ][  ]                                                    # 
#                                                                              #
##############################################################################*/
               
void VSP_SOLVER::CalculateVortexStretchingRatioPerturbationLoopVelocities_Tranpose(double *vec_in, double *vec_out)
{

    int i, j, k, v, Loop, Node, Node1, Node2, iLevel, iLoop, jLevel, jEdge, Edge, Level;
    int LoopType, MaxLoopTypes, NumberOfSheets, *MG_OffSet;
    int i_c, i_f, NodeC, NodeF, ArraySize;
    
    int LoopL, LoopR, LoopC, LoopF;
    double q[3], qs[3], xyz[3], Coef, *GammaT_pR_pRatio, Fact;
    VSP_EDGE *VortexEdge;

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt mesh accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    GammaT_pR_pRatio = new double[ArraySize];
    
    zero_double_array(GammaT_pR_pRatio, ArraySize-1);
          
    // Surface vortex induced velocities 

    MaxLoopTypes = 0;

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:GammaT_pR_pRatio[:ArraySize]) private(iLevel,iLoop,j,jLevel,VortexEdge,q,Coef,LoopL,LoopR,xyz,qs) schedule(dynamic)     
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {

          iLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();
                                                 
          iLoop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          if ( VSPGeom().Grid(iLevel).LoopList(iLoop).SurfaceID() > 0 ) {
             
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
             
                jLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
                
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
 
                VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c(),q);   

                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] =  VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[2];
                   
                   VortexEdge->pVelocity_pGamma(xyz,qs);  
                   
                   q[0] += qs[0]; 
                   q[1] -= qs[1]; 
                   q[2] += qs[2]; 
                   
                }
                
                if ( VortexEdge->SurfaceID() == 0 ) {
                               
                   Coef = CalculateGammaPsiAdjointExpansionOverLoops(iLevel, iLoop, q);
                              
                   LoopL = VortexEdge->LoopL();
                   
                   LoopR = VortexEdge->LoopR();
                                                 
                   if ( LoopL > 0 ) GammaT_pR_pRatio[LoopL + MG_OffSet[jLevel]] += Coef * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor();
                   
                   if ( LoopR > 0 ) GammaT_pR_pRatio[LoopR + MG_OffSet[jLevel]] -= Coef * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor();
                   
                }                   
                   
             }
                          
          }
          
       }
       
    }
    
    // Prolongate
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();
          
          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             GammaT_pR_pRatio[LoopF + MG_OffSet[Level-1]] += Fact * GammaT_pR_pRatio[LoopC + MG_OffSet[Level]];
             
          }
          
       }
       
    }

    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       vec_out[i] += GammaT_pR_pRatio[i + MG_OffSet[MGLevel_]];
       
    }
    
    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] GammaT_pR_pRatio;
    
}

/*##############################################################################
#                                                                              #
# VSP_SOLVER CalculateVortexStretchingRatioPerturbationEdgeVelocities_Tranpose #
#                                                                              #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [v^t] x [  ][  ][J ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [   ]   [  ][  ][  ][  ]                                                    # 
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateVortexStretchingRatioPerturbationEdgeVelocities_Tranpose(double *vec_in, double *vec_out)
{
   
    int i, j, k, Edge, MaxLoopTypes, LoopType, iLevel, iEdge, jLevel;
    int ArraySize, *MG_OffSet, LoopL, LoopR, LoopC, LoopF, Level;
    double Coef, q[3], qs[3], xyz[3], *GammaT_pR_pRatio, Fact;
    VSP_EDGE *VortexEdge;

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt gamma accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    GammaT_pR_pRatio = new double[ArraySize];
    
    zero_double_array(GammaT_pR_pRatio, ArraySize-1);
            
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:GammaT_pR_pRatio[:ArraySize]) private(iLevel,iEdge,j,jLevel,VortexEdge,q,Coef,LoopL,LoopR,xyz,qs) schedule(dynamic)
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
 
          iLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          iEdge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          // Only need to loop over wake edges
          
          if ( VSPGeom().Grid(iLevel).EdgeList(iEdge).SurfaceID() == 0 ) {
             
             // Loop over all edges
          
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
                
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                if ( VortexEdge->SurfaceID() == 0 ) {
               
                   VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c(), q);

                   if ( DoSymmetryPlaneSolve_ ) {
                      
                      xyz[0] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[0];
                      xyz[1] = -VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[1];
                      xyz[2] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[2];
                      
                      VortexEdge->pVelocity_pGamma(xyz,qs);  
                      
                      q[0] += qs[0]; 
                      q[1] -= qs[1]; 
                      q[2] += qs[2]; 
                      
                   }
                                   
                   CalculateAdjointWakeGammaMatrixMultiply(iLevel, iEdge, q, 1., Coef);
                      
                   LoopL = VortexEdge->LoopL();
                   
                   LoopR = VortexEdge->LoopR();
       
                   if ( LoopL > 0 ) GammaT_pR_pRatio[LoopL + MG_OffSet[jLevel]] += Coef * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor();
                   
                   if ( LoopR > 0 ) GammaT_pR_pRatio[LoopR + MG_OffSet[jLevel]] -= Coef * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor();        
                   
                }           

             }
             
          }
  
       }   
       
    }

    // Prolongate gradients
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();

          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             GammaT_pR_pRatio[LoopF + MG_OffSet[Level-1]] += Fact * GammaT_pR_pRatio[LoopC + MG_OffSet[Level]];
             
          }
          
       }
       
    }

    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       vec_out[i] += GammaT_pR_pRatio[i + MG_OffSet[MGLevel_]];
       
    }
    
    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] GammaT_pR_pRatio;
           
}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER CalculateMeshAdjointExpansionOverLoops              #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateMeshAdjointExpansionOverLoops(int &Level, int &Loop,
                                                        double &dq0_dx1,
                                                        double &dq0_dy1,
                                                        double &dq0_dz1,
                                                        double &dq0_dx2,
                                                        double &dq0_dy2,
                                                        double &dq0_dz2,
                                                                    
                                                        double &dq1_dx1,
                                                        double &dq1_dy1,
                                                        double &dq1_dz1,
                                                        double &dq1_dx2,
                                                        double &dq1_dy2,
                                                        double &dq1_dz2,
                                                                   
                                                        double &dq2_dx1,
                                                        double &dq2_dy1,
                                                        double &dq2_dz1,
                                                        double &dq2_dx2,
                                                        double &dq2_dy2,
                                                        double &dq2_dz2,
                                                        
                                                        double &dq0_dxp,
                                                        double &dq0_dyp,
                                                        double &dq0_dzp,
                                                           
                                                        double &dq1_dxp,
                                                        double &dq1_dyp,
                                                        double &dq1_dzp,
                                                              
                                                        double &dq2_dxp,
                                                        double &dq2_dyp,
                                                        double &dq2_dzp, 
                                                        
                                                        double &dq0_dMach,
                                                        double &dq1_dMach,
                                                        double &dq2_dMach,
                                                                                                                   
                                                        double Coef[9]) 
{
     
   if ( Level == MGLevel_ ) {
  
      // Edge node xyz perturbations
      
      Coef[0] = ( dq0_dx1 * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dx1 * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dx1 * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();
           
      Coef[1] = ( dq0_dy1 * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dy1 * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dy1 * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();
      
      Coef[2] = ( dq0_dz1 * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dz1 * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dz1 * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();
      
      Coef[3] = ( dq0_dx2 * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dx2 * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dx2 * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();
           
      Coef[4] = ( dq0_dy2 * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dy2 * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dy2 * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();
      
      Coef[5] = ( dq0_dz2 * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dz2 * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dz2 * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();

      // xyzp (centroid) perturbation
      
      Coef[6] = ( dq0_dxp * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dxp * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dxp * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();    
                
      Coef[7] = ( dq0_dyp * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dyp * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dyp * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();      
                
      Coef[8] = ( dq0_dzp * VSPGeom().Grid(Level).LoopList(Loop).Nx()
                + dq1_dzp * VSPGeom().Grid(Level).LoopList(Loop).Ny()
                + dq2_dzp * VSPGeom().Grid(Level).LoopList(Loop).Nz()
                ) * VSPGeom().Grid(Level).LoopList(Loop).dGamma();      
                                                  
   }
   
   else {

      double dCoef[9];
      
      int i, LevelF;

      Coef[0] = 0.;
      Coef[1] = 0.;
      Coef[2] = 0.;
      Coef[3] = 0.;
      Coef[4] = 0.;
      Coef[5] = 0.;
      Coef[6] = 0.;
      Coef[7] = 0.;
      Coef[8] = 0.;
                   
      LevelF = Level - 1;

      for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; i++ ) {
         
         CalculateMeshAdjointExpansionOverLoops(LevelF, VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(i),
                                                dq0_dx1,
                                                dq0_dy1,
                                                dq0_dz1,
                                                dq0_dx2,
                                                dq0_dy2,
                                                dq0_dz2,
                                                       
                                                dq1_dx1,
                                                dq1_dy1,
                                                dq1_dz1,
                                                dq1_dx2,
                                                dq1_dy2,
                                                dq1_dz2,
                                                       
                                                dq2_dx1,
                                                dq2_dy1,
                                                dq2_dz1,
                                                dq2_dx2,
                                                dq2_dy2,
                                                dq2_dz2,
                                                
                                                dq0_dxp,
                                                dq0_dyp,
                                                dq0_dzp,
                                                
                                                dq1_dxp,
                                                dq1_dyp,
                                                dq1_dzp,
                                                
                                                dq2_dxp,
                                                dq2_dyp,
                                                dq2_dzp,
                                                
                                                dq0_dMach,
                                                dq1_dMach,
                                                dq2_dMach,    
                                                                                            
                                                dCoef);


         Coef[0] += dCoef[0];
         Coef[1] += dCoef[1];
         Coef[2] += dCoef[2];
         Coef[3] += dCoef[3];
         Coef[4] += dCoef[4];
         Coef[5] += dCoef[5];    
         Coef[6] += dCoef[6];    
         Coef[7] += dCoef[7];    
         Coef[8] += dCoef[8];    
                       
      }
      
   }

}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER DistributeAdjointExpansionOverNodes                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DistributeAdjointExpansionOverNodes(int &Level, int &Node, double Coef[3], double *Vec)
{
  
   if ( Level == MGLevel_ ) {

      int i, j, i1;
      
      i1 = Node - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
      
   //   if ( 1||!VSPGeom().Grid(Level).NodeList(Node).IsWakeTrailingEdgeNode() ) {
      
         Vec[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*i1 - 2] += Coef[0];
         Vec[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*i1 - 1] += Coef[1];
         Vec[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*i1    ] += Coef[2];
         
   //   }

   }
   
   else {
      
      int LevelF, NodeF;

      LevelF = Level - 1;

      NodeF = VSPGeom().Grid(Level).NodeList(Node).FineGridNode();
 
      DistributeAdjointExpansionOverNodes(LevelF, NodeF, Coef, Vec);
    
   }
   
}

/*##############################################################################
#                                                                              #
#    VSP_SOLVER CalculateMeshPerturbationEdgeVelocitiesOverEdges_Tranpose      #
#                                                                              #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [v^t] x [  ][J ][  ][  ]                                                    #
#  [   ]   [  ][  ][  ][  ]                                                    # 
#  [   ]   [  ][  ][  ][  ]                                                    # 
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateMeshPerturbationEdgeVelocitiesOverEdges_Tranpose(double *vec_in, double *vec_out)
{

    int i, j, Level, MaxLoopTypes, LoopType, iLevel, iEdge, jLevel, *MG_OffSet, ArraySize;
    int Node1, Node2, NodeC, NodeF;
    double q[3], Coef[9], xyz[3], *GammaT_pR_pMesh;
    
    double dq0_dx1;
    double dq0_dy1;
    double dq0_dz1;
    double dq0_dx2;
    double dq0_dy2;
    double dq0_dz2;
                         
    double dq1_dx1;
    double dq1_dy1;
    double dq1_dz1;
    double dq1_dx2;
    double dq1_dy2;
    double dq1_dz2;
                         
    double dq2_dx1;
    double dq2_dy1;
    double dq2_dz1;
    double dq2_dx2;
    double dq2_dy2;
    double dq2_dz2; 
    
    double dq0_dxp;
    double dq0_dyp;
    double dq0_dzp;
                          
    double dq1_dxp;
    double dq1_dyp;
    double dq1_dzp;
                          
    double dq2_dxp;
    double dq2_dyp;
    double dq2_dzp;                                               
    
    double dq0_dMach;
    double dq1_dMach;
    double dq2_dMach;

    // Symmetry
    
    double dq0_dx1_s;
    double dq0_dy1_s;
    double dq0_dz1_s;
    double dq0_dx2_s;
    double dq0_dy2_s;
    double dq0_dz2_s;
                        
    double dq1_dx1_s;
    double dq1_dy1_s;
    double dq1_dz1_s;
    double dq1_dx2_s;
    double dq1_dy2_s;
    double dq1_dz2_s;
                          
    double dq2_dx1_s;
    double dq2_dy1_s;
    double dq2_dz1_s;
    double dq2_dx2_s;
    double dq2_dy2_s;
    double dq2_dz2_s; 
                         
    double dq0_dxp_s;
    double dq0_dyp_s;
    double dq0_dzp_s;
                        
    double dq1_dxp_s;
    double dq1_dyp_s;
    double dq1_dzp_s;
                        
    double dq2_dxp_s;
    double dq2_dyp_s;
    double dq2_dzp_s;                                               
    
    double dq0_dMach_s;
    double dq1_dMach_s;
    double dq2_dMach_s;
            
    VSP_EDGE *VortexEdge;

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + 3*VSPGeom().Grid(i-1).NumberOfNodes();
       
    }
    
    // Partial wrt mesh accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    GammaT_pR_pMesh = new double[ArraySize];
    
    zero_double_array(GammaT_pR_pMesh, ArraySize-1);
    
    MaxLoopTypes = 0;

    // Mesh perturbation induced gamma perturbation velocities across wake loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:GammaT_pR_pMesh[:ArraySize]) private(iLevel,iEdge,j,jLevel,VortexEdge,\
                                                                                                   dq0_dx1,\
                                                                                                   dq0_dy1,\
                                                                                                   dq0_dz1,\
                                                                                                   dq0_dx2,\
                                                                                                   dq0_dy2,\
                                                                                                   dq0_dz2,\
                                                                                                   dq1_dx1,\
                                                                                                   dq1_dy1,\
                                                                                                   dq1_dz1,\
                                                                                                   dq1_dx2,\
                                                                                                   dq1_dy2,\
                                                                                                   dq1_dz2,\
                                                                                                   dq2_dx1,\
                                                                                                   dq2_dy1,\
                                                                                                   dq2_dz1,\
                                                                                                   dq2_dx2,\
                                                                                                   dq2_dy2,\
                                                                                                   dq2_dz2,\
                                                                                                   dq0_dxp,\
                                                                                                   dq0_dyp,\
                                                                                                   dq0_dzp,\
                                                                                                   dq1_dxp,\
                                                                                                   dq1_dyp,\
                                                                                                   dq1_dzp,\
                                                                                                   dq2_dxp,\
                                                                                                   dq2_dyp,\
                                                                                                   dq2_dzp,\
                                                                                                   dq0_dMach,\
                                                                                                   dq1_dMach,\
                                                                                                   dq2_dMach,\
                                                                                                   dq0_dx1_s,\
                                                                                                   dq0_dy1_s,\
                                                                                                   dq0_dz1_s,\
                                                                                                   dq0_dx2_s,\
                                                                                                   dq0_dy2_s,\
                                                                                                   dq0_dz2_s,\
                                                                                                   dq1_dx1_s,\
                                                                                                   dq1_dy1_s,\
                                                                                                   dq1_dz1_s,\
                                                                                                   dq1_dx2_s,\
                                                                                                   dq1_dy2_s,\
                                                                                                   dq1_dz2_s,\
                                                                                                   dq2_dx1_s,\
                                                                                                   dq2_dy1_s,\
                                                                                                   dq2_dz1_s,\
                                                                                                   dq2_dx2_s,\
                                                                                                   dq2_dy2_s,\
                                                                                                   dq2_dz2_s,\
                                                                                                   dq0_dxp_s,\
                                                                                                   dq0_dyp_s,\
                                                                                                   dq0_dzp_s,\
                                                                                                   dq1_dxp_s,\
                                                                                                   dq1_dyp_s,\
                                                                                                   dq1_dzp_s,\
                                                                                                   dq2_dxp_s,\
                                                                                                   dq2_dyp_s,\
                                                                                                   dq2_dzp_s,\
                                                                                                   dq0_dMach_s,\
                                                                                                   dq1_dMach_s,\
                                                                                                   dq2_dMach_s,\
                                                                                                   xyz, Coef, Node1, Node2) schedule(dynamic)
#endif
#endif
                                                                                   
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
   
          iLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          iEdge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          // Only need to calculate perturbation wrt to mesh on wakes

          if ( VSPGeom().Grid(iLevel).EdgeList(iEdge).SurfaceID() == 0 ) {
   
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
      
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                VortexEdge->dInducedVelocity_dMesh_Transpose(VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c(), 
                                                             dq0_dx1,
                                                             dq0_dy1,
                                                             dq0_dz1,
                                                             dq0_dx2,
                                                             dq0_dy2,
                                                             dq0_dz2,
                                                             
                                                             dq1_dx1,
                                                             dq1_dy1,
                                                             dq1_dz1,
                                                             dq1_dx2,
                                                             dq1_dy2,
                                                             dq1_dz2,
                                                             
                                                             dq2_dx1,
                                                             dq2_dy1,
                                                             dq2_dz1,
                                                             dq2_dx2,
                                                             dq2_dy2,
                                                             dq2_dz2,
                                                             
                                                             dq0_dxp,
                                                             dq0_dyp,
                                                             dq0_dzp,
                                                                
                                                             dq1_dxp,
                                                             dq1_dyp,
                                                             dq1_dzp,
                                                                  
                                                             dq2_dxp,
                                                             dq2_dyp,
                                                             dq2_dzp,
                                                             
                                                             dq0_dMach,
                                                             dq1_dMach,
                                                             dq2_dMach);                                                                      


                if ( DoSymmetryPlaneSolve_ ) {
                      
                   xyz[0] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[2];
                   
                   VortexEdge->dInducedVelocity_dMesh_Transpose(xyz,
                                                                dq0_dx1_s,
                                                                dq0_dy1_s,
                                                                dq0_dz1_s,
                                                                dq0_dx2_s,
                                                                dq0_dy2_s,
                                                                dq0_dz2_s,
                                                                      
                                                                dq1_dx1_s,
                                                                dq1_dy1_s,
                                                                dq1_dz1_s,
                                                                dq1_dx2_s,
                                                                dq1_dy2_s,
                                                                dq1_dz2_s,
                                                                      
                                                                dq2_dx1_s,
                                                                dq2_dy1_s,
                                                                dq2_dz1_s,
                                                                dq2_dx2_s,
                                                                dq2_dy2_s,
                                                                dq2_dz2_s,
                                                                      
                                                                dq0_dxp_s,
                                                                dq0_dyp_s,
                                                                dq0_dzp_s,
                                                                      
                                                                dq1_dxp_s,
                                                                dq1_dyp_s,
                                                                dq1_dzp_s,
                                                                      
                                                                dq2_dxp_s,
                                                                dq2_dyp_s,
                                                                dq2_dzp_s,
                                                                
                                                                dq0_dMach_s,
                                                                dq1_dMach_s,
                                                                dq2_dMach_s);                           
             
                   dq0_dx1 += dq0_dx1_s;
                   dq0_dy1 += dq0_dy1_s;
                   dq0_dz1 += dq0_dz1_s;
                   dq0_dx2 += dq0_dx2_s;
                   dq0_dy2 += dq0_dy2_s;
                   dq0_dz2 += dq0_dz2_s;
                   
                   dq1_dx1 -= dq1_dx1_s;
                   dq1_dy1 -= dq1_dy1_s;
                   dq1_dz1 -= dq1_dz1_s;
                   dq1_dx2 -= dq1_dx2_s;
                   dq1_dy2 -= dq1_dy2_s;
                   dq1_dz2 -= dq1_dz2_s;
                   
                   dq2_dx1 += dq2_dx1_s;
                   dq2_dy1 += dq2_dy1_s;
                   dq2_dz1 += dq2_dz1_s;
                   dq2_dx2 += dq2_dx2_s;
                   dq2_dy2 += dq2_dy2_s;
                   dq2_dz2 += dq2_dz2_s;
                   
                   dq0_dxp += dq0_dxp_s;
                   dq0_dyp += dq0_dyp_s;
                   dq0_dzp += dq0_dzp_s;
                   
                   dq1_dxp -= dq1_dxp_s;
                   dq1_dyp -= dq1_dyp_s;
                   dq1_dzp -= dq1_dzp_s;
                   
                   dq2_dxp += dq2_dxp_s;
                   dq2_dyp += dq2_dyp_s;
                   dq2_dzp += dq2_dzp_s;
                   
                   dq0_dMach += dq0_dMach_s;
                   dq1_dMach -= dq1_dMach_s;
                   dq2_dMach += dq2_dMach_s;        
                            
                }
                                             
                // If this is a surface edge there are no wake node unknowns
                // However, the incoming xyz_p is a function of the wake node unknowns
                // So the xyz_p terms are not zero, but the rest are
                                                                             
                if ( VortexEdge->SurfaceID() > 0 ) {
                   
                   dq0_dx1 = 0.;
                   dq0_dy1 = 0.;
                   dq0_dz1 = 0.;
                   dq0_dx2 = 0.;
                   dq0_dy2 = 0.;
                   dq0_dz2 = 0.;
                          
                   dq1_dx1 = 0.;
                   dq1_dy1 = 0.;
                   dq1_dz1 = 0.;
                   dq1_dx2 = 0.;
                   dq1_dy2 = 0.;
                   dq1_dz2 = 0.;
                         
                   dq2_dx1 = 0.;
                   dq2_dy1 = 0.;
                   dq2_dz1 = 0.;
                   dq2_dx2 = 0.;
                   dq2_dy2 = 0.;    
                   
                }  

                CalculateAdjointWakeMeshMatrixMultiply(iLevel, iEdge, dq0_dx1,
                                                                      dq0_dy1,
                                                                      dq0_dz1,
                                                                      dq0_dx2,
                                                                      dq0_dy2,
                                                                      dq0_dz2,
                                                                      
                                                                      dq1_dx1,
                                                                      dq1_dy1,
                                                                      dq1_dz1,
                                                                      dq1_dx2,
                                                                      dq1_dy2,
                                                                      dq1_dz2,
                                                                      
                                                                      dq2_dx1,
                                                                      dq2_dy1,
                                                                      dq2_dz1,
                                                                      dq2_dx2,
                                                                      dq2_dy2,
                                                                      dq2_dz2,
                                                                      
                                                                      dq0_dxp,
                                                                      dq0_dyp,
                                                                      dq0_dzp,
                                                                         
                                                                      dq1_dxp,
                                                                      dq1_dyp,
                                                                      dq1_dzp,
                                                                           
                                                                      dq2_dxp,
                                                                      dq2_dyp,
                                                                      dq2_dzp, 1., Coef);     
                                                                                 
                // Distribute coefficients    

                if ( VortexEdge->SurfaceID() == 0 ) {
                   
                   Node1 = VortexEdge->Node1();
                   Node2 = VortexEdge->Node2();
                   
                   GammaT_pR_pMesh[3*Node1 - 2 + MG_OffSet[jLevel]] += Coef[0];
                   GammaT_pR_pMesh[3*Node1 - 1 + MG_OffSet[jLevel]] += Coef[1];
                   GammaT_pR_pMesh[3*Node1     + MG_OffSet[jLevel]] += Coef[2];

                   GammaT_pR_pMesh[3*Node2 - 2 + MG_OffSet[jLevel]] += Coef[3];
                   GammaT_pR_pMesh[3*Node2 - 1 + MG_OffSet[jLevel]] += Coef[4];
                   GammaT_pR_pMesh[3*Node2     + MG_OffSet[jLevel]] += Coef[5];

                }

                Node1 = VSPGeom().Grid(iLevel).EdgeList(iEdge).Node1();
                Node2 = VSPGeom().Grid(iLevel).EdgeList(iEdge).Node2();
                
                                                                                     GammaT_pR_pMesh[3*Node1 - 2 + MG_OffSet[iLevel]] += Coef[6];
                if ( !VSPGeom().Grid(iLevel).NodeList(Node1).IsSymmetryPlaneNode() ) GammaT_pR_pMesh[3*Node1 - 1 + MG_OffSet[iLevel]] += Coef[7];
                                                                                     GammaT_pR_pMesh[3*Node1     + MG_OffSet[iLevel]] += Coef[8];
                                                       
                                                                                     GammaT_pR_pMesh[3*Node2 - 2 + MG_OffSet[iLevel]] += Coef[6];
                if ( !VSPGeom().Grid(iLevel).NodeList(Node2).IsSymmetryPlaneNode() ) GammaT_pR_pMesh[3*Node2 - 1 + MG_OffSet[iLevel]] += Coef[7];
                                                                                     GammaT_pR_pMesh[3*Node2     + MG_OffSet[iLevel]] += Coef[8];
               
             }
             
          }

       }   
       
    }    

    // Prolongate gradients
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( NodeC = 1 ; NodeC <= VSPGeom().Grid(Level).NumberOfNodes() ; NodeC++ ) {

          NodeF = VSPGeom().Grid(Level).NodeList(NodeC).FineGridNode();
          
          GammaT_pR_pMesh[3*NodeF - 2 + MG_OffSet[Level-1]] += GammaT_pR_pMesh[3*NodeC - 2 + MG_OffSet[Level]];
          GammaT_pR_pMesh[3*NodeF - 1 + MG_OffSet[Level-1]] += GammaT_pR_pMesh[3*NodeC - 1 + MG_OffSet[Level]];
          GammaT_pR_pMesh[3*NodeF     + MG_OffSet[Level-1]] += GammaT_pR_pMesh[3*NodeC     + MG_OffSet[Level]];
          
       }
       
    }

    // Copy over results

    for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() + 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {

       j = i - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
       
       vec_out[3*j - 2 + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()] += GammaT_pR_pMesh[3*i - 2 + MG_OffSet[MGLevel_]];
       vec_out[3*j - 1 + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()] += GammaT_pR_pMesh[3*i - 1 + MG_OffSet[MGLevel_]];
       vec_out[3*j     + VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops()] += GammaT_pR_pMesh[3*i     + MG_OffSet[MGLevel_]];
       
    }
    
    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] GammaT_pR_pMesh;
        
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CalculateAdjointWakeMeshMatrixMultiply           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateAdjointWakeMeshMatrixMultiply(int LevelC, int EdgeC, 
                                                                              double &dq0_dx1,
                                                                              double &dq0_dy1,
                                                                              double &dq0_dz1,
                                                                              double &dq0_dx2,
                                                                              double &dq0_dy2,
                                                                              double &dq0_dz2,
                                                                              
                                                                              double &dq1_dx1,
                                                                              double &dq1_dy1,
                                                                              double &dq1_dz1,
                                                                              double &dq1_dx2,
                                                                              double &dq1_dy2,
                                                                              double &dq1_dz2,
                                                                              
                                                                              double &dq2_dx1,
                                                                              double &dq2_dy1,
                                                                              double &dq2_dz1,
                                                                              double &dq2_dx2,
                                                                              double &dq2_dy2,
                                                                              double &dq2_dz2,
                                                                              
                                                                              double &dq0_dxp,
                                                                              double &dq0_dyp,
                                                                              double &dq0_dzp,
                                                                              
                                                                              double &dq1_dxp,
                                                                              double &dq1_dyp,
                                                                              double &dq1_dzp,
                                                                              
                                                                              double &dq2_dxp,
                                                                              double &dq2_dyp,
                                                                              double &dq2_dzp, double Fact, double Coef[9]) 
{
    
    // On finest level

    if ( LevelC == MGLevel_  ) {
        
       if ( VSPGeom().Grid(LevelC).EdgeList(EdgeC).IsWakeEdge() && VSPGeom().Grid(LevelC).EdgeList(EdgeC).WakeEdgeData().dS() > 0. ) {
          
          if ( !TimeAccurate_ ) {

             VSPGeom().Grid(LevelC).EdgeList(EdgeC).dInducedVelocity_dMesh_dMesh_Transpose(dq0_dx1,
                                                                                           dq0_dy1,
                                                                                           dq0_dz1,
                                                                                           dq0_dx2,
                                                                                           dq0_dy2,
                                                                                           dq0_dz2,
                                                                                           
                                                                                           dq1_dx1,
                                                                                           dq1_dy1,
                                                                                           dq1_dz1,
                                                                                           dq1_dx2,
                                                                                           dq1_dy2,
                                                                                           dq1_dz2,
                                                                                           
                                                                                           dq2_dx1,
                                                                                           dq2_dy1,
                                                                                           dq2_dz1,
                                                                                           dq2_dx2,
                                                                                           dq2_dy2,
                                                                                           dq2_dz2,
   
                                                                                           dq0_dxp,
                                                                                           dq0_dyp,
                                                                                           dq0_dzp,
                                                                                              
                                                                                           dq1_dxp,
                                                                                           dq1_dyp,
                                                                                           dq1_dzp,
                                                                                                
                                                                                           dq2_dxp,
                                                                                           dq2_dyp,
                                                                                           dq2_dzp,     
                                                                                                                                                           
                                                                                           Coef);     
                                                                                           
          }
          
          else {
             
             VSPGeom().Grid(LevelC).EdgeList(EdgeC).dInducedVelocity_dMesh_dMesh_Unsteady_Transpose(dq0_dx1,
                                                                                                    dq0_dy1,
                                                                                                    dq0_dz1,
                                                                                                    dq0_dx2,
                                                                                                    dq0_dy2,
                                                                                                    dq0_dz2,
                                                                                                    
                                                                                                    dq1_dx1,
                                                                                                    dq1_dy1,
                                                                                                    dq1_dz1,
                                                                                                    dq1_dx2,
                                                                                                    dq1_dy2,
                                                                                                    dq1_dz2,
                                                                                                    
                                                                                                    dq2_dx1,
                                                                                                    dq2_dy1,
                                                                                                    dq2_dz1,
                                                                                                    dq2_dx2,
                                                                                                    dq2_dy2,
                                                                                                    dq2_dz2,
                                                                                                    
                                                                                                    dq0_dxp,
                                                                                                    dq0_dyp,
                                                                                                    dq0_dzp,
                                                                                                       
                                                                                                    dq1_dxp,
                                                                                                    dq1_dyp,
                                                                                                    dq1_dzp,
                                                                                                         
                                                                                                    dq2_dxp,
                                                                                                    dq2_dyp,
                                                                                                    dq2_dzp,     
                                                                                                         
                                                                                                    DeltaTime_,
                                                                                                    
                                                                                                    Coef);     
                                                                                           
          }             

          Coef[0] *= Fact;
          Coef[1] *= Fact;
          Coef[2] *= Fact;
          Coef[3] *= Fact;
          Coef[4] *= Fact;
          Coef[5] *= Fact;
          Coef[6] *= Fact;
          Coef[7] *= Fact;
          Coef[8] *= Fact;
           
       }
       
       else {
          
          Coef[0] = 0.;
          Coef[1] = 0.;
          Coef[2] = 0.;
          Coef[3] = 0.;
          Coef[4] = 0.;
          Coef[5] = 0.;
          Coef[6] = 0.;
          Coef[7] = 0.;
          Coef[8] = 0.;
          
       }
                
    }
    
    // Prolongate over edges
    
    else {
       
       int j, Edge;
       
       double dCoef[9], NewFact;

       // Loop over adjoint edges...
       
       Coef[0] = 0.;
       Coef[1] = 0.;
       Coef[2] = 0.;
       Coef[3] = 0.;
       Coef[4] = 0.;
       Coef[5] = 0.;
       Coef[6] = 0.;
       Coef[7] = 0.;
       Coef[8] = 0.;
                           
       for ( j = 1 ; j <= VSPGeom().Grid(LevelC).EdgeList(EdgeC).NumberOfAdjointEdges() ; j++ ) {
          
          Edge = ABS(VSPGeom().Grid(LevelC).EdgeList(EdgeC).AdjointEdgeList(j));

          NewFact = Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).AdjointEdgeFactor(j);
         
          CalculateAdjointWakeMeshMatrixMultiply(LevelC - 1, Edge, dq0_dx1,
                                                                   dq0_dy1,
                                                                   dq0_dz1,
                                                                   dq0_dx2,
                                                                   dq0_dy2,
                                                                   dq0_dz2,
                                                                   
                                                                   dq1_dx1,
                                                                   dq1_dy1,
                                                                   dq1_dz1,
                                                                   dq1_dx2,
                                                                   dq1_dy2,
                                                                   dq1_dz2,
                                                                   
                                                                   dq2_dx1,
                                                                   dq2_dy1,
                                                                   dq2_dz1,
                                                                   dq2_dx2,
                                                                   dq2_dy2,
                                                                   dq2_dz2,

                                                                   dq0_dxp,
                                                                   dq0_dyp,
                                                                   dq0_dzp,
                                                                      
                                                                   dq1_dxp,
                                                                   dq1_dyp,
                                                                   dq1_dzp,
                                                                        
                                                                   dq2_dxp,
                                                                   dq2_dyp,
                                                                   dq2_dzp, NewFact, dCoef);

          Coef[0] += dCoef[0];
          Coef[1] += dCoef[1];
          Coef[2] += dCoef[2];
          Coef[3] += dCoef[3];
          Coef[4] += dCoef[4];
          Coef[5] += dCoef[5];
          Coef[6] += dCoef[6];
          Coef[7] += dCoef[7];
          Coef[8] += dCoef[8];
          
       }

    }
            
}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER CalculateForceGradients                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateForceGradients(void)
{

    int Level, i, k;
    
    // Zero gradients wrt gamma
    
    for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfLoops() ; i++ ) {
          
          VSPGeom().Grid(Level).LoopList(i).pFx_pGamma() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pFy_pGamma() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pFz_pGamma() = 0.;

          VSPGeom().Grid(Level).LoopList(i).pMx_pGamma() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pMy_pGamma() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pMz_pGamma() = 0.;

          VSPGeom().Grid(Level).LoopList(i).pFwx_pGamma() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pFwy_pGamma() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pFwz_pGamma() = 0.;
          
       }
       
    }
        
    // Zero gradients wrt mesh
        
    for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfNodes() ; i++ ) {
          
          VSPGeom().Grid(Level).NodeList(i).pFix_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiy_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiz_pX() = 0.;

          VSPGeom().Grid(Level).NodeList(i).pFix_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiy_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiz_pY() = 0.;
                             
          VSPGeom().Grid(Level).NodeList(i).pFix_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiy_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiz_pZ() = 0.;

          VSPGeom().Grid(Level).NodeList(i).pMix_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiy_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiz_pX() = 0.;
                                            
          VSPGeom().Grid(Level).NodeList(i).pMix_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiy_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiz_pY() = 0.;
                                             
          VSPGeom().Grid(Level).NodeList(i).pMix_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiy_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiz_pZ() = 0.;
                    
       }
       
    }
    
    // Zero gradients wrt stall factor

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {

          VSPGeom().VortexSheet(k).TrailingVortex(i).pFx_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFy_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFz_pStallFactor() = 0.;
                                                                      
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor() = 0.;

          VSPGeom().VortexSheet(k).TrailingVortex(i).pFwx_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFwy_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFwz_pStallFactor() = 0.;
          
       }
       
    }
        
    // Zero gradients wrt vortex stretching ratio
        
    for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfLoops() ; i++ ) {
          
          VSPGeom().Grid(Level).LoopList(i).pFx_pRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pFy_pRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pFz_pRatio() = 0.;
                                              
          VSPGeom().Grid(Level).LoopList(i).pMx_pRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pMy_pRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pMz_pRatio() = 0.;

          VSPGeom().Grid(Level).LoopList(i).pFxo_pRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pFyo_pRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pFzo_pRatio() = 0.;
                                             
          VSPGeom().Grid(Level).LoopList(i).pMxo_pRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pMyo_pRatio() = 0.;
          VSPGeom().Grid(Level).LoopList(i).pMzo_pRatio() = 0.;          
       }
       
    }        
                      
    // Gradients with respect to the loop vorticity

    CalculateForceGradients_wrt_Gamma();

    // Gradients with respect to the mesh xyz locations
   
    CalculateForceGradients_wrt_Mesh();
    
    // Gradients with respect to the stall variables
    
    if ( StallModelIsOn_ ) CalculateForceGradients_wrt_StallFactor();
    
    // Gradients with respect to vortex stretching parameter
    
    if ( TimeAccurate_ ) CalculateForceGradients_wrt_VortexStretchingFactor();
    
    // Calculate viscous force gradients
    
    CalculateViscousForceGradients();

}
 
/*##############################################################################
#                                                                              #
#             VSP_SOLVER CalculateForceGradients_wrt_Gamma                     #
#                                                                              #
# F = rho * V x (Gamma * L)                                                    #
# pF_pGamma = rho * pV_pGamma x ( Gamma * L ) + rho * V x L                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateForceGradients_wrt_Gamma(void)
{

    int i, j, k, MaxLoopTypes, LoopType, iLevel, iEdge, jLevel, Sign;
    int *MG_OffSet, ArraySize, LoopL, LoopR, Level, LoopC, LoopF, Edge;
    int KuttaLoop1, KuttaLoop2, iLoop;
    double q[3], Forces[3], Moments[3], WakeForces[3], xyz[3], qs[3], qw[3], KuttaWeight, Fact, dx, dy, dz;
    double *pF_pGamma, *pM_pGamma, *pFw_pGamma, StallFactor;
    VSP_EDGE *VortexEdge, TempEdge;

    // Update the edge velocities
    
    CalculateEdgeVelocities();

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + 3*VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt mesh accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    pF_pGamma = new double[ArraySize];

    pM_pGamma = new double[ArraySize];
    
    pFw_pGamma = new double[ArraySize];
    
    zero_double_array(pF_pGamma, ArraySize-1);

    zero_double_array(pM_pGamma, ArraySize-1);
          
    zero_double_array(pFw_pGamma, ArraySize-1);
          
    // Zero out force partials
    
    for ( iLevel = 0 ; iLevel <= NumberOfMGLevels_ ; iLevel++ ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(iLevel).NumberOfLoops() ; i++ ) {
          
          VSPGeom().Grid(iLevel).LoopList(i).pFx_pGamma() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFy_pGamma() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFz_pGamma() = 0.;

          VSPGeom().Grid(iLevel).LoopList(i).pMx_pGamma() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pMy_pGamma() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pMz_pGamma() = 0.;

          VSPGeom().Grid(iLevel).LoopList(i).pFwx_pGamma() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFwy_pGamma() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFwz_pGamma() = 0.;

       }
       
    }

    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the loops
    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {
#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:pF_pGamma[:ArraySize],pM_pGamma[:ArraySize],pFw_pGamma[:ArraySize]) private(iLevel,iEdge,j,jLevel,VortexEdge,q,Forces,Moments,WakeForces,LoopL,LoopR,xyz,qs,qw) schedule(dynamic)           
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
 
          iLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          iEdge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();
          
          if ( VSPGeom().Grid(iLevel).EdgeList(iEdge).SurfaceID() > 0 ) {

             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
   
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
      
                VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c(), q);
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[2];
                   
                   VortexEdge->pVelocity_pGamma(xyz, qs);
                   
                   q[0] += qs[0];
                   q[1] -= qs[1];
                   q[2] += qs[2];
                   
                }
                
                qw[0] = qw[1] = qw[2] = 0.;
                
                if ( VortexEdge->SurfaceID() == 0 ) {
                   
                   qw[0] = q[0];
                   qw[1] = q[1];
                   qw[2] = q[2];
                   
                }
                
                CalculateAdjointForceGradient(iLevel, iEdge, q, 1., Forces, Moments, qw, WakeForces, 1);

                LoopL = VortexEdge->LoopL();
                
                LoopR = VortexEdge->LoopR();
                
                if ( LoopL > 0 ) {
                   
                   pF_pGamma[3*LoopL - 2 + MG_OffSet[jLevel]] +=  Forces[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                   pF_pGamma[3*LoopL - 1 + MG_OffSet[jLevel]] +=  Forces[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                   pF_pGamma[3*LoopL     + MG_OffSet[jLevel]] +=  Forces[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();   

                   pM_pGamma[3*LoopL - 2 + MG_OffSet[jLevel]] += Moments[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                   pM_pGamma[3*LoopL - 1 + MG_OffSet[jLevel]] += Moments[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                   pM_pGamma[3*LoopL     + MG_OffSet[jLevel]] += Moments[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();   
         
                   pFw_pGamma[3*LoopL - 2 + MG_OffSet[jLevel]] += WakeForces[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                   pFw_pGamma[3*LoopL - 1 + MG_OffSet[jLevel]] += WakeForces[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                   pFw_pGamma[3*LoopL     + MG_OffSet[jLevel]] += WakeForces[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio(); 
                      
                }  

                if ( LoopR > 0 ) {
                   
                   pF_pGamma[3*LoopR - 2 + MG_OffSet[jLevel]] -=  Forces[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                   pF_pGamma[3*LoopR - 1 + MG_OffSet[jLevel]] -=  Forces[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                   pF_pGamma[3*LoopR     + MG_OffSet[jLevel]] -=  Forces[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();  

                   pM_pGamma[3*LoopR - 2 + MG_OffSet[jLevel]] -= Moments[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                   pM_pGamma[3*LoopR - 1 + MG_OffSet[jLevel]] -= Moments[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                   pM_pGamma[3*LoopR     + MG_OffSet[jLevel]] -= Moments[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio(); 
            
                   pFw_pGamma[3*LoopR - 2 + MG_OffSet[jLevel]] -= WakeForces[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                   pFw_pGamma[3*LoopR - 1 + MG_OffSet[jLevel]] -= WakeForces[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                   pFw_pGamma[3*LoopR     + MG_OffSet[jLevel]] -= WakeForces[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();  
                                        
                }  
                               
             }
             
          }
             
       }   
       
    } 
    
    // Prolongate
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();
          
          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             // Forces
             
             pF_pGamma[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pF_pGamma[3*LoopC - 2 + MG_OffSet[Level]];
             pF_pGamma[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pF_pGamma[3*LoopC - 1 + MG_OffSet[Level]];
             pF_pGamma[3*LoopF     + MG_OffSet[Level-1]] += Fact * pF_pGamma[3*LoopC     + MG_OffSet[Level]];
             
             // Moments
             
             pM_pGamma[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pM_pGamma[3*LoopC - 2 + MG_OffSet[Level]];
             pM_pGamma[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pM_pGamma[3*LoopC - 1 + MG_OffSet[Level]];
             pM_pGamma[3*LoopF     + MG_OffSet[Level-1]] += Fact * pM_pGamma[3*LoopC     + MG_OffSet[Level]];      
             
             // Wake induced forces
             
             pFw_pGamma[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pFw_pGamma[3*LoopC - 2 + MG_OffSet[Level]];
             pFw_pGamma[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pFw_pGamma[3*LoopC - 1 + MG_OffSet[Level]];
             pFw_pGamma[3*LoopF     + MG_OffSet[Level-1]] += Fact * pFw_pGamma[3*LoopC     + MG_OffSet[Level]];
                              
          }
          
       }
       
    }

    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       // Forces
       
       VSPGeom().Grid(MGLevel_).LoopList(i).pFx_pGamma() = pF_pGamma[3*i - 2 + MG_OffSet[MGLevel_]];
       VSPGeom().Grid(MGLevel_).LoopList(i).pFy_pGamma() = pF_pGamma[3*i - 1 + MG_OffSet[MGLevel_]]; 
       VSPGeom().Grid(MGLevel_).LoopList(i).pFz_pGamma() = pF_pGamma[3*i     + MG_OffSet[MGLevel_]]; 

       // Moments
       
       VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pGamma() = pM_pGamma[3*i - 2 + MG_OffSet[MGLevel_]];
       VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pGamma() = pM_pGamma[3*i - 1 + MG_OffSet[MGLevel_]]; 
       VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pGamma() = pM_pGamma[3*i     + MG_OffSet[MGLevel_]]; 

       // Wake induced forces
       
       VSPGeom().Grid(MGLevel_).LoopList(i).pFwx_pGamma() = pFw_pGamma[3*i - 2 + MG_OffSet[MGLevel_]];
       VSPGeom().Grid(MGLevel_).LoopList(i).pFwy_pGamma() = pFw_pGamma[3*i - 1 + MG_OffSet[MGLevel_]]; 
       VSPGeom().Grid(MGLevel_).LoopList(i).pFwz_pGamma() = pFw_pGamma[3*i     + MG_OffSet[MGLevel_]]; 

    }
        
    // Redistribute the terms that were calculate for the wake loops... these need to be split over the corresponding
    // Kutta edge loops...

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {

          // Wake loop
                       
          iLoop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
         
          // Trailing edge for this loop
          
          Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
          
          // Sign
          
          Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());

          // Loops attached to trailing edge

          KuttaLoop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
          
          KuttaLoop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();

          if ( !TimeAccurate_ || ( TimeAccurate_ && VSPGeom().Grid(MGLevel_).LoopList(iLoop).MinValidTimeStep() == 1 ) ) {
             
             if ( KuttaLoop1 > 0 ) {
                
                // Forces
             
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFx_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFx_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFy_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFy_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFz_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFz_pGamma();
   
                // Moments
             
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pMx_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMx_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pMy_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMy_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pMz_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMz_pGamma();

                // Wake induced forces
             
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFwx_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwx_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFwy_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwy_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFwz_pGamma() += Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwz_pGamma();
                                                                                                        
             }                                                             
                                                                           
             if ( KuttaLoop2 > 0 ) {      
                
                // Forces                                 
                                                                  
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFx_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFx_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFy_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFy_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFz_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFz_pGamma();
                                                                          
                // Moments                                                
                                                                          
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pMx_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMx_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pMy_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMy_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pMz_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMz_pGamma();

                // Wake induced forces                                 
                                                                  
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFwx_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwx_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFwy_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwy_pGamma();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFwz_pGamma() -= Sign*VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwz_pGamma();
        
             }
             
          }

       }

    }
    
    // Now add in the simple partial term... ie, the V part of V*Gamma...

    for ( iLoop = 1 ; iLoop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; iLoop++ ) {
       
       // Only work on loops on surfaces we are calculating gradients for
       
       if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(MGLevel_).LoopList(iLoop).ComponentID()] ) {

          for ( k = 1 ; k <= VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() ; k++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Edge(k);
   
             StallFactor = 1.;
         
             if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) StallFactor = VSPGeom().Grid(MGLevel_).EdgeList(Edge).TrailingEdgeStallFactor();
   
             dx = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - XYZcg_[0];
             dy = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - XYZcg_[1];
             dz = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - XYZcg_[2];
             
             VSPGeom().Grid(MGLevel_).EdgeList(Edge).CalculateForces_dGamma(Forces);
   
             Forces[0] *= StallFactor;
             Forces[1] *= StallFactor;
             Forces[2] *= StallFactor;
             
             // Depending on edge direction there's a sign flip...
             
             if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL() != iLoop ) {
                
                Forces[0] *= -1.;
                Forces[1] *= -1.;
                Forces[2] *= -1.;
                
             }
             
             if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsSymmetryPlaneEdge() ) Forces[1] = 0.;
   
             // Forces
   
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFx_pGamma() += Forces[0];
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFy_pGamma() += Forces[1];
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFz_pGamma() += Forces[2];
             
             // Moments
             
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMx_pGamma() += Forces[2]*dy - Forces[1]*dz;
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMy_pGamma() += Forces[0]*dz - Forces[2]*dx;
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMz_pGamma() += Forces[1]*dx - Forces[0]*dy;
             
             // Wake forces
             
             if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) {
                
                VSPGeom().Grid(MGLevel_).EdgeList(Edge).CalculateTrefftzForces_dGamma(Forces);
   
                if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL() != iLoop ) {
                   
                   Forces[0] *= -1.;
                   Forces[1] *= -1.;
                   Forces[2] *= -1.;
                   
                }
   
                // Wake induced forces
                
                VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwx_pGamma() += Forces[0];
                VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwy_pGamma() += Forces[1];
                VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwz_pGamma() += Forces[2];
                
             }
                       
          }
          
       }
       
    }

    // Now add in the unsteady terms for a time accurate solution

    if ( TimeAccurate_ ) {

       for ( iLoop = 1 ; iLoop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; iLoop++ ) {

          // Only work on loops on surfaces we are calculating gradients for
          
          if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(MGLevel_).LoopList(iLoop).ComponentID()] ) {

             KuttaWeight = 0.;
             
             for ( k = 1 ; k <= VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() ; k++ ) {
            
                Edge = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Edge(k);
            
                if ( !VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) KuttaWeight += 1.;
            
             }
             
             KuttaWeight /= VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges();
   
             Forces[0] = KuttaWeight * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[0] / ( DeltaTime_ );
             Forces[1] = KuttaWeight * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[1] / ( DeltaTime_ );
             Forces[2] = KuttaWeight * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[2] / ( DeltaTime_ ); 
            
             // Force partials wrt current time gamma
             
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFx_pGamma() += Forces[0];
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFy_pGamma() += Forces[1];
             VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFz_pGamma() += Forces[2];
         
             for ( k = 1 ; k <= VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() ; k++ ) {
                
                Edge = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Edge(k);
                
                if ( !VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) {
   
                   dx = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - XYZcg_[0];
                   dy = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - XYZcg_[1];
                   dz = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - XYZcg_[2];
   
                   Forces[0] = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[0] / ( DeltaTime_ * VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() );
                   Forces[1] = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[1] / ( DeltaTime_ * VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() );
                   Forces[2] = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[2] / ( DeltaTime_ * VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() ); 
      
                   if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsSymmetryPlaneEdge() ) Forces[1] = 0.;
      
                   // Moment partials wrt current time gamma 
                   
                   VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMx_pGamma() += Forces[2]*dy - Forces[1]*dz;
                   VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMy_pGamma() += Forces[0]*dz - Forces[2]*dx;
                   VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMz_pGamma() += Forces[1]*dx - Forces[0]*dy;
       
                }
                    
             }
             
          }
          
       }
       
    }
    
    if ( DoSymmetryPlaneSolve_ ) {
       
       for ( iLoop = 1 ; iLoop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; iLoop++ ) {
     
          // Forces
          
          VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFy_pGamma() = 0.;
          
          // Moments
          
          VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMx_pGamma() = 0.;
          VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMz_pGamma() = 0.;
          
          // Wake induced forces
          
          VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFwy_pGamma() = 0.;
              
       }
       
    }
          
    delete [] MG_OffSet;
    delete [] pF_pGamma;
    delete [] pM_pGamma;    
    delete [] pFw_pGamma;

}

/*##############################################################################
#                                                                              #
#      VSP_SOLVER CalculateTimeAccurateForceCouplingTerms_wrt_Gamma            #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateTimeAccurateForceCouplingTerms_wrt_Gamma(void)
{

    int k;
    int Edge;
    int iLoop;
    double Forces[3], Moments[3], KuttaWeight, dx, dy, dz;

    zero_double_array(pF_pSoln_NP1_[1], NumberOfEquations_);
    zero_double_array(pF_pSoln_NP1_[2], NumberOfEquations_);
    zero_double_array(pF_pSoln_NP1_[3], NumberOfEquations_);
    zero_double_array(pF_pSoln_NP1_[4], NumberOfEquations_);
    zero_double_array(pF_pSoln_NP1_[5], NumberOfEquations_);
    zero_double_array(pF_pSoln_NP1_[6], NumberOfEquations_);
       
    // Now add in the unsteady terms for a time accurate solution

    for ( iLoop = 1 ; iLoop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; iLoop++ ) {
       
       if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(MGLevel_).LoopList(iLoop).ComponentID()] ) {
          
          KuttaWeight = 0.;
          
          for ( k = 1 ; k <= VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() ; k++ ) {
         
             Edge = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Edge(k);
         
             if ( !VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) KuttaWeight += 1.;
         
          }
          
          KuttaWeight /= VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges();
   
          Forces[0] = -KuttaWeight * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[0] / ( DeltaTime_ );
          Forces[1] = -KuttaWeight * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[1] / ( DeltaTime_ );
          Forces[2] = -KuttaWeight * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[2] / ( DeltaTime_ ); 
   
          // Force partials wrt time - 1 gamma
   
          pF_pSoln_NP1_[1][iLoop] += Forces[0];
          pF_pSoln_NP1_[2][iLoop] += Forces[1];
          pF_pSoln_NP1_[3][iLoop] += Forces[2];
                 
          for ( k = 1 ; k <= VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() ; k++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(iLoop).Edge(k);
             
             if ( !VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) {
   
                dx = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - XYZcg_[0];
                dy = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - XYZcg_[1];
                dz = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - XYZcg_[2];
   
                Forces[0] = -VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[0] / ( DeltaTime_ * VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() );
                Forces[1] = -VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[1] / ( DeltaTime_ * VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() );
                Forces[2] = -VSPGeom().Grid(MGLevel_).LoopList(iLoop).Area() * VSPGeom().Grid(MGLevel_).LoopList(iLoop).Normal()[2] / ( DeltaTime_ * VSPGeom().Grid(MGLevel_).LoopList(iLoop).NumberOfEdges() ); 
   
                if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsSymmetryPlaneEdge() ) Forces[1] = 0.;
   
                // Moment partials wrt time - 1 gamma
                
                pF_pSoln_NP1_[4][iLoop] += Forces[2]*dy - Forces[1]*dz;
                pF_pSoln_NP1_[5][iLoop] += Forces[0]*dz - Forces[2]*dx;
                pF_pSoln_NP1_[6][iLoop] += Forces[1]*dx - Forces[0]*dy;
                          
             }
                 
          }
          
       }
       
    }

    if ( DoSymmetryPlaneSolve_ ) {
       
       for ( iLoop = 1 ; iLoop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; iLoop++ ) {
     
          // Forces
          
          pF_pSoln_NP1_[2][iLoop] = 0.;
          
          // Moments
          
          pF_pSoln_NP1_[4][iLoop] = 0.;
          pF_pSoln_NP1_[6][iLoop] = 0.;
    
       }
       
    }

}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER CalculateAdjointForcesOverEdges                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateAdjointForcesOverEdges(int &Level, int &Loop, int iLevel, int iLoop)
{

   if ( Level == MGLevel_ ) {

      int j, Edge;
      double  Forces[3], q[3], Fact;
      
      for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfEdges() ; j++ ) {
         
         Edge = VSPGeom().Grid(Level).LoopList(Loop).Edge(j);

         if ( !VSPGeom().Grid(Level).EdgeList(Edge).IsTrailingEdge()  ) {

           Fact = 0.5;
          
           if ( VSPGeom().Grid(Level).EdgeList(Edge).LoopL() == 0 ||
                VSPGeom().Grid(Level).EdgeList(Edge).LoopR() == 0 ) Fact = 1.;

            q[0] = VSPGeom().Grid(Level).EdgeList(Edge).dU_dGamma();
            q[1] = VSPGeom().Grid(Level).EdgeList(Edge).dV_dGamma();
            q[2] = VSPGeom().Grid(Level).EdgeList(Edge).dW_dGamma();

            VSPGeom().Grid(Level).EdgeList(Edge).CalculateForces_dVelocity(q,Forces);
            
            VSPGeom().Grid(iLevel).LoopList(iLoop).pFx_pGamma() += Fact*Forces[0];
            VSPGeom().Grid(iLevel).LoopList(iLoop).pFy_pGamma() += Fact*Forces[1];
            VSPGeom().Grid(iLevel).LoopList(iLoop).pFz_pGamma() += Fact*Forces[2];      

         }

      }
         
   }
   
   else {

      int j, LevelF, LoopF;

      LevelF = Level - 1;
            
      for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; j++ ) {
       
         LoopF = VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(j);

         CalculateAdjointForcesOverEdges(LevelF, LoopF, iLevel, iLoop);
                                  
      }  
      
   }

}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER CalculateAdjointMeshForcesOverEdges                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateAdjointMeshForcesOverEdges(int &Level, int &Loop, int iLevel, int Node1, int Node2)
{

   if ( Level == MGLevel_ ) {

      int j, k, Edge;
      double Forces[3], q[3], Fact;      

      for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfEdges() ; j++ ) {
         
         Edge = VSPGeom().Grid(Level).LoopList(Loop).Edge(j);

         if ( !VSPGeom().Grid(Level).EdgeList(Edge).IsTrailingEdge()  ) {

           Fact = 0.5;
          
           if ( VSPGeom().Grid(Level).EdgeList(Edge).LoopL() == 0 ||
                VSPGeom().Grid(Level).EdgeList(Edge).LoopR() == 0 ) Fact = 1.;
              
            // Node 1
            
            k = Node1;
            
            // Node 1, wrt x
            
            q[0] = VSPGeom().Grid(Level).EdgeList(Edge).dq0_dx1();
            q[1] = VSPGeom().Grid(Level).EdgeList(Edge).dq1_dx1();
            q[2] = VSPGeom().Grid(Level).EdgeList(Edge).dq2_dx1();

            VSPGeom().Grid(Level).EdgeList(Edge).CalculateForces_dVelocity(q,Forces);
            
            VSPGeom().Grid(iLevel).NodeList(k).pFix_pX() += Fact*Forces[0];
            VSPGeom().Grid(iLevel).NodeList(k).pFiy_pX() += Fact*Forces[1];
            VSPGeom().Grid(iLevel).NodeList(k).pFiz_pX() += Fact*Forces[2];      
                               
            // Node 1, wrt y             
                                        
            q[0] = VSPGeom().Grid(Level).EdgeList(Edge).dq0_dy1();
            q[1] = VSPGeom().Grid(Level).EdgeList(Edge).dq1_dy1();
            q[2] = VSPGeom().Grid(Level).EdgeList(Edge).dq2_dy1();

            VSPGeom().Grid(Level).EdgeList(Edge).CalculateForces_dVelocity(q,Forces);
            
            VSPGeom().Grid(iLevel).NodeList(k).pFix_pY() += Fact*Forces[0];
            VSPGeom().Grid(iLevel).NodeList(k).pFiy_pY() += Fact*Forces[1];
            VSPGeom().Grid(iLevel).NodeList(k).pFiz_pY() += Fact*Forces[2];      
                                                    
            // Node 1, wrt z             
                                        
            q[0] = VSPGeom().Grid(Level).EdgeList(Edge).dq0_dz1();
            q[1] = VSPGeom().Grid(Level).EdgeList(Edge).dq1_dz1();
            q[2] = VSPGeom().Grid(Level).EdgeList(Edge).dq2_dz1();
           
            VSPGeom().Grid(Level).EdgeList(Edge).CalculateForces_dVelocity(q,Forces);
            
            VSPGeom().Grid(iLevel).NodeList(k).pFix_pZ() += Fact*Forces[0];
            VSPGeom().Grid(iLevel).NodeList(k).pFiy_pZ() += Fact*Forces[1];
            VSPGeom().Grid(iLevel).NodeList(k).pFiz_pZ() += Fact*Forces[2];     
                  
            // Node 2
                              
            k = Node2;
                                                    
            // Node 2, wrt x             
                                        
            q[0] = VSPGeom().Grid(Level).EdgeList(Edge).dq0_dx2();
            q[1] = VSPGeom().Grid(Level).EdgeList(Edge).dq1_dx2();
            q[2] = VSPGeom().Grid(Level).EdgeList(Edge).dq2_dx2();
                   
            VSPGeom().Grid(Level).EdgeList(Edge).CalculateForces_dVelocity(q,Forces);
            
            VSPGeom().Grid(iLevel).NodeList(k).pFix_pX() += Fact*Forces[0];
            VSPGeom().Grid(iLevel).NodeList(k).pFiy_pX() += Fact*Forces[1];
            VSPGeom().Grid(iLevel).NodeList(k).pFiz_pX() += Fact*Forces[2];     
                                                    
            // Node 2, wrt y                 
                                        
            q[0] = VSPGeom().Grid(Level).EdgeList(Edge).dq0_dy2();
            q[1] = VSPGeom().Grid(Level).EdgeList(Edge).dq1_dy2();
            q[2] = VSPGeom().Grid(Level).EdgeList(Edge).dq2_dy2();
            
            VSPGeom().Grid(Level).EdgeList(Edge).CalculateForces_dVelocity(q,Forces);
            
            VSPGeom().Grid(iLevel).NodeList(k).pFix_pY() += Fact*Forces[0];
            VSPGeom().Grid(iLevel).NodeList(k).pFiy_pY() += Fact*Forces[1];
            VSPGeom().Grid(iLevel).NodeList(k).pFiz_pY() += Fact*Forces[2];     
                                                    
            // Node 2, wrt z                   
                                        
            q[0] = VSPGeom().Grid(Level).EdgeList(Edge).dq0_dz2();
            q[1] = VSPGeom().Grid(Level).EdgeList(Edge).dq1_dz2();
            q[2] = VSPGeom().Grid(Level).EdgeList(Edge).dq2_dz2();
    
            VSPGeom().Grid(Level).EdgeList(Edge).CalculateForces_dVelocity(q,Forces);
            
            VSPGeom().Grid(iLevel).NodeList(k).pFix_pZ() += Fact*Forces[0];
            VSPGeom().Grid(iLevel).NodeList(k).pFiy_pZ() += Fact*Forces[1];
            VSPGeom().Grid(iLevel).NodeList(k).pFiz_pZ() += Fact*Forces[2];     
                     
         }

      }
         
   }
   
   else {

      int j, LevelF, LoopF;

      LevelF = Level - 1;
            
      for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; j++ ) {
       
         LoopF = VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(j);

         CalculateAdjointMeshForcesOverEdges(LevelF, LoopF, iLevel, Node1, Node2);
                                  
      }  
      
   }

}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER DistributeAdjointForcesOverLoops                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DistributeAdjointForcesOverLoops(int &iLevel, int &iLoop, double Forces[3], double *pF_pS)
{
  
   if ( iLevel == MGLevel_ ) {

      pF_pS[3*iLoop - 2] += Forces[0];
      pF_pS[3*iLoop - 1] += Forces[1];
      pF_pS[3*iLoop    ] += Forces[2];    
      
   }
   
   else {
      
      int i, LevelC;
      
      LevelC = iLevel - 1;
      
      for ( i = 1 ; i <= VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfFineGridLoops() ; i++ ) {
     
         DistributeAdjointForcesOverLoops(LevelC, VSPGeom().Grid(iLevel).LoopList(iLoop).FineGridLoop(i), Forces, pF_pS);
         
      }
      
   }
   
}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER CalculateForceGradients_wrt_Mesh                  #
#                                                                              #
# F = rho * V x (Gamma * L)                                                    #
# pF_pxyz = rho * pV_pxyz x ( Gamma * L ) + rho * V * Gamma * pL_pxyz          #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateForceGradients_wrt_Mesh(void)
{

    int i, j, k, p, j1, j2, Node, Node1, Node2, Edge, MaxLoopTypes, LoopType;
    int iLevel, iEdge, jLevel, jEdge, Level;
    int i_c, i_f, NodeC, NodeF;
    int *MG_OffSet, ArraySize;
    int Loop;
    double xyz[3], q[18], qw[18], Forces[18], Moments[18], WakeForces[18], dForce[18], Force[3];
    double *pF_pMesh, *pM_pMesh, *pFw_pMesh, StallFactor;
    
    double *NormalGradients, *AreaGradients;
    double DGammaDt, DeltaPressure;
    double dFx_dA, dFy_dA, dFz_dA;
    double dFx_dNormalX, dFy_dNormalY, dFz_dNormalZ;

    double dq0_dx1;
    double dq0_dy1;
    double dq0_dz1;
    double dq0_dx2;
    double dq0_dy2;
    double dq0_dz2;
                         
    double dq1_dx1;
    double dq1_dy1;
    double dq1_dz1;
    double dq1_dx2;
    double dq1_dy2;
    double dq1_dz2;
                         
    double dq2_dx1;
    double dq2_dy1;
    double dq2_dz1;
    double dq2_dx2;
    double dq2_dy2;
    double dq2_dz2;

    double dq0_dxp;
    double dq0_dyp;
    double dq0_dzp;
                          
    double dq1_dxp;
    double dq1_dyp;
    double dq1_dzp;
                          
    double dq2_dxp;
    double dq2_dyp;
    double dq2_dzp;   

    double dq0_dMach;
    double dq1_dMach;
    double dq2_dMach;     

    // Symmetry
    
    double dq0_dx1_s;
    double dq0_dy1_s;
    double dq0_dz1_s;
    double dq0_dx2_s;
    double dq0_dy2_s;
    double dq0_dz2_s;
                         
    double dq1_dx1_s;
    double dq1_dy1_s;
    double dq1_dz1_s;
    double dq1_dx2_s;
    double dq1_dy2_s;
    double dq1_dz2_s;
                        
    double dq2_dx1_s;
    double dq2_dy1_s;
    double dq2_dz1_s;
    double dq2_dx2_s;
    double dq2_dy2_s;
    double dq2_dz2_s;
                         
    double dq0_dxp_s;
    double dq0_dyp_s;
    double dq0_dzp_s;
                        
    double dq1_dxp_s;
    double dq1_dyp_s;
    double dq1_dzp_s;
                        
    double dq2_dxp_s;
    double dq2_dyp_s;
    double dq2_dzp_s;   

    double dq0_dMach_s;
    double dq1_dMach_s;
    double dq2_dMach_s;     
                                                            
    double dx, dy, dz;  
                                          
    VSP_EDGE *VortexEdge;

    // MG offset array

    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + 9*VSPGeom().Grid(i-1).NumberOfNodes();
       
    }
    
    // Partial wrt mesh accumalation array
   
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    pF_pMesh = new double[ArraySize];
   
    pM_pMesh = new double[ArraySize];
    
    pFw_pMesh = new double[ArraySize];
   
    zero_double_array(pF_pMesh, ArraySize - 1);
          
    zero_double_array(pM_pMesh, ArraySize - 1);

    zero_double_array(pFw_pMesh, ArraySize - 1);

    // Zero out force partials
    
    for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfNodes() ; i++ ) {
          
          VSPGeom().Grid(Level).NodeList(i).pFix_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiy_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiz_pX() = 0.;

          VSPGeom().Grid(Level).NodeList(i).pFix_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiy_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiz_pY() = 0.;
                             
          VSPGeom().Grid(Level).NodeList(i).pFix_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiy_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFiz_pZ() = 0.;

          VSPGeom().Grid(Level).NodeList(i).pMix_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiy_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiz_pX() = 0.;
                                            
          VSPGeom().Grid(Level).NodeList(i).pMix_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiy_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiz_pY() = 0.;
                                             
          VSPGeom().Grid(Level).NodeList(i).pMix_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiy_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pMiz_pZ() = 0.;

          VSPGeom().Grid(Level).NodeList(i).pFwx_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFwy_pX() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFwz_pX() = 0.;
                                              
          VSPGeom().Grid(Level).NodeList(i).pFwx_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFwy_pY() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFwz_pY() = 0.;
                                              
          VSPGeom().Grid(Level).NodeList(i).pFwx_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFwy_pZ() = 0.;
          VSPGeom().Grid(Level).NodeList(i).pFwz_pZ() = 0.;               
               
       }
       
    }
                   
    MaxLoopTypes = 0;

    // Mesh induced velocities perturbations over all the edges

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:pF_pMesh[:ArraySize],pM_pMesh[:ArraySize],pFw_pMesh[:ArraySize]) private(iLevel,iEdge,j,jLevel,VortexEdge,\
                                                                                                                                          dq0_dx1,\
                                                                                                                                          dq0_dy1,\
                                                                                                                                          dq0_dz1,\
                                                                                                                                          dq0_dx2,\
                                                                                                                                          dq0_dy2,\
                                                                                                                                          dq0_dz2,\
                                                                                                                                          dq1_dx1,\
                                                                                                                                          dq1_dy1,\
                                                                                                                                          dq1_dz1,\
                                                                                                                                          dq1_dx2,\
                                                                                                                                          dq1_dy2,\
                                                                                                                                          dq1_dz2,\
                                                                                                                                          dq2_dx1,\
                                                                                                                                          dq2_dy1,\
                                                                                                                                          dq2_dz1,\
                                                                                                                                          dq2_dx2,\
                                                                                                                                          dq2_dy2,\
                                                                                                                                          dq2_dz2,\
                                                                                                                                          dq0_dxp,\
                                                                                                                                          dq0_dyp,\
                                                                                                                                          dq0_dzp,\
                                                                                                                                          dq1_dxp,\
                                                                                                                                          dq1_dyp,\
                                                                                                                                          dq1_dzp,\
                                                                                                                                          dq2_dxp,\
                                                                                                                                          dq2_dyp,\
                                                                                                                                          dq2_dzp,\
                                                                                                                                          dq0_dMach,\
                                                                                                                                          dq1_dMach,\
                                                                                                                                          dq2_dMach,\
                                                                                                                                          dq0_dx1_s,\
                                                                                                                                          dq0_dy1_s,\
                                                                                                                                          dq0_dz1_s,\
                                                                                                                                          dq0_dx2_s,\
                                                                                                                                          dq0_dy2_s,\
                                                                                                                                          dq0_dz2_s,\
                                                                                                                                          dq1_dx1_s,\
                                                                                                                                          dq1_dy1_s,\
                                                                                                                                          dq1_dz1_s,\
                                                                                                                                          dq1_dx2_s,\
                                                                                                                                          dq1_dy2_s,\
                                                                                                                                          dq1_dz2_s,\
                                                                                                                                          dq2_dx1_s,\
                                                                                                                                          dq2_dy1_s,\
                                                                                                                                          dq2_dz1_s,\
                                                                                                                                          dq2_dx2_s,\
                                                                                                                                          dq2_dy2_s,\
                                                                                                                                          dq2_dz2_s,\
                                                                                                                                          dq0_dxp_s,\
                                                                                                                                          dq0_dyp_s,\
                                                                                                                                          dq0_dzp_s,\
                                                                                                                                          dq1_dxp_s,\
                                                                                                                                          dq1_dyp_s,\
                                                                                                                                          dq1_dzp_s,\
                                                                                                                                          dq2_dxp_s,\
                                                                                                                                          dq2_dyp_s,\
                                                                                                                                          dq2_dzp_s,\
                                                                                                                                          dq0_dMach_s,\
                                                                                                                                          dq1_dMach_s,\
                                                                                                                                          dq2_dMach_s,\
                                                                                                                                          Node1, Node2, q, Forces, Moments, xyz, qw, WakeForces) schedule(dynamic)           
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
    
          iLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          iEdge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          if ( VSPGeom().Grid(iLevel).EdgeList(iEdge).SurfaceID() > 0 ) {
                     
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
                 
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                // Gradients wrt mesh at edge j

                VortexEdge->dInducedVelocity_dMesh_Transpose(VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c(),
                                                             dq0_dx1,
                                                             dq0_dy1,
                                                             dq0_dz1,
                                                             dq0_dx2,
                                                             dq0_dy2,
                                                             dq0_dz2,
                                                             
                                                             dq1_dx1,
                                                             dq1_dy1,
                                                             dq1_dz1,
                                                             dq1_dx2,
                                                             dq1_dy2,
                                                             dq1_dz2,
                                                             
                                                             dq2_dx1,
                                                             dq2_dy1,
                                                             dq2_dz1,
                                                             dq2_dx2,
                                                             dq2_dy2,
                                                             dq2_dz2,
                                                             
                                                             dq0_dxp,
                                                             dq0_dyp,
                                                             dq0_dzp,
                                                                
                                                             dq1_dxp,
                                                             dq1_dyp,
                                                             dq1_dzp,
                                                                   
                                                             dq2_dxp,
                                                             dq2_dyp,
                                                             dq2_dzp,
                                                             
                                                             dq0_dMach,
                                                             dq1_dMach,
                                                             dq2_dMach);   


                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[2];
                   
                   VortexEdge->dInducedVelocity_dMesh_Transpose(xyz,
                                                                dq0_dx1_s,
                                                                dq0_dy1_s,
                                                                dq0_dz1_s,
                                                                dq0_dx2_s,
                                                                dq0_dy2_s,
                                                                dq0_dz2_s,
                                                                    
                                                                dq1_dx1_s,
                                                                dq1_dy1_s,
                                                                dq1_dz1_s,
                                                                dq1_dx2_s,
                                                                dq1_dy2_s,
                                                                dq1_dz2_s,
                                                                       
                                                                dq2_dx1_s,
                                                                dq2_dy1_s,
                                                                dq2_dz1_s,
                                                                dq2_dx2_s,
                                                                dq2_dy2_s,
                                                                dq2_dz2_s,
                                                                     
                                                                dq0_dxp_s,
                                                                dq0_dyp_s,
                                                                dq0_dzp_s,
                                                                     
                                                                dq1_dxp_s,
                                                                dq1_dyp_s,
                                                                dq1_dzp_s,
                                                                      
                                                                dq2_dxp_s,
                                                                dq2_dyp_s,
                                                                dq2_dzp_s,
                                                                
                                                                dq0_dMach_s,
                                                                dq1_dMach_s,
                                                                dq2_dMach_s);   

                   dq0_dx1 += dq0_dx1_s;
                   dq0_dy1 -= dq0_dy1_s;
                   dq0_dz1 += dq0_dz1_s;
                   dq0_dx2 += dq0_dx2_s;
                   dq0_dy2 -= dq0_dy2_s;
                   dq0_dz2 += dq0_dz2_s;
                         
                   dq1_dx1 -= dq1_dx1_s;
                   dq1_dy1 += dq1_dy1_s;
                   dq1_dz1 -= dq1_dz1_s;
                   dq1_dx2 -= dq1_dx2_s;
                   dq1_dy2 += dq1_dy2_s;
                   dq1_dz2 -= dq1_dz2_s;
                         
                   dq2_dx1 += dq2_dx1_s;
                   dq2_dy1 -= dq2_dy1_s;
                   dq2_dz1 += dq2_dz1_s;
                   dq2_dx2 += dq2_dx2_s;
                   dq2_dy2 -= dq2_dy2_s;
                   dq2_dz2 += dq2_dz2_s;
                          
                   dq0_dxp += dq0_dxp_s;
                   dq0_dyp -= dq0_dyp_s;
                   dq0_dzp += dq0_dzp_s;
                          
                   dq1_dxp -= dq1_dxp_s;
                   dq1_dyp += dq1_dyp_s;
                   dq1_dzp -= dq1_dzp_s; 
                          
                   dq2_dxp += dq2_dxp_s;
                   dq2_dyp -= dq2_dyp_s;
                   dq2_dzp += dq2_dzp_s;
                   
                   dq0_dMach += dq0_dMach_s;
                   dq1_dMach -= dq1_dMach_s;
                   dq2_dMach += dq2_dMach_s;
                   
                }
                                                                                                                    
                // j nodes

                   Node1 = VortexEdge->Node1();          
                   Node2 = VortexEdge->Node2();
                                                             
                   // Node 1, wrt x
                   
                   q[ 0] = dq0_dx1;
                   q[ 1] = dq1_dx1;
                   q[ 2] = dq2_dx1;
                                                      
                   // Node 1, wrt y                        
                                                           
                   q[ 3] = dq0_dy1;
                   q[ 4] = dq1_dy1;
                   q[ 5] = dq2_dy1;
                                                           
                   // Node 1, wrt z                        
                                                           
                   q[ 6] = dq0_dz1;
                   q[ 7] = dq1_dz1;
                   q[ 8] = dq2_dz1;

                   // Node 2, wrt x                        
                                                           
                   q[ 9] = dq0_dx2;
                   q[10] = dq1_dx2;
                   q[11] = dq2_dx2;
                                                               
                   // Node 2, wrt y                            
                                                                  
                   q[12] = dq0_dy2;
                   q[13] = dq1_dy2;
                   q[14] = dq2_dy2;
                                                                  
                   // Node 2, wrt z                              
                                                                
                   q[15] = dq0_dz2;
                   q[16] = dq1_dz2;
                   q[17] = dq2_dz2;
                   
                   // Wake induced velocity
                   
                   qw[ 0] = 0.;
                   qw[ 1] = 0.;
                   qw[ 2] = 0.;
                                       
                   qw[ 3] = 0.;
                   qw[ 4] = 0.;
                   qw[ 5] = 0.;
                        
                   qw[ 6] = 0.;
                   qw[ 7] = 0.;
                   qw[ 8] = 0.;
                              
                   qw[ 9] = 0.;
                   qw[10] = 0.;
                   qw[11] = 0.;
                                           
                   qw[12] = 0.;
                   qw[13] = 0.;
                   qw[14] = 0.;
                                           
                   qw[15] = 0.;
                   qw[16] = 0.;
                   qw[17] = 0.;    
                                         
                   if ( VortexEdge->SurfaceID() == 0 ) {
                    
                      qw[ 0] = q[ 0];
                      qw[ 1] = q[ 1];
                      qw[ 2] = q[ 2];
                                                                
                      qw[ 3] = q[ 3];
                      qw[ 4] = q[ 4];
                      qw[ 5] = q[ 5];
                                         
                      qw[ 6] = q[ 6];
                      qw[ 7] = q[ 7];
                      qw[ 8] = q[ 8];
                                               
                      qw[ 9] = q[ 9];
                      qw[10] = q[10];
                      qw[11] = q[11];
                                                       
                      qw[12] = q[12];
                      qw[13] = q[13];
                      qw[14] = q[14];
                                                       
                      qw[15] = q[15];
                      qw[16] = q[16];
                      qw[17] = q[17];    
                      
                   }                 
                                                                          
                   CalculateAdjointForceGradient(iLevel, iEdge, q, 1., Forces, Moments, qw, WakeForces, 6);

                   // Forces
                   
                      // Node 1, wrt x
   
                      pF_pMesh[9*Node1 - 8 + MG_OffSet[jLevel]] += Forces[ 0];
                      pF_pMesh[9*Node1 - 7 + MG_OffSet[jLevel]] += Forces[ 1];
                      pF_pMesh[9*Node1 - 6 + MG_OffSet[jLevel]] += Forces[ 2];      
                                                      
                      // Node 1, wrt y                
                                                      
                      pF_pMesh[9*Node1 - 5 + MG_OffSet[jLevel]] += Forces[ 3];
                      pF_pMesh[9*Node1 - 4 + MG_OffSet[jLevel]] += Forces[ 4];
                      pF_pMesh[9*Node1 - 3 + MG_OffSet[jLevel]] += Forces[ 5];      
                                                             
                      // Node 1, wrt z                
                                                      
                      pF_pMesh[9*Node1 - 2 + MG_OffSet[jLevel]] += Forces[ 6];
                      pF_pMesh[9*Node1 - 1 + MG_OffSet[jLevel]] += Forces[ 7];
                      pF_pMesh[9*Node1     + MG_OffSet[jLevel]] += Forces[ 8];     
                      
                      // Node 2, wrt x
                      
                      pF_pMesh[9*Node2 - 8 + MG_OffSet[jLevel]] += Forces[ 9];
                      pF_pMesh[9*Node2 - 7 + MG_OffSet[jLevel]] += Forces[10];
                      pF_pMesh[9*Node2 - 6 + MG_OffSet[jLevel]] += Forces[11];      
                                                          
                      // Node 2, wrt y                    
                                                          
                      pF_pMesh[9*Node2 - 5 + MG_OffSet[jLevel]] += Forces[12];
                      pF_pMesh[9*Node2 - 4 + MG_OffSet[jLevel]] += Forces[13];
                      pF_pMesh[9*Node2 - 3 + MG_OffSet[jLevel]] += Forces[14];      
                                                           
                      // Node 2, wrt z                    
                                                          
                      pF_pMesh[9*Node2 - 2 + MG_OffSet[jLevel]] += Forces[15];
                      pF_pMesh[9*Node2 - 1 + MG_OffSet[jLevel]] += Forces[16];
                      pF_pMesh[9*Node2     + MG_OffSet[jLevel]] += Forces[17];     

                   // Moments
                   
                      // Node 1, wrt x
   
                      pM_pMesh[9*Node1 - 8 + MG_OffSet[jLevel]] += Moments[ 0];
                      pM_pMesh[9*Node1 - 7 + MG_OffSet[jLevel]] += Moments[ 1];
                      pM_pMesh[9*Node1 - 6 + MG_OffSet[jLevel]] += Moments[ 2];      
                                                 
                      // Node 1, wrt y                
                                         
                      pM_pMesh[9*Node1 - 5 + MG_OffSet[jLevel]] += Moments[ 3];
                      pM_pMesh[9*Node1 - 4 + MG_OffSet[jLevel]] += Moments[ 4];
                      pM_pMesh[9*Node1 - 3 + MG_OffSet[jLevel]] += Moments[ 5];      
                                                          
                      // Node 1, wrt z                
                                                
                      pM_pMesh[9*Node1 - 2 + MG_OffSet[jLevel]] += Moments[ 6];
                      pM_pMesh[9*Node1 - 1 + MG_OffSet[jLevel]] += Moments[ 7];
                      pM_pMesh[9*Node1     + MG_OffSet[jLevel]] += Moments[ 8];     
                     
                      // Node 2, wrt x
                  
                      pM_pMesh[9*Node2 - 8 + MG_OffSet[jLevel]] += Moments[ 9];
                      pM_pMesh[9*Node2 - 7 + MG_OffSet[jLevel]] += Moments[10];
                      pM_pMesh[9*Node2 - 6 + MG_OffSet[jLevel]] += Moments[11];      
                                                     
                      // Node 2, wrt y                    
                                                
                      pM_pMesh[9*Node2 - 5 + MG_OffSet[jLevel]] += Moments[12];
                      pM_pMesh[9*Node2 - 4 + MG_OffSet[jLevel]] += Moments[13];
                      pM_pMesh[9*Node2 - 3 + MG_OffSet[jLevel]] += Moments[14];      
                                                      
                      // Node 2, wrt z                    
                                                  
                      pM_pMesh[9*Node2 - 2 + MG_OffSet[jLevel]] += Moments[15];
                      pM_pMesh[9*Node2 - 1 + MG_OffSet[jLevel]] += Moments[16];
                      pM_pMesh[9*Node2     + MG_OffSet[jLevel]] += Moments[17];     
              
                   // Wake induced forces
                   
                      // Node 1, wrt x
   
                      pFw_pMesh[9*Node1 - 8 + MG_OffSet[jLevel]] += WakeForces[ 0];
                      pFw_pMesh[9*Node1 - 7 + MG_OffSet[jLevel]] += WakeForces[ 1];
                      pFw_pMesh[9*Node1 - 6 + MG_OffSet[jLevel]] += WakeForces[ 2];      
                                                      
                      // Node 1, wrt y                
                                                      
                      pFw_pMesh[9*Node1 - 5 + MG_OffSet[jLevel]] += WakeForces[ 3];
                      pFw_pMesh[9*Node1 - 4 + MG_OffSet[jLevel]] += WakeForces[ 4];
                      pFw_pMesh[9*Node1 - 3 + MG_OffSet[jLevel]] += WakeForces[ 5];      
                                                             
                      // Node 1, wrt z                
                                                      
                      pFw_pMesh[9*Node1 - 2 + MG_OffSet[jLevel]] += WakeForces[ 6];
                      pFw_pMesh[9*Node1 - 1 + MG_OffSet[jLevel]] += WakeForces[ 7];
                      pFw_pMesh[9*Node1     + MG_OffSet[jLevel]] += WakeForces[ 8];     
                      
                      // Node 2, wrt x
                      
                      pFw_pMesh[9*Node2 - 8 + MG_OffSet[jLevel]] += WakeForces[ 9];
                      pFw_pMesh[9*Node2 - 7 + MG_OffSet[jLevel]] += WakeForces[10];
                      pFw_pMesh[9*Node2 - 6 + MG_OffSet[jLevel]] += WakeForces[11];      
                                                          
                      // Node 2, wrt y                    
                                                          
                      pFw_pMesh[9*Node2 - 5 + MG_OffSet[jLevel]] += WakeForces[12];
                      pFw_pMesh[9*Node2 - 4 + MG_OffSet[jLevel]] += WakeForces[13];
                      pFw_pMesh[9*Node2 - 3 + MG_OffSet[jLevel]] += WakeForces[14];      
                                                           
                      // Node 2, wrt z                    
                                                          
                      pFw_pMesh[9*Node2 - 2 + MG_OffSet[jLevel]] += WakeForces[15];
                      pFw_pMesh[9*Node2 - 1 + MG_OffSet[jLevel]] += WakeForces[16];
                      pFw_pMesh[9*Node2     + MG_OffSet[jLevel]] += WakeForces[17];    
                                                          
                // i nodes

                   Node1 = VSPGeom().Grid(iLevel).EdgeList(iEdge).Node1();          
                   Node2 = VSPGeom().Grid(iLevel).EdgeList(iEdge).Node2();
        
                   // wrt x
                   
                   q[0] = 0.5*dq0_dxp;
                   q[1] = 0.5*dq1_dxp;
                   q[2] = 0.5*dq2_dxp;
                                                                            
                   // wrt y                                        
                                                                           
                   q[3] = 0.5*dq0_dyp;
                   q[4] = 0.5*dq1_dyp;
                   q[5] = 0.5*dq2_dyp;
                                                                       
                   // wrt z                                    
                                                                       
                   q[6] = 0.5*dq0_dzp;
                   q[7] = 0.5*dq1_dzp;
                   q[8] = 0.5*dq2_dzp;
                   
                   qw[ 0] = 0.;
                   qw[ 1] = 0.;
                   qw[ 2] = 0.;
                                                     
                   qw[ 3] = 0.;
                   qw[ 4] = 0.;
                   qw[ 5] = 0.;
                              
                   qw[ 6] = 0.;
                   qw[ 7] = 0.;
                   qw[ 8] = 0.;
                                         
                   if ( VortexEdge->SurfaceID() == 0 ) {
                    
                      qw[ 0] = q[ 0];
                      qw[ 1] = q[ 1];
                      qw[ 2] = q[ 2];
                                                                
                      qw[ 3] = q[ 3];
                      qw[ 4] = q[ 4];
                      qw[ 5] = q[ 5];
                                         
                      qw[ 6] = q[ 6];
                      qw[ 7] = q[ 7];
                      qw[ 8] = q[ 8];

                   }                 
                                              
                   CalculateAdjointForceGradient(iLevel, iEdge, q, 1., Forces, Moments, qw, WakeForces, 3);

                   // Forces
                   
                      // Node 1, wrt x
      
                      pF_pMesh[9*Node1 - 8 + MG_OffSet[iLevel]] += Forces[0];
                      pF_pMesh[9*Node1 - 7 + MG_OffSet[iLevel]] += Forces[1];
                      pF_pMesh[9*Node1 - 6 + MG_OffSet[iLevel]] += Forces[2];      
                                                      
                      // Node 1, wrt y                

                      if ( !VSPGeom().Grid(iLevel).NodeList(Node1).IsSymmetryPlaneNode() ) {
                                                      
                         pF_pMesh[9*Node1 - 5 + MG_OffSet[iLevel]] += Forces[3];
                         pF_pMesh[9*Node1 - 4 + MG_OffSet[iLevel]] += Forces[4];
                         pF_pMesh[9*Node1 - 3 + MG_OffSet[iLevel]] += Forces[5];      
                           
                      }
                                                      
                      // Node 1, wrt z                
                                                      
                      pF_pMesh[9*Node1 - 2 + MG_OffSet[iLevel]] += Forces[6];
                      pF_pMesh[9*Node1 - 1 + MG_OffSet[iLevel]] += Forces[7];
                      pF_pMesh[9*Node1     + MG_OffSet[iLevel]] += Forces[8];     
                                         
                      // Node 2, wrt x
      
                      pF_pMesh[9*Node2 - 8 + MG_OffSet[iLevel]] += Forces[0];
                      pF_pMesh[9*Node2 - 7 + MG_OffSet[iLevel]] += Forces[1];
                      pF_pMesh[9*Node2 - 6 + MG_OffSet[iLevel]] += Forces[2];      
                                                          
                      // Node 2, wrt y                    

                      if ( !VSPGeom().Grid(iLevel).NodeList(Node2).IsSymmetryPlaneNode()  ) {
                                                          
                         pF_pMesh[9*Node2 - 5 + MG_OffSet[iLevel]] += Forces[3];
                         pF_pMesh[9*Node2 - 4 + MG_OffSet[iLevel]] += Forces[4];
                         pF_pMesh[9*Node2 - 3 + MG_OffSet[iLevel]] += Forces[5];      

                      } 
                                                                                
                      // Node 2, wrt z                    
                                                          
                      pF_pMesh[9*Node2 - 2 + MG_OffSet[iLevel]] += Forces[6];
                      pF_pMesh[9*Node2 - 1 + MG_OffSet[iLevel]] += Forces[7];
                      pF_pMesh[9*Node2     + MG_OffSet[iLevel]] += Forces[8];   

                   // Moments
                   
                      // Node 1, wrt x
      
                      pM_pMesh[9*Node1 - 8 + MG_OffSet[iLevel]] += Moments[0];
                      pM_pMesh[9*Node1 - 7 + MG_OffSet[iLevel]] += Moments[1];
                      pM_pMesh[9*Node1 - 6 + MG_OffSet[iLevel]] += Moments[2];      
                                                      
                      // Node 1, wrt y                
                                                      
                      pM_pMesh[9*Node1 - 5 + MG_OffSet[iLevel]] += Moments[3];
                      pM_pMesh[9*Node1 - 4 + MG_OffSet[iLevel]] += Moments[4];
                      pM_pMesh[9*Node1 - 3 + MG_OffSet[iLevel]] += Moments[5];      
                                                             
                      // Node 1, wrt z                
                                                      
                      pM_pMesh[9*Node1 - 2 + MG_OffSet[iLevel]] += Moments[6];
                      pM_pMesh[9*Node1 - 1 + MG_OffSet[iLevel]] += Moments[7];
                      pM_pMesh[9*Node1     + MG_OffSet[iLevel]] += Moments[8];     
                                         
                      // Node 2, wrt x
      
                      pM_pMesh[9*Node2 - 8 + MG_OffSet[iLevel]] += Moments[0];
                      pM_pMesh[9*Node2 - 7 + MG_OffSet[iLevel]] += Moments[1];
                      pM_pMesh[9*Node2 - 6 + MG_OffSet[iLevel]] += Moments[2];      
                                                          
                      // Node 2, wrt y                    
                                                          
                      pM_pMesh[9*Node2 - 5 + MG_OffSet[iLevel]] += Moments[3];
                      pM_pMesh[9*Node2 - 4 + MG_OffSet[iLevel]] += Moments[4];
                      pM_pMesh[9*Node2 - 3 + MG_OffSet[iLevel]] += Moments[5];      
                                                           
                      // Node 2, wrt z                    
                                                          
                      pM_pMesh[9*Node2 - 2 + MG_OffSet[iLevel]] += Moments[6];
                      pM_pMesh[9*Node2 - 1 + MG_OffSet[iLevel]] += Moments[7];
                      pM_pMesh[9*Node2     + MG_OffSet[iLevel]] += Moments[8];   

                   // Wake induced forces
                   
                      // Node 1, wrt x
      
                      pFw_pMesh[9*Node1 - 8 + MG_OffSet[iLevel]] += WakeForces[0];
                      pFw_pMesh[9*Node1 - 7 + MG_OffSet[iLevel]] += WakeForces[1];
                      pFw_pMesh[9*Node1 - 6 + MG_OffSet[iLevel]] += WakeForces[2];      
                                                      
                      // Node 1, wrt y                

                      if ( !VSPGeom().Grid(iLevel).NodeList(Node1).IsSymmetryPlaneNode() ) {
                                                      
                         pFw_pMesh[9*Node1 - 5 + MG_OffSet[iLevel]] += WakeForces[3];
                         pFw_pMesh[9*Node1 - 4 + MG_OffSet[iLevel]] += WakeForces[4];
                         pFw_pMesh[9*Node1 - 3 + MG_OffSet[iLevel]] += WakeForces[5];      
                           
                      }
                                                      
                      // Node 1, wrt z                
                                                      
                      pFw_pMesh[9*Node1 - 2 + MG_OffSet[iLevel]] += WakeForces[6];
                      pFw_pMesh[9*Node1 - 1 + MG_OffSet[iLevel]] += WakeForces[7];
                      pFw_pMesh[9*Node1     + MG_OffSet[iLevel]] += WakeForces[8];     
                                         
                      // Node 2, wrt x
      
                      pFw_pMesh[9*Node2 - 8 + MG_OffSet[iLevel]] += WakeForces[0];
                      pFw_pMesh[9*Node2 - 7 + MG_OffSet[iLevel]] += WakeForces[1];
                      pFw_pMesh[9*Node2 - 6 + MG_OffSet[iLevel]] += WakeForces[2];      
                                                          
                      // Node 2, wrt y                    

                      if ( !VSPGeom().Grid(iLevel).NodeList(Node2).IsSymmetryPlaneNode()  ) {
                                                          
                         pFw_pMesh[9*Node2 - 5 + MG_OffSet[iLevel]] += WakeForces[3];
                         pFw_pMesh[9*Node2 - 4 + MG_OffSet[iLevel]] += WakeForces[4];
                         pFw_pMesh[9*Node2 - 3 + MG_OffSet[iLevel]] += WakeForces[5];      

                      } 
                                                                                
                      // Node 2, wrt z                    
                                                          
                      pFw_pMesh[9*Node2 - 2 + MG_OffSet[iLevel]] += WakeForces[6];
                      pFw_pMesh[9*Node2 - 1 + MG_OffSet[iLevel]] += WakeForces[7];
                      pFw_pMesh[9*Node2     + MG_OffSet[iLevel]] += WakeForces[8];   
                                                                                                                                               
             }
             
          }
          
       }
       
    }
    
    // Prolongate forces and moments

    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {
  
       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfNodes() ; i_c++ ) {
         
          NodeC = i_c;
          
          i_f = VSPGeom().Grid(Level).NodeList(i_c).FineGridNode();
          
          NodeF = i_f;
          
          // Forces
          
          pF_pMesh[9*NodeF - 8 + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC - 8 + MG_OffSet[Level]];
          pF_pMesh[9*NodeF - 7 + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC - 7 + MG_OffSet[Level]];
          pF_pMesh[9*NodeF - 6 + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC - 6 + MG_OffSet[Level]];
         
          pF_pMesh[9*NodeF - 5 + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC - 5 + MG_OffSet[Level]];
          pF_pMesh[9*NodeF - 4 + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC - 4 + MG_OffSet[Level]];
          pF_pMesh[9*NodeF - 3 + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC - 3 + MG_OffSet[Level]];
          
          pF_pMesh[9*NodeF - 2 + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC - 2 + MG_OffSet[Level]];
          pF_pMesh[9*NodeF - 1 + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC - 1 + MG_OffSet[Level]];
          pF_pMesh[9*NodeF     + MG_OffSet[Level-1]] += pF_pMesh[9*NodeC     + MG_OffSet[Level]];
          
          // Moments
         
          pM_pMesh[9*NodeF - 8 + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC - 8 + MG_OffSet[Level]];
          pM_pMesh[9*NodeF - 7 + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC - 7 + MG_OffSet[Level]];
          pM_pMesh[9*NodeF - 6 + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC - 6 + MG_OffSet[Level]];
         
          pM_pMesh[9*NodeF - 5 + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC - 5 + MG_OffSet[Level]];
          pM_pMesh[9*NodeF - 4 + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC - 4 + MG_OffSet[Level]];
          pM_pMesh[9*NodeF - 3 + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC - 3 + MG_OffSet[Level]];
          
          pM_pMesh[9*NodeF - 2 + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC - 2 + MG_OffSet[Level]];
          pM_pMesh[9*NodeF - 1 + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC - 1 + MG_OffSet[Level]];
          pM_pMesh[9*NodeF     + MG_OffSet[Level-1]] += pM_pMesh[9*NodeC     + MG_OffSet[Level]];

          // Wake induced forces
          
          pFw_pMesh[9*NodeF - 8 + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC - 8 + MG_OffSet[Level]];
          pFw_pMesh[9*NodeF - 7 + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC - 7 + MG_OffSet[Level]];
          pFw_pMesh[9*NodeF - 6 + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC - 6 + MG_OffSet[Level]];
                                                              
          pFw_pMesh[9*NodeF - 5 + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC - 5 + MG_OffSet[Level]];
          pFw_pMesh[9*NodeF - 4 + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC - 4 + MG_OffSet[Level]];
          pFw_pMesh[9*NodeF - 3 + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC - 3 + MG_OffSet[Level]];
                                                              
          pFw_pMesh[9*NodeF - 2 + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC - 2 + MG_OffSet[Level]];
          pFw_pMesh[9*NodeF - 1 + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC - 1 + MG_OffSet[Level]];
          pFw_pMesh[9*NodeF     + MG_OffSet[Level-1]] += pFw_pMesh[9*NodeC     + MG_OffSet[Level]];
                                                
      }
      
   }
   
   // Copy over the forces and moments
    
    for ( Level = 0 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfNodes() ; i++ ) {
          
          j = i;
          
          // Forces

          VSPGeom().Grid(Level).NodeList(i).pFix_pX() = pF_pMesh[9*j - 8 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFiy_pX() = pF_pMesh[9*j - 7 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFiz_pX() = pF_pMesh[9*j - 6 + MG_OffSet[Level]];
                                                                                         
          VSPGeom().Grid(Level).NodeList(i).pFix_pY() = pF_pMesh[9*j - 5 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFiy_pY() = pF_pMesh[9*j - 4 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFiz_pY() = pF_pMesh[9*j - 3 + MG_OffSet[Level]];
                                                                                          
          VSPGeom().Grid(Level).NodeList(i).pFix_pZ() = pF_pMesh[9*j - 2 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFiy_pZ() = pF_pMesh[9*j - 1 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFiz_pZ() = pF_pMesh[9*j     + MG_OffSet[Level]];
                                                                                          
          // Moments                                                                     
                                                                                         
          VSPGeom().Grid(Level).NodeList(i).pMix_pX() = pM_pMesh[9*j - 8 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pMiy_pX() = pM_pMesh[9*j - 7 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pMiz_pX() = pM_pMesh[9*j - 6 + MG_OffSet[Level]];
                                                                                        
          VSPGeom().Grid(Level).NodeList(i).pMix_pY() = pM_pMesh[9*j - 5 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pMiy_pY() = pM_pMesh[9*j - 4 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pMiz_pY() = pM_pMesh[9*j - 3 + MG_OffSet[Level]];
                                                                                         
          VSPGeom().Grid(Level).NodeList(i).pMix_pZ() = pM_pMesh[9*j - 2 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pMiy_pZ() = pM_pMesh[9*j - 1 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pMiz_pZ() = pM_pMesh[9*j     + MG_OffSet[Level]];

          // Wake induced forces

          VSPGeom().Grid(Level).NodeList(i).pFwx_pX() = pFw_pMesh[9*j - 8 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFwy_pX() = pFw_pMesh[9*j - 7 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFwz_pX() = pFw_pMesh[9*j - 6 + MG_OffSet[Level]];
                                                                              
          VSPGeom().Grid(Level).NodeList(i).pFwx_pY() = pFw_pMesh[9*j - 5 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFwy_pY() = pFw_pMesh[9*j - 4 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFwz_pY() = pFw_pMesh[9*j - 3 + MG_OffSet[Level]];
                                                                                
          VSPGeom().Grid(Level).NodeList(i).pFwx_pZ() = pFw_pMesh[9*j - 2 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFwy_pZ() = pFw_pMesh[9*j - 1 + MG_OffSet[Level]];
          VSPGeom().Grid(Level).NodeList(i).pFwz_pZ() = pFw_pMesh[9*j     + MG_OffSet[Level]];
                                                  
       }
       
    }    

    // Merge the trailing edge nodes on the surface and wake

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          j1 = VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Node();
          
          j2 = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(1);
          
          StallFactor = VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor();
          
          // Forces
          
             // wrt X
        
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFix_pX();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFiy_pX();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFiz_pX();
                                                                                                                                             
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFix_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pX();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFiy_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pX();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFiz_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pX();                                            
                                                                                                                                                          
             // wrt Y                                                                                                                                    
                                                                                                                                                          
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFix_pY();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFiy_pY();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFiz_pY();
                                                                                        
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFix_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pY();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFiy_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pY();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFiz_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pY();                                            
                          
             // wrt Z                                                                                                                                
                                                                                                                                                  
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFix_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFiy_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFiz_pZ();
                                                                                                
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFix_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFix_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFiy_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFiy_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFiz_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFiz_pZ();

          // Moments
          
             // wrt X
             
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMix_pX();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMiy_pX();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMiz_pX();
                                                                                                                                               
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMix_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pX();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMiy_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pX();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMiz_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pX();                                            
                                                                                                                                               
             // wrt Y                                                                                                                           
                                                                                                                                                
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMix_pY();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMiy_pY();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMiz_pY();
                                                                                                                                    
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMix_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pY();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMiy_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pY();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMiz_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pY();                                            
                                                                                                                                                
             // wrt Z                                                                                                                              
                                                                                                                                             
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMix_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMiy_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pMiz_pZ();
                                                                                           
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMix_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMix_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMiy_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMiy_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j2).pMiz_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pMiz_pZ();

          // Wake induced forces
          
             // wrt X
        
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwx_pX();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwy_pX();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pX() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pX() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwz_pX();
                                                                                                                                     
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwx_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pX();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwy_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pX();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwz_pX() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pX();                                            
                                                                                                                                                       
             // wrt Y                                                                                                                                 
                                                                                                                                                       
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwx_pY();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwy_pY();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pY() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pY() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwz_pY();
                                                                                  
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwx_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pY();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwy_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pY();                                            
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwz_pY() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pY();                                            
                                                    
             // wrt Z                                                                                                                             
                                                                                                                                               
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwx_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwy_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pZ() = VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pZ() + VSPGeom().Grid(MGLevel_).NodeList(j2).pFwz_pZ();
                                                                                        
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwx_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwx_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwy_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwy_pZ();
             VSPGeom().Grid(MGLevel_).NodeList(j2).pFwz_pZ() = 0.*VSPGeom().Grid(MGLevel_).NodeList(j1).pFwz_pZ();
                             
       }
   
    }    

    // Now need to add in the geometrical partials...
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; i++ ) {

       // Only work on loops on surfaces we are calculating gradients for
       
       if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(MGLevel_).EdgeList(i).ComponentID()] ) {
                
          // Moment arm
   
          dx = VSPGeom().Grid(MGLevel_).EdgeList(i).Xc() - XYZcg_[0];
          dy = VSPGeom().Grid(MGLevel_).EdgeList(i).Yc() - XYZcg_[1];
          dz = VSPGeom().Grid(MGLevel_).EdgeList(i).Zc() - XYZcg_[2];
                       
          // Force on this edge
                                 
          VSPGeom().Grid(MGLevel_).EdgeList(i).CalculateForces();
          
          Force[0] = VSPGeom().Grid(MGLevel_).EdgeList(i).Fx();
          Force[1] = VSPGeom().Grid(MGLevel_).EdgeList(i).Fy();
          Force[2] = VSPGeom().Grid(MGLevel_).EdgeList(i).Fz();
          
          // Gradients of force on this edge wrt xyz 1,2
                       
          VSPGeom().Grid(MGLevel_).EdgeList(i).CalculateForces_dMesh(dForce);
               
          if ( TimeAccurate_ ) {
   
             Force[0] += VSPGeom().Grid(MGLevel_).EdgeList(i).Unsteady_Fx();
             Force[1] += VSPGeom().Grid(MGLevel_).EdgeList(i).Unsteady_Fy();
             Force[2] += VSPGeom().Grid(MGLevel_).EdgeList(i).Unsteady_Fz();
                          
          }
   
          StallFactor = 1.;
          
          if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsTrailingEdge() ) StallFactor = VSPGeom().Grid(MGLevel_).EdgeList(i).TrailingEdgeStallFactor();
          
          Force[0] *= StallFactor;
          Force[1] *= StallFactor;
          Force[2] *= StallFactor;
                           
          // Gradients of force on this edge wrt xyz 1,2
   
          dForce[ 0] *= StallFactor;
          dForce[ 1] *= StallFactor;
          dForce[ 2] *= StallFactor;
          dForce[ 3] *= StallFactor;
          dForce[ 4] *= StallFactor;
          dForce[ 5] *= StallFactor;
          dForce[ 6] *= StallFactor;
          dForce[ 7] *= StallFactor;
          dForce[ 8] *= StallFactor;
          dForce[ 9] *= StallFactor;
          dForce[10] *= StallFactor;
          dForce[11] *= StallFactor;
          dForce[12] *= StallFactor;
          dForce[13] *= StallFactor;
          dForce[14] *= StallFactor;
          dForce[15] *= StallFactor;
          dForce[16] *= StallFactor;
          dForce[17] *= StallFactor;
                             
          // Forces
   
             j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
             
             // Node 1, wrt x
             
             VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pX() += dForce[ 0];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pX() += dForce[ 1];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pX() += dForce[ 2];
                                                      
             // Node 1, wrt y     
             
             if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                      
                VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pY() += dForce[ 3];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pY() += dForce[ 4];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pY() += dForce[ 5];
                
             }
                                                      
             // Node 1, wrt z                         
                                                      
             VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pZ() += dForce[ 6];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pZ() += dForce[ 7];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pZ() += dForce[ 8];
   
             j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();
             
             // Node 2, wrt x
             
             VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pX() += dForce[ 9];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pX() += dForce[10];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pX() += dForce[11];
                                                      
             // Node 2, wrt y                         
                   
             if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                      
                VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pY() += dForce[12];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pY() += dForce[13];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pY() += dForce[14];
                
             }
                                                      
             // Node 2, wrt z                         
                                                      
             VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pZ() += dForce[15];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pZ() += dForce[16];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pZ() += dForce[17];
             
          // Moments
          
             j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
                  
             // Node 1, wrt x
             
             VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pX() += dForce[ 2]*dy - dForce[ 1]*dz;
             VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pX() += dForce[ 0]*dz - dForce[ 2]*dx - 0.5*Force[2];
             VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pX() += dForce[ 1]*dx - dForce[ 0]*dy + 0.5*Force[1];
                                                                                                         
             // Node 1, wrt y                                                                            
                            
             if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                                                                        
                VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pY() += dForce[ 5]*dy - dForce[ 4]*dz + 0.5*Force[2];
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pY() += dForce[ 3]*dz - dForce[ 5]*dx;             
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pY() += dForce[ 4]*dx - dForce[ 3]*dy - 0.5*Force[0];
                
             }
                                                                                                  
             // Node 1, wrt z                                                                            
                                                                                                        
             VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pZ() += dForce[ 8]*dy - dForce[ 7]*dz - 0.5*Force[1];
             VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pZ() += dForce[ 6]*dz - dForce[ 8]*dx + 0.5*Force[0];
             VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pZ() += dForce[ 7]*dx - dForce[ 6]*dy;                 
   
             j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();
   
             // Node 2, wrt x
             
             VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pX() += dForce[11]*dy - dForce[10]*dz;
             VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pX() += dForce[ 9]*dz - dForce[11]*dx - 0.5*Force[2];
             VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pX() += dForce[10]*dx - dForce[ 9]*dy + 0.5*Force[1];
                                                              
             // Node 2, wrt y                      
                       
             if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                   
                VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pY() += dForce[14]*dy - dForce[13]*dz + 0.5*Force[2];
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pY() += dForce[12]*dz - dForce[14]*dx;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pY() += dForce[13]*dx - dForce[12]*dy - 0.5*Force[0];
                
             }
                                                        
             // Node 2, wrt z                       
                                                     
             VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pZ() += dForce[17]*dy - dForce[16]*dz - 0.5*Force[1];
             VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pZ() += dForce[15]*dz - dForce[17]*dx + 0.5*Force[0];
             VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pZ() += dForce[16]*dx - dForce[15]*dy;           
             
          // Wake induced forces
                    
          if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsTrailingEdge() ) {
          
             // Gradients of trefttz force on this edge wrt xyz 1,2
                   
             VSPGeom().Grid(MGLevel_).EdgeList(i).CalculateTrefftzForces_dMesh(dForce);
                       
             j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
             
             // Node 1, wrt x
             
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pX() += dForce[ 0];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pX() += dForce[ 1];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pX() += dForce[ 2];
                                                      
             // Node 1, wrt y     
             
             if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                      
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pY() += dForce[ 3];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pY() += dForce[ 4];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pY() += dForce[ 5];
                
             }
                                                      
             // Node 1, wrt z                         
                                                      
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pZ() += dForce[ 6];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pZ() += dForce[ 7];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pZ() += dForce[ 8];
   
             j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();
             
             // Node 2, wrt x
             
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pX() += dForce[ 9];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pX() += dForce[10];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pX() += dForce[11];
                                                      
             // Node 2, wrt y                         
                   
             if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                      
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pY() += dForce[12];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pY() += dForce[13];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pY() += dForce[14];
                
             }
                                                      
             // Node 2, wrt z                         
                                                      
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pZ() += dForce[15];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pZ() += dForce[16];
             VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pZ() += dForce[17];
             
          }
          
       }
          
    }
    
    // Need to add in body rotation terms
    
    int g;
    double OVec[3], RVec[3], TVec[3], pVelocity[3], pForce[3];
    double Omega, Angle;  
    QUAT Quat, InvQuat, Vec1, pVec1_pXYZC, Vec2, pVec2_pXYZC, BodyVelocity, WQuat;
    QUAT pBodyVelocity_pXYZC; 
       
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; i++ ) {
       
       // Only work on loops on surfaces we are calculating gradients for
       
       if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(MGLevel_).EdgeList(i).ComponentID()] ) {
           
          // For rotor cases we need to find inviscid partials wrt omega
          
          g = VSPGeom().Grid(MGLevel_).EdgeList(i).Group();
          
          if ( VSPGeom().ComponentGroupList(g).GeometryIsARotor() ) {
    
             OVec[0] = VSPGeom().ComponentGroupList(g).OVec(0); // Rotation origin
             OVec[1] = VSPGeom().ComponentGroupList(g).OVec(1);
             OVec[2] = VSPGeom().ComponentGroupList(g).OVec(2);
                                                   
             RVec[0] = VSPGeom().ComponentGroupList(g).RVec(0); // Rotation vector
             RVec[1] = VSPGeom().ComponentGroupList(g).RVec(1);
             RVec[2] = VSPGeom().ComponentGroupList(g).RVec(2);
                                                   
             TVec[0] = VSPGeom().ComponentGroupList(g).TVec(0); // Translation vector
             TVec[1] = VSPGeom().ComponentGroupList(g).TVec(1);
             TVec[2] = VSPGeom().ComponentGroupList(g).TVec(2);
             
             VSPGeom().ComponentGroupList(g).Update();
      
             Quat = VSPGeom().ComponentGroupList(g).Quat();
             
             InvQuat = VSPGeom().ComponentGroupList(g).InvQuat();
             
             WQuat = VSPGeom().ComponentGroupList(g).WQuat();
             
             // Calculate surface velocity for edge centroids
             
             Vec1(0) = VSPGeom().Grid(MGLevel_).EdgeList(i).Xc() - OVec[0];
             Vec1(1) = VSPGeom().Grid(MGLevel_).EdgeList(i).Yc() - OVec[1];
             Vec1(2) = VSPGeom().Grid(MGLevel_).EdgeList(i).Zc() - OVec[2];
             
             for ( p = 0 ; p <= 2 ; p++ ) {
             
                pVec1_pXYZC(0) = 0.;
                pVec1_pXYZC(1) = 0.;
                pVec1_pXYZC(2) = 0.;
                         
                pVec1_pXYZC(p) = 1.;
         
                // Body point location after rotation
                
                Vec2 = Quat * Vec1 * InvQuat;
                
                pVec2_pXYZC = Quat * pVec1_pXYZC * InvQuat;
   
                // Body point velocity
                
                BodyVelocity = WQuat * Vec2;
                
                pBodyVelocity_pXYZC = WQuat * pVec2_pXYZC;
                
                pVelocity[0] = -pBodyVelocity_pXYZC(0);
                pVelocity[1] = -pBodyVelocity_pXYZC(1);
                pVelocity[2] = -pBodyVelocity_pXYZC(2);
                
                VSPGeom().Grid(MGLevel_).EdgeList(i).CalculateForces_dVelocity(pVelocity, pForce);
                
                if ( p == 0 ) {
                   
                   // Node 1, wrt x
                                                                                                  
                   dForce[ 0] = 0.5*pForce[0];
                   dForce[ 1] = 0.5*pForce[1];
                   dForce[ 2] = 0.5*pForce[2];        
                                            
                   // Node 2, wrt x         
                                                                                               
                   dForce[ 9] = 0.5*pForce[0];
                   dForce[10] = 0.5*pForce[1];
                   dForce[11] = 0.5*pForce[2];     
                   
                }
                
                else if ( p == 1 ) {
                        
                   // Node 1, wrt y
                   
                   dForce[ 3] = 0.5*pForce[0]; 
                   dForce[ 4] = 0.5*pForce[1]; 
                   dForce[ 5] = 0.5*pForce[2];          
                                            
                   // Node 2, wrt y                                                                               
                                                                                                                  
                   dForce[12] = 0.5*pForce[0]; 
                   dForce[13] = 0.5*pForce[1];
                   dForce[14] = 0.5*pForce[2];         
                
                }         
                
                else if ( p == 2 ) {    
                
                   // Node 1, wrt z
                   
                   dForce[ 6] = 0.5*pForce[0];  
                   dForce[ 7] = 0.5*pForce[1];  
                   dForce[ 8] = 0.5*pForce[2];         
                                                                                                           
                   // Node 2, wrt z                                                                               
                                                                                                                  
                   dForce[15] = 0.5*pForce[0]; 
                   dForce[16] = 0.5*pForce[1];  
                   dForce[17] = 0.5*pForce[2];        
                   
                } 
                
             }
             
             // Moment arm
      
             dx = VSPGeom().Grid(MGLevel_).EdgeList(i).Xc() - XYZcg_[0];
             dy = VSPGeom().Grid(MGLevel_).EdgeList(i).Yc() - XYZcg_[1];
             dz = VSPGeom().Grid(MGLevel_).EdgeList(i).Zc() - XYZcg_[2];
   
             // Wake induced forces
             
             if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsWakeTrailingEdge() ) {
      
                j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
                
                // Node 1, wrt x
                
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pX() -= dForce[ 0];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pX() -= dForce[ 1];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pX() -= dForce[ 2];
                                                         
                // Node 1, wrt y     
                
                if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                         
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pY() -= dForce[ 3];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pY() -= dForce[ 4];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pY() -= dForce[ 5];
                   
                }
                                                         
                // Node 1, wrt z                         
                                                         
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pZ() -= dForce[ 6];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pZ() -= dForce[ 7];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pZ() -= dForce[ 8];
      
                j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();
                
                // Node 2, wrt x
                
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pX() -= dForce[ 9];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pX() -= dForce[10];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pX() -= dForce[11];
                                                         
                // Node 2, wrt y                         
                      
                if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                         
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pY() -= dForce[12];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pY() -= dForce[13];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pY() -= dForce[14];
                   
                }
                                                         
                // Node 2, wrt z                         
                                                         
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwx_pZ() -= dForce[15];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwy_pZ() -= dForce[16];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFwz_pZ() -= dForce[17];
                
             }
                
             // Calculate partials of force wrt 
      
             StallFactor = 1.;
             
             if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsTrailingEdge() ) StallFactor = VSPGeom().Grid(MGLevel_).EdgeList(i).TrailingEdgeStallFactor();
   
             dForce[ 0] *= StallFactor;
             dForce[ 1] *= StallFactor;
             dForce[ 2] *= StallFactor;
             dForce[ 3] *= StallFactor;
             dForce[ 4] *= StallFactor;
             dForce[ 5] *= StallFactor;
             dForce[ 6] *= StallFactor;
             dForce[ 7] *= StallFactor;
             dForce[ 8] *= StallFactor;
             dForce[ 9] *= StallFactor;
             dForce[10] *= StallFactor;
             dForce[11] *= StallFactor;
             dForce[12] *= StallFactor;
             dForce[13] *= StallFactor;
             dForce[14] *= StallFactor;
             dForce[15] *= StallFactor;
             dForce[16] *= StallFactor;
             dForce[17] *= StallFactor;
                                
             // Forces
      
                j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
                
                // Node 1, wrt x
                
                VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pX() += dForce[ 0];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pX() += dForce[ 1];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pX() += dForce[ 2];
                                                         
                // Node 1, wrt y     
                
                if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                         
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pY() += dForce[ 3];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pY() += dForce[ 4];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pY() += dForce[ 5];
                   
                }
                                                         
                // Node 1, wrt z                         
                                                         
                VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pZ() += dForce[ 6];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pZ() += dForce[ 7];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pZ() += dForce[ 8];
      
                j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();
                
                // Node 2, wrt x
                
                VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pX() += dForce[ 9];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pX() += dForce[10];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pX() += dForce[11];
                                                         
                // Node 2, wrt y                         
                      
                if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                         
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pY() += dForce[12];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pY() += dForce[13];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pY() += dForce[14];
                   
                }
                                                         
                // Node 2, wrt z                         
                                                         
                VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pZ() += dForce[15];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pZ() += dForce[16];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pZ() += dForce[17];
                
             // Moments
             
                j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
             
                // Node 1, wrt x
                
                VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pX() += dForce[ 2]*dy - dForce[ 1]*dz;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pX() += dForce[ 0]*dz - dForce[ 2]*dx;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pX() += dForce[ 1]*dx - dForce[ 0]*dy;
                                                                                                            
                // Node 1, wrt y                                                                            
                      
                if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                                                                            
                   VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pY() += dForce[ 5]*dy - dForce[ 4]*dz;
                   VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pY() += dForce[ 3]*dz - dForce[ 5]*dx;             
                   VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pY() += dForce[ 4]*dx - dForce[ 3]*dy;
                   
                }
                                                                                                            
                // Node 1, wrt z                                                                            
                                                                                                            
                VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pZ() += dForce[ 8]*dy - dForce[ 7]*dz;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pZ() += dForce[ 6]*dz - dForce[ 8]*dx;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pZ() += dForce[ 7]*dx - dForce[ 6]*dy;                 
      
                j = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();
      
                // Node 2, wrt x
                
                VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pX() += dForce[11]*dy - dForce[10]*dz;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pX() += dForce[ 9]*dz - dForce[11]*dx;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pX() += dForce[10]*dx - dForce[ 9]*dy;
                                                                 
                // Node 2, wrt y                      
                          
                if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                                                      
                   VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pY() += dForce[14]*dy - dForce[13]*dz;
                   VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pY() += dForce[12]*dz - dForce[14]*dx;
                   VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pY() += dForce[13]*dx - dForce[12]*dy;
                   
                }
                                                           
                // Node 2, wrt z                       
                                                        
                VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pZ() += dForce[17]*dy - dForce[16]*dz;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pZ() += dForce[15]*dz - dForce[17]*dx;
                VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pZ() += dForce[16]*dx - dForce[15]*dy;     
                
          }
          
       }
             
    }    
    
    // Now add in the unsteady terms for a time accurate solution
 
    if ( TimeAccurate_ ) {
       
       int Found;
   
       double KuttaWeight;

       for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; Loop++ ) {

          // Only work on loops on surfaces we are calculating gradients for
          
          if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(MGLevel_).LoopList(Loop).ComponentID()] ) {
           
             KuttaWeight = 0.;
             
             for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; i++ ) {
                
                Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(i);
                
                if ( !VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) {
                   
                   KuttaWeight += 1.;
                   
                }
                
             }
                
             KuttaWeight /= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges(); 
   
             //DGammaDt = ( 3.*Gamma(Loop) - 4.*GammaNM1(Loop) + GammaNM2(Loop) ) / (2.*DeltaTime_);
             //
             //if ( Time_ <= 2 ) DGammaDt = ( Gamma(Loop) - GammaNM1(Loop) )/DeltaTime_;
             
             DGammaDt = ( Gamma(Loop) - GammaNM1(Loop) )/DeltaTime_;
             
             DeltaPressure = -DGammaDt;
   
             NormalGradients = new double[9*VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() + 1];
             
             AreaGradients = new double[3*VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() + 1];
   
             CalculateLoopNormalGradients_wrt_Mesh(MGLevel_, Loop, NormalGradients, AreaGradients);
        
             Force[0]     = -KuttaWeight * DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nx();
             Force[1]     = -KuttaWeight * DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Ny();
             Force[2]     = -KuttaWeight * DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nz();
                           
             dFx_dA       = -KuttaWeight * DeltaPressure                                                  * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nx();
             dFy_dA       = -KuttaWeight * DeltaPressure                                                  * VSPGeom().Grid(MGLevel_).LoopList(Loop).Ny();
             dFz_dA       = -KuttaWeight * DeltaPressure                                                  * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nz();
                           
             dFx_dNormalX = -KuttaWeight * DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
             dFy_dNormalY = -KuttaWeight * DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
             dFz_dNormalZ = -KuttaWeight * DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area(); 
   
             // Loop over nodes and calculate partials wrt xyz of forces
             
             for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() ; p++ ) {
                
                j = VSPGeom().Grid(MGLevel_).LoopList(Loop).Node(p);
   
                // wrt X
                
                dForce[0] = dFx_dA * AreaGradients[3*p-2] + dFx_dNormalX * NormalGradients[9*p - 8];
                dForce[1] = dFy_dA * AreaGradients[3*p-2] + dFy_dNormalY * NormalGradients[9*p - 5];
                dForce[2] = dFz_dA * AreaGradients[3*p-2] + dFz_dNormalZ * NormalGradients[9*p - 2];
      
                VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pX() += dForce[0];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pX() += dForce[1];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pX() += dForce[2];
                    
                // wrt Y
                
                if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                
                   dForce[0] = dFx_dA * AreaGradients[3*p-1] + dFx_dNormalX * NormalGradients[9*p - 7];
                   dForce[1] = dFy_dA * AreaGradients[3*p-1] + dFy_dNormalY * NormalGradients[9*p - 4];
                   dForce[2] = dFz_dA * AreaGradients[3*p-1] + dFz_dNormalZ * NormalGradients[9*p - 1];
      
                   // Delta forces... 
          
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pY() += dForce[0];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pY() += dForce[1];
                   VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pY() += dForce[2];  
                
                }
                
                // wrt Z
                
                dForce[0] = dFx_dA * AreaGradients[3*p  ] + dFx_dNormalX * NormalGradients[9*p - 6];
                dForce[1] = dFy_dA * AreaGradients[3*p  ] + dFy_dNormalY * NormalGradients[9*p - 3];
                dForce[2] = dFz_dA * AreaGradients[3*p  ] + dFz_dNormalZ * NormalGradients[9*p    ];
      
                // Delta forces... 
                
                VSPGeom().Grid(MGLevel_).NodeList(j).pFix_pZ() += dForce[0];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiy_pZ() += dForce[1];
                VSPGeom().Grid(MGLevel_).NodeList(j).pFiz_pZ() += dForce[2]; 
                      
             }
                      
             // Moments use total 1/( number of edges for this loop ) fraction of force per edge...
   
             Force[0]     = -( DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nx() )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
             Force[1]     = -( DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Ny() )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
             Force[2]     = -( DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nz() )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
                                                                                                            
             dFx_dA       = -( DeltaPressure                                                  * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nx() )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
             dFy_dA       = -( DeltaPressure                                                  * VSPGeom().Grid(MGLevel_).LoopList(Loop).Ny() )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
             dFz_dA       = -( DeltaPressure                                                  * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nz() )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
                                                                                                              
             dFx_dNormalX = -( DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area()                                                )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
             dFy_dNormalY = -( DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area()                                                )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
             dFz_dNormalZ = -( DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area()                                                )/VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges();
   
             // Now the partials of the moments
                       
             for ( p = 1 ; p <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() ; p++ ) {
                
                j = VSPGeom().Grid(MGLevel_).LoopList(Loop).Node(p);
                
                for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; i++ ) {
                   
                   Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(i);
                   
                   if ( !VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) {
                                
                      dx = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - XYZcg_[0];
                      dy = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - XYZcg_[1];
                      dz = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - XYZcg_[2];
       
                      // wrt X
                      
                      dForce[0] = ( dFx_dA * AreaGradients[3*p-2] + dFx_dNormalX * NormalGradients[9*p - 8] );
                      dForce[1] = ( dFy_dA * AreaGradients[3*p-2] + dFy_dNormalY * NormalGradients[9*p - 5] );
                      dForce[2] = ( dFz_dA * AreaGradients[3*p-2] + dFz_dNormalZ * NormalGradients[9*p - 2] );
   
                      // Delta moments
                      
                      VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pX() += dForce[2]*dy - dForce[1]*dz;
                      VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pX() += dForce[0]*dz - dForce[2]*dx;
                      VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pX() += dForce[1]*dx - dForce[0]*dy;
   
                      // wrt Y
                      
                      if ( !VSPGeom().Grid(MGLevel_).NodeList(j).IsSymmetryPlaneNode() ) {                    
                      
                         dForce[0] = ( dFx_dA * AreaGradients[3*p-1] + dFx_dNormalX * NormalGradients[9*p - 7] );
                         dForce[1] = ( dFy_dA * AreaGradients[3*p-1] + dFy_dNormalY * NormalGradients[9*p - 4] );
                         dForce[2] = ( dFz_dA * AreaGradients[3*p-1] + dFz_dNormalZ * NormalGradients[9*p - 1] );
         
                         // Delta moments
   
                         VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pY() += dForce[2]*dy - dForce[1]*dz;
                         VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pY() += dForce[0]*dz - dForce[2]*dx;             
                         VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pY() += dForce[1]*dx - dForce[0]*dy;
         
                      }
                      
                      // wrt Z
                      
                      dForce[0] = ( dFx_dA * AreaGradients[3*p  ] + dFx_dNormalX * NormalGradients[9*p - 6] );
                      dForce[1] = ( dFy_dA * AreaGradients[3*p  ] + dFy_dNormalY * NormalGradients[9*p - 3] );
                      dForce[2] = ( dFz_dA * AreaGradients[3*p  ] + dFz_dNormalZ * NormalGradients[9*p    ] );
    
                      // Delta moments
   
                      VSPGeom().Grid(MGLevel_).NodeList(j).pMix_pZ() += dForce[2]*dy - dForce[1]*dz;
                      VSPGeom().Grid(MGLevel_).NodeList(j).pMiy_pZ() += dForce[0]*dz - dForce[2]*dx;
                      VSPGeom().Grid(MGLevel_).NodeList(j).pMiz_pZ() += dForce[1]*dx - dForce[0]*dy;  
   
                   }
                   
                }
                
             }
    
             delete [] NormalGradients;          
             delete [] AreaGradients;                 
             
          }
          
       }
          
    }
    
    // Free up memory
    
    delete [] MG_OffSet;
    delete [] pF_pMesh;           
    delete [] pM_pMesh;           
    delete [] pFw_pMesh;
      
}

/*##############################################################################
#                                                                              #
#             VSP_SOLVER CalculateForceGradients_wrt_StallFactor               #
#                                                                              #
# F = rho * V x (Gamma * L) * K                                                #
# pF_pK = rho * pV_pK x ( Gamma * L ) + rho * V x Gamma x L                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateForceGradients_wrt_StallFactor(void)
{

    int i, j, k, MaxLoopTypes, LoopType, iLevel, iEdge, jLevel, Sign;
    int *MG_OffSet, ArraySize, LoopL, LoopR, Level, LoopC, LoopF, Edge;
    int KuttaLoop1, KuttaLoop2, iLoop, Loop, KuttaStallEquation;
    double q[3], qw[3], Forces[3], Moments[3], WakeForces[3], xyz[3], qs[3], Fact, dx, dy, dz;
    double *pF_pStall, *pM_pStall, *pFw_pStall, dGamma;
    VSP_EDGE *VortexEdge, TempEdge;

    // Update the edge velocities
    
    CalculateEdgeVelocities();

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];

    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + 3*VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt mesh accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    pF_pStall = new double[ArraySize];

    pM_pStall = new double[ArraySize];

    pFw_pStall = new double[ArraySize];
    
    zero_double_array(pF_pStall, ArraySize-1);

    zero_double_array(pM_pStall, ArraySize-1);

    zero_double_array(pFw_pStall, ArraySize-1);

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {

          VSPGeom().VortexSheet(k).TrailingVortex(i).pFx_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFy_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFz_pStallFactor() = 0.;
                                                                      
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor() = 0.;

          VSPGeom().VortexSheet(k).TrailingVortex(i).pFwx_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFwy_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFwz_pStallFactor() = 0.;

       }
       
    }
              
    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {
#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:pF_pStall[:ArraySize],pM_pStall[:ArraySize],pFw_pStall[:ArraySize]) private(iLevel,iEdge,j,jLevel,VortexEdge,q,Forces,Moments,LoopL,LoopR,xyz,qs,qw,WakeForces) schedule(dynamic)           
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
 
          iLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          iEdge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();
          
          if ( VSPGeom().Grid(iLevel).EdgeList(iEdge).SurfaceID() > 0 ) {

             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
   
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
   
                VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c(), q);
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[2];
                   
                   VortexEdge->pVelocity_pGamma(xyz, qs);
                   
                   q[0] += qs[0];
                   q[1] -= qs[1];
                   q[2] += qs[2];
   
                }                
                
                qw[0] = qw[1] = qw[2] = 0.;
     
                if ( VortexEdge->SurfaceID() == 0 ) {
                   
                   qw[0] = q[0];
                   qw[1] = q[1];
                   qw[2] = q[2];
  
                   CalculateAdjointForceGradient(iLevel, iEdge, q, 1., Forces, Moments, qw, WakeForces, 1);
   
                   LoopL = VortexEdge->LoopL();
                   
                   LoopR = VortexEdge->LoopR();
                   
                   if ( LoopL > 0 ) {
                      
                      pF_pStall[3*LoopL - 2 + MG_OffSet[jLevel]] +=  Forces[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                      pF_pStall[3*LoopL - 1 + MG_OffSet[jLevel]] +=  Forces[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                      pF_pStall[3*LoopL     + MG_OffSet[jLevel]] +=  Forces[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();   
   
                      pM_pStall[3*LoopL - 2 + MG_OffSet[jLevel]] += Moments[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                      pM_pStall[3*LoopL - 1 + MG_OffSet[jLevel]] += Moments[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                      pM_pStall[3*LoopL     + MG_OffSet[jLevel]] += Moments[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();   

                      pFw_pStall[3*LoopL - 2 + MG_OffSet[jLevel]] += WakeForces[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                      pFw_pStall[3*LoopL - 1 + MG_OffSet[jLevel]] += WakeForces[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();
                      pFw_pStall[3*LoopL     + MG_OffSet[jLevel]] += WakeForces[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopL).VortexStretchingRatio();   

                   }  
   
                   if ( LoopR > 0 ) {
                      
                      pF_pStall[3*LoopR - 2 + MG_OffSet[jLevel]] -=  Forces[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                      pF_pStall[3*LoopR - 1 + MG_OffSet[jLevel]] -=  Forces[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                      pF_pStall[3*LoopR     + MG_OffSet[jLevel]] -=  Forces[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();   
   
                      pM_pStall[3*LoopR - 2 + MG_OffSet[jLevel]] -= Moments[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                      pM_pStall[3*LoopR - 1 + MG_OffSet[jLevel]] -= Moments[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                      pM_pStall[3*LoopR     + MG_OffSet[jLevel]] -= Moments[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();

                      pFw_pStall[3*LoopR - 2 + MG_OffSet[jLevel]] -= WakeForces[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                      pFw_pStall[3*LoopR - 1 + MG_OffSet[jLevel]] -= WakeForces[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();
                      pFw_pStall[3*LoopR     + MG_OffSet[jLevel]] -= WakeForces[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma() * VSPGeom().Grid(jLevel).LoopList(LoopR).VortexStretchingRatio();   
                                         
                   }  
                   
                }
                                   
             }
             
          }
             
       }   
       
    } 
    
    // Prolongate
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();
          
          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             // Forces
             
             pF_pStall[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pF_pStall[3*LoopC - 2 + MG_OffSet[Level]];
             pF_pStall[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pF_pStall[3*LoopC - 1 + MG_OffSet[Level]];
             pF_pStall[3*LoopF     + MG_OffSet[Level-1]] += Fact * pF_pStall[3*LoopC     + MG_OffSet[Level]];
             
             // Moments
             
             pM_pStall[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pM_pStall[3*LoopC - 2 + MG_OffSet[Level]];
             pM_pStall[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pM_pStall[3*LoopC - 1 + MG_OffSet[Level]];
             pM_pStall[3*LoopF     + MG_OffSet[Level-1]] += Fact * pM_pStall[3*LoopC     + MG_OffSet[Level]];             

             // Wake induced forces
             
             pFw_pStall[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pFw_pStall[3*LoopC - 2 + MG_OffSet[Level]];
             pFw_pStall[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pFw_pStall[3*LoopC - 1 + MG_OffSet[Level]];
             pFw_pStall[3*LoopF     + MG_OffSet[Level-1]] += Fact * pFw_pStall[3*LoopC     + MG_OffSet[Level]];

          }
          
       }
       
    }

    // Redistribute the terms that were calculate for the wake loops... these need to be split over the corresponding
    // Kutta edge loops...

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {

          // Wake loop
                       
          iLoop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
         
          // Trailing edge for this loop
          
          Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
          
          // Sign
          
          Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());

          // Loops attached to trailing edge

          KuttaLoop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
          
          KuttaLoop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();

          if ( KuttaLoop1 > 0 ) {
             
             // Forces
             
             pF_pStall[3*KuttaLoop1 - 2 + MG_OffSet[MGLevel_]] += pF_pStall[3*iLoop - 2 + MG_OffSet[MGLevel_]];
             pF_pStall[3*KuttaLoop1 - 1 + MG_OffSet[MGLevel_]] += pF_pStall[3*iLoop - 1 + MG_OffSet[MGLevel_]];
             pF_pStall[3*KuttaLoop1     + MG_OffSet[MGLevel_]] += pF_pStall[3*iLoop     + MG_OffSet[MGLevel_]];
                                                                 
             // Moments                                          
                                                                 
             pM_pStall[3*KuttaLoop1 - 2 + MG_OffSet[MGLevel_]] += pM_pStall[3*iLoop - 2 + MG_OffSet[MGLevel_]];
             pM_pStall[3*KuttaLoop1 - 1 + MG_OffSet[MGLevel_]] += pM_pStall[3*iLoop - 1 + MG_OffSet[MGLevel_]];
             pM_pStall[3*KuttaLoop1     + MG_OffSet[MGLevel_]] += pM_pStall[3*iLoop     + MG_OffSet[MGLevel_]];      

             // Wake induced forces
             
             pFw_pStall[3*KuttaLoop1 - 2 + MG_OffSet[MGLevel_]] += pFw_pStall[3*iLoop - 2 + MG_OffSet[MGLevel_]];
             pFw_pStall[3*KuttaLoop1 - 1 + MG_OffSet[MGLevel_]] += pFw_pStall[3*iLoop - 1 + MG_OffSet[MGLevel_]];
             pFw_pStall[3*KuttaLoop1     + MG_OffSet[MGLevel_]] += pFw_pStall[3*iLoop     + MG_OffSet[MGLevel_]];
                                                                 
          }                                                      
                                                                 
          if ( KuttaLoop2 > 0 ) {                                
                                           
             // Forces                                           
                                                                 
             pF_pStall[3*KuttaLoop2 - 2 + MG_OffSet[MGLevel_]] += pF_pStall[3*iLoop - 2 + MG_OffSet[MGLevel_]];
             pF_pStall[3*KuttaLoop2 - 1 + MG_OffSet[MGLevel_]] += pF_pStall[3*iLoop - 1 + MG_OffSet[MGLevel_]];
             pF_pStall[3*KuttaLoop2     + MG_OffSet[MGLevel_]] += pF_pStall[3*iLoop     + MG_OffSet[MGLevel_]];
                                                              
             // Moments                                       
                                                              
             pM_pStall[3*KuttaLoop2 - 2 + MG_OffSet[MGLevel_]] += pM_pStall[3*iLoop - 2 + MG_OffSet[MGLevel_]];
             pM_pStall[3*KuttaLoop2 - 1 + MG_OffSet[MGLevel_]] += pM_pStall[3*iLoop - 1 + MG_OffSet[MGLevel_]];
             pM_pStall[3*KuttaLoop2     + MG_OffSet[MGLevel_]] += pM_pStall[3*iLoop     + MG_OffSet[MGLevel_]];     

             // Wake induced forces                                           
                                                                 
             pFw_pStall[3*KuttaLoop2 - 2 + MG_OffSet[MGLevel_]] += pFw_pStall[3*iLoop - 2 + MG_OffSet[MGLevel_]];
             pFw_pStall[3*KuttaLoop2 - 1 + MG_OffSet[MGLevel_]] += pFw_pStall[3*iLoop - 1 + MG_OffSet[MGLevel_]];
             pFw_pStall[3*KuttaLoop2     + MG_OffSet[MGLevel_]] += pFw_pStall[3*iLoop     + MG_OffSet[MGLevel_]];
          
          }
          
       }

    }

    // Copy over results

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {

          // Trailing edge for this loop
          
          Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());

          // Sign
          
          Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());

          // Loops attached to trailing edge

          KuttaLoop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
          
          KuttaLoop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();
                    
          if ( KuttaLoop1 > 0 ) {
                       
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFx_pStallFactor() = pF_pStall[3*KuttaLoop1 - 2 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFy_pStallFactor() = pF_pStall[3*KuttaLoop1 - 1 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFz_pStallFactor() = pF_pStall[3*KuttaLoop1     + MG_OffSet[MGLevel_]];
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor() = pM_pStall[3*KuttaLoop1 - 2 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor() = pM_pStall[3*KuttaLoop1 - 1 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor() = pM_pStall[3*KuttaLoop1     + MG_OffSet[MGLevel_]];

             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwx_pStallFactor() = pFw_pStall[3*KuttaLoop1 - 2 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwy_pStallFactor() = pFw_pStall[3*KuttaLoop1 - 1 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwz_pStallFactor() = pFw_pStall[3*KuttaLoop1     + MG_OffSet[MGLevel_]];
             
          }

          if ( KuttaLoop2 > 0 ) {
                       
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFx_pStallFactor() = pF_pStall[3*KuttaLoop2 - 2 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFy_pStallFactor() = pF_pStall[3*KuttaLoop2 - 1 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFz_pStallFactor() = pF_pStall[3*KuttaLoop2     + MG_OffSet[MGLevel_]];
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor() = pM_pStall[3*KuttaLoop2 - 2 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor() = pM_pStall[3*KuttaLoop2 - 1 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor() = pM_pStall[3*KuttaLoop2     + MG_OffSet[MGLevel_]];

             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwx_pStallFactor() = pFw_pStall[3*KuttaLoop2 - 2 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwy_pStallFactor() = pFw_pStall[3*KuttaLoop2 - 1 + MG_OffSet[MGLevel_]];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwz_pStallFactor() = pFw_pStall[3*KuttaLoop2     + MG_OffSet[MGLevel_]];
             
          }
                    
       }
       
    }
 
    // Now add in the simple partial term... ie, the V part of V*(1-K)*Gamma... for the trailing edge edges
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());

          // Only work on loops on surfaces we are calculating gradients for
          
          if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(MGLevel_).EdgeList(Edge).ComponentID()] ) {
           
             LoopL = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
      
             LoopR = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();
             
             dGamma = VSPGeom().Grid(MGLevel_).LoopList(LoopL).Gamma()
                    - VSPGeom().Grid(MGLevel_).LoopList(LoopR).Gamma();
                          
             dx = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - XYZcg_[0];
             dy = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - XYZcg_[1];
             dz = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - XYZcg_[2];
             
             VSPGeom().Grid(MGLevel_).EdgeList(Edge).CalculateForces_dGamma(Forces);
             
             Forces[0] *= -dGamma;
             Forces[1] *= -dGamma;
             Forces[2] *= -dGamma;
      
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFx_pStallFactor() += Forces[0];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFy_pStallFactor() += Forces[1];
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFz_pStallFactor() += Forces[2];
   
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor() += Forces[2]*dy - Forces[1]*dz;
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor() += Forces[0]*dz - Forces[2]*dx;
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor() += Forces[1]*dx - Forces[0]*dy;
             
          }

       }
       
    }
       
    delete [] MG_OffSet;
    delete [] pF_pStall;
    delete [] pM_pStall;
    delete [] pFw_pStall;
    

}

/*##############################################################################
#                                                                              #
#       VSP_SOLVER CalculateForceGradients_wrt_VortexStretchingFactor          #
#                                                                              #
# F = rho * V x (Gamma * L) * R                                                #
# pF_pR = rho * pV_pR x ( Gamma * L ) + rho * V x Gamma x L                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateForceGradients_wrt_VortexStretchingFactor(void)
{

    int i, j, k, MaxLoopTypes, LoopType, iLevel, iEdge, jLevel, Sign;
    int *MG_OffSet, ArraySize, LoopL, LoopR, Level, LoopC, LoopF, Edge;
    int KuttaLoop1, KuttaLoop2, iLoop;
    double q[3], qw[3], Forces[3], Moments[3], WakeForces[3], xyz[3], qs[3], Fact, dx, dy, dz;
    double *pF_pRatio, *pM_pRatio, *pFw_pRatio, StallFactor, dGamma;
    VSP_EDGE *VortexEdge, TempEdge;

    // Update the edge velocities
    
    CalculateEdgeVelocities();

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + 3*VSPGeom().Grid(i-1).NumberOfLoops();
       
    }
    
    // Partial wrt mesh accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    pF_pRatio = new double[ArraySize];

    pM_pRatio = new double[ArraySize];
    
    pFw_pRatio = new double[ArraySize];
    
    zero_double_array(pF_pRatio, ArraySize-1);

    zero_double_array(pM_pRatio, ArraySize-1);

    zero_double_array(pFw_pRatio, ArraySize-1);
          
    // Zero out force partials
    
    for ( iLevel = 0 ; iLevel <= NumberOfMGLevels_ ; iLevel++ ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(iLevel).NumberOfLoops() ; i++ ) {
          
          VSPGeom().Grid(iLevel).LoopList(i).pFx_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFy_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFz_pRatio() = 0.;
                                               
          VSPGeom().Grid(iLevel).LoopList(i).pMx_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pMy_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pMz_pRatio() = 0.;

          VSPGeom().Grid(iLevel).LoopList(i).pFxo_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFyo_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFzo_pRatio() = 0.;
                                              
          VSPGeom().Grid(iLevel).LoopList(i).pMxo_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pMyo_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pMzo_pRatio() = 0.;        
          
          VSPGeom().Grid(iLevel).LoopList(i).pFiwx_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFiwy_pRatio() = 0.;
          VSPGeom().Grid(iLevel).LoopList(i).pFiwz_pRatio() = 0.;            
       }
       
    }

    MaxLoopTypes = 0;

    // Surface vortex induced gamma perturbation velocities across all the loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {
#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:pF_pRatio[:ArraySize],pM_pRatio[:ArraySize],pFw_pRatio[:ArraySize]) private(iLevel,iEdge,j,jLevel,VortexEdge,q,Forces,Moments,LoopL,LoopR,xyz,qs,qw,WakeForces) schedule(dynamic)           
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
 
          iLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          iEdge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();
          
          if ( VSPGeom().Grid(iLevel).EdgeList(iEdge).SurfaceID() > 0 ) {

             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
   
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
      
                VortexEdge->pVelocity_pGamma(VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c(), q);
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(iLevel).EdgeList(iEdge).xyz_c()[2];
                   
                   VortexEdge->pVelocity_pGamma(xyz, qs);
                   
                   q[0] += qs[0];
                   q[1] -= qs[1];
                   q[2] += qs[2];
                   
                }          
                
                qw[0] = qw[1] = qw[2] = 0.;
                
                if ( VortexEdge->SurfaceID() == 0 ) {
                   
                   qw[0] = q[0];
                   qw[1] = q[1];
                   qw[2] = q[2];
                   
                }
                           
                CalculateAdjointForceGradient(iLevel, iEdge, q, 1., Forces, Moments, qw, WakeForces, 1);

                LoopL = VortexEdge->LoopL();
                
                LoopR = VortexEdge->LoopR();
                
                if ( LoopL > 0 ) {
                   
                   pF_pRatio[3*LoopL - 2 + MG_OffSet[jLevel]] +=  Forces[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();
                   pF_pRatio[3*LoopL - 1 + MG_OffSet[jLevel]] +=  Forces[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();
                   pF_pRatio[3*LoopL     + MG_OffSet[jLevel]] +=  Forces[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();   
                      
                   pM_pRatio[3*LoopL - 2 + MG_OffSet[jLevel]] += Moments[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();
                   pM_pRatio[3*LoopL - 1 + MG_OffSet[jLevel]] += Moments[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();
                   pM_pRatio[3*LoopL     + MG_OffSet[jLevel]] += Moments[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();   

                   pFw_pRatio[3*LoopL - 2 + MG_OffSet[jLevel]] += WakeForces[0] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();
                   pFw_pRatio[3*LoopL - 1 + MG_OffSet[jLevel]] += WakeForces[1] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();
                   pFw_pRatio[3*LoopL     + MG_OffSet[jLevel]] += WakeForces[2] * VSPGeom().Grid(jLevel).LoopList(LoopL).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopL).Gamma();   

                }  

                if ( LoopR > 0 ) {
                   
                   pF_pRatio[3*LoopR - 2 + MG_OffSet[jLevel]] -=  Forces[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma();
                   pF_pRatio[3*LoopR - 1 + MG_OffSet[jLevel]] -=  Forces[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma();
                   pF_pRatio[3*LoopR     + MG_OffSet[jLevel]] -=  Forces[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma();  
                       
                   pM_pRatio[3*LoopR - 2 + MG_OffSet[jLevel]] -= Moments[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma();
                   pM_pRatio[3*LoopR - 1 + MG_OffSet[jLevel]] -= Moments[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma();
                   pM_pRatio[3*LoopR     + MG_OffSet[jLevel]] -= Moments[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma(); 

                   pFw_pRatio[3*LoopR - 2 + MG_OffSet[jLevel]] -= WakeForces[0] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma();
                   pFw_pRatio[3*LoopR - 1 + MG_OffSet[jLevel]] -= WakeForces[1] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma();
                   pFw_pRatio[3*LoopR     + MG_OffSet[jLevel]] -= WakeForces[2] * VSPGeom().Grid(jLevel).LoopList(LoopR).StallFactor() * VSPGeom().Grid(jLevel).LoopList(LoopR).Gamma();  
                                                      
                }  
                               
             }
             
          }
             
       }   
       
    } 
    
    // Prolongate
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( LoopC = 1 ; LoopC <= VSPGeom().Grid(Level).NumberOfLoops() ; LoopC++ ) {
 
          Fact = 1./VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops();
          
          for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(LoopC).NumberOfFineGridLoops() ; i++ ) {
             
             LoopF = VSPGeom().Grid(Level).LoopList(LoopC).FineGridLoop(i);

             // Forces
             
             pF_pRatio[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pF_pRatio[3*LoopC - 2 + MG_OffSet[Level]];
             pF_pRatio[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pF_pRatio[3*LoopC - 1 + MG_OffSet[Level]];
             pF_pRatio[3*LoopF     + MG_OffSet[Level-1]] += Fact * pF_pRatio[3*LoopC     + MG_OffSet[Level]];
                                                                      
             // Moments                                               
                                                                      
             pM_pRatio[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pM_pRatio[3*LoopC - 2 + MG_OffSet[Level]];
             pM_pRatio[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pM_pRatio[3*LoopC - 1 + MG_OffSet[Level]];
             pM_pRatio[3*LoopF     + MG_OffSet[Level-1]] += Fact * pM_pRatio[3*LoopC     + MG_OffSet[Level]];             

             // Wake induced forces
             
             pFw_pRatio[3*LoopF - 2 + MG_OffSet[Level-1]] += Fact * pF_pRatio[3*LoopC - 2 + MG_OffSet[Level]];
             pFw_pRatio[3*LoopF - 1 + MG_OffSet[Level-1]] += Fact * pF_pRatio[3*LoopC - 1 + MG_OffSet[Level]];
             pFw_pRatio[3*LoopF     + MG_OffSet[Level-1]] += Fact * pF_pRatio[3*LoopC     + MG_OffSet[Level]];
                         
          }
          
       }
       
    }

    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       // Forces
       
       VSPGeom().Grid(MGLevel_).LoopList(i).pFx_pRatio() = pF_pRatio[3*i - 2 + MG_OffSet[MGLevel_]];
       VSPGeom().Grid(MGLevel_).LoopList(i).pFy_pRatio() = pF_pRatio[3*i - 1 + MG_OffSet[MGLevel_]]; 
       VSPGeom().Grid(MGLevel_).LoopList(i).pFz_pRatio() = pF_pRatio[3*i     + MG_OffSet[MGLevel_]]; 
                                                      
       // Moments                                     
                                                      
       VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pRatio() = pM_pRatio[3*i - 2 + MG_OffSet[MGLevel_]];
       VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pRatio() = pM_pRatio[3*i - 1 + MG_OffSet[MGLevel_]]; 
       VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pRatio() = pM_pRatio[3*i     + MG_OffSet[MGLevel_]]; 

       // Wake induced forces
       
       VSPGeom().Grid(MGLevel_).LoopList(i).pFiwx_pRatio() = pFw_pRatio[3*i - 2 + MG_OffSet[MGLevel_]];
       VSPGeom().Grid(MGLevel_).LoopList(i).pFiwy_pRatio() = pFw_pRatio[3*i - 1 + MG_OffSet[MGLevel_]]; 
       VSPGeom().Grid(MGLevel_).LoopList(i).pFiwz_pRatio() = pFw_pRatio[3*i     + MG_OffSet[MGLevel_]]; 
                                                           
    }
        
    // Redistribute the terms that were calculate for the wake loops... these need to be split over the corresponding
    // Kutta edge loops...

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {

          // Wake loop
                       
          iLoop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
         
          // Trailing edge for this loop
          
          Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
          
          // Sign
          
          Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());

          // Loops attached to trailing edge

          KuttaLoop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
          
          KuttaLoop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopR();
   
          if ( !TimeAccurate_ || ( TimeAccurate_ && VSPGeom().Grid(MGLevel_).LoopList(iLoop).MinValidTimeStep() == 1 ) ) {
             
             if ( KuttaLoop1 > 0 ) {
                
                // Forces
             
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFx_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFx_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFy_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFy_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFz_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFz_pRatio();
                                                                                                                
                // Moments                                                                                                 
                                                                                                                           
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pMx_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMx_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pMy_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMy_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pMz_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMz_pRatio();

                // Wake induced forces
             
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFiwx_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFiwx_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFiwy_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFiwy_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop1).pFiwz_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFiwz_pRatio();
                                                                                                   
             }                                                        
                                                                      
             if ( KuttaLoop2 > 0 ) {                               
                                                                   
                // Forces                                          
                                                                   
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFx_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFx_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFy_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFy_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFz_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFz_pRatio();
                                                                                                                         
                // Moments                                                                                               
                                                                                                                         
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pMx_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMx_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pMy_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMy_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pMz_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMz_pRatio();

                // Wake induced forces                                          
                                                                   
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFiwx_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFiwx_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFiwy_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFiwy_pRatio();
                VSPGeom().Grid(MGLevel_).LoopList(KuttaLoop2).pFiwz_pRatio() += VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFiwz_pRatio();
                                                     
             }
             
          }

       }

    }

    if ( DoSymmetryPlaneSolve_ ) {
       
       for ( iLoop = 1 ; iLoop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; iLoop++ ) {
     
          // Forces
          
          VSPGeom().Grid(MGLevel_).LoopList(iLoop).pFy_pRatio() = 0.;
                                                       
          // Moments                                   
                                                       
          VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMx_pRatio() = 0.;
          VSPGeom().Grid(MGLevel_).LoopList(iLoop).pMz_pRatio() = 0.;
    
       }
       
    }
    
    delete [] MG_OffSet;
    delete [] pF_pRatio;               
    delete [] pM_pRatio;
    
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CalculateViscousForceGradients                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateViscousForceGradients(void) 
{

    int i, j, k, c, g, p, Node1, Node2, Edge, LE_Edge, TE_Edge, LoopL, LoopR;
    int LE_Node1, LE_Node2, TE_Node1, TE_Node2;
    double Wgt1, Wgt2, StallFactor, StallBumpFactor, VLE, VTE, Velocity, Sign;
    double CA, SA, CB, SB, Fx, Fy, Fz, Mx, My, Mz;
    double ComponentCg[3];
    double Chord, Span, Cl, Gamma, RVec[3], SVec[3], Re, Cf, Cfi, pCf_pCl2;
    
    double u, v, w;
     
    double dSVecX_dXcLE;
    double dSVecX_dYcLE;
    double dSVecX_dZcLE;
              
    double dSVecY_dXcLE;
    double dSVecY_dYcLE;
    double dSVecY_dZcLE;
              
    double dSVecZ_dXcLE;
    double dSVecZ_dYcLE;
    double dSVecZ_dZcLE;
             
    double dSVecX_dXcTE;
    double dSVecX_dYcTE;
    double dSVecX_dZcTE;
              
    double dSVecY_dXcTE;
    double dSVecY_dYcTE;
    double dSVecY_dZcTE;
              
    double dSVecZ_dXcTE;
    double dSVecZ_dYcTE;
    double dSVecZ_dZcTE;

    double dChord_dXcLE; 
    double dChord_dYcLE;
    double dChord_dZcLE;
                    
    double dChord_dXcTE;
    double dChord_dYcTE;
    double dChord_dZcTE;    

    double dVecX_dXcLE;
    double dVecX_dYcLE;
    double dVecX_dZcLE;
                          
    double dVecY_dXcLE;
    double dVecY_dYcLE;
    double dVecY_dZcLE;
                          
    double dVecZ_dXcLE;
    double dVecZ_dYcLE;
    double dVecZ_dZcLE;
                          
    double dVecX_dXcTE;
    double dVecX_dYcTE;
    double dVecX_dZcTE;
                          
    double dVecY_dXcTE;
    double dVecY_dYcTE;
    double dVecY_dZcTE;
                          
    double dVecZ_dXcTE;
    double dVecZ_dYcTE;
    double dVecZ_dZcTE; 

    double dLength_dX1; 
    double dLength_dY1;
    double dLength_dZ1;
                          
    double dLength_dX2;
    double dLength_dY2;
    double dLength_dZ2;
     
    double dVecX_dX1;
    double dVecX_dY1;
    double dVecX_dZ1;
                            
    double dVecY_dX1;
    double dVecY_dY1;
    double dVecY_dZ1;
                            
    double dVecZ_dX1;
    double dVecZ_dY1;
    double dVecZ_dZ1;
                            
    double dVecX_dX2;
    double dVecX_dY2;
    double dVecX_dZ2;
                          
    double dVecY_dX2;
    double dVecY_dY2;
    double dVecY_dZ2;
                           
    double dVecZ_dX2;
    double dVecZ_dY2;
    double dVecZ_dZ2;    

    double pSpan_pXLE_1;
    double pSpan_pYLE_1;
    double pSpan_pZLE_1;
             
    double pSpan_pXLE_2;
    double pSpan_pYLE_2;
    double pSpan_pZLE_2;      

    double pSpan_pXTE_1;
    double pSpan_pYTE_1;
    double pSpan_pZTE_1;
                      
    double pSpan_pXTE_2;
    double pSpan_pYTE_2;
    double pSpan_pZTE_2;  
        
    double pCl_pGamma;
    double pRe_pChord;
    double pCl_pChord;
    double pCfi_pCl;
    double pCf_pCl;
    double pCf_pStallFactor;
    double pStallBumpFactor_pStall;
    double pCfi_pRe;
    double pCf_pRe;
    
    double pFx_pCf;
    double pFy_pCf;
    double pFz_pCf;
              
    double pFx_pChord;
    double pFy_pChord;
    double pFz_pChord;
              
    double pFx_pSpan;
    double pFy_pSpan;
    double pFz_pSpan;    
              
    double pFx_pSVecX;
    double pFy_pSVecY;
    double pFz_pSVecZ;             
    
    double pRVecX_pXc_TE;       
    double pRVecY_pYc_TE;       
    double pRVecZ_pZc_TE;       
    
    double pRVecX_pXc_LE;       
    double pRVecY_pYc_LE;       
    double pRVecZ_pZc_LE;    
                   
    double pMx_pFx;
    double pMx_pFy;
    double pMx_pFz;
                         
    double pMy_pFx;
    double pMy_pFy;
    double pMy_pFz;
                        
    double pMz_pFx;
    double pMz_pFy;
    double pMz_pFz;
              
    double pMx_pRVecX;
    double pMx_pRVecY;
    double pMx_pRVecZ;
    
    double pMy_pRVecX;
    double pMy_pRVecY;
    double pMy_pRVecZ;
              
    double pMz_pRVecX;
    double pMz_pRVecY;
    double pMz_pRVecZ;

    double pFx_pX;
    double pFx_pY;
    double pFx_pZ;
                       
    double pFy_pX;
    double pFy_pY;
    double pFy_pZ;
                        
    double pFz_pX;
    double pFz_pY;
    double pFz_pZ;

    double pMx_pX;
    double pMx_pY;
    double pMx_pZ;
                 
    double pMy_pX;
    double pMy_pY;
    double pMy_pZ;
                   
    double pMz_pX;
    double pMz_pY;
    double pMz_pZ;
    
    double pRe_pVelocity;
    double pCl_pVelocity;        
    double pVelocity_pBodyVelocity[2][3];

    double pFx_pVelocity;
    double pFy_pVelocity;
    double pFz_pVelocity;
    
    double pMx_pVelocity;
    double pMy_pVelocity;
    double pMz_pVelocity;
    
    double OVec[3], TVec[3];
    QUAT Quat, InvQuat, WQuat, Vec1, Vec2, pVec1_pXYZC, pVec2_pXYZC, BodyVelocity, pBodyVelocity_pXYZC;
    
    // Zero out gradients
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ() = 0.;
                                                
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ() = 0.;
                                                  
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ() = 0.;
                                                   
       VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY() = 0.;  
       VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ() = 0.;            
                                                   
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY() = 0.;  
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ() = 0.;            
                                                   
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX() = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY() = 0.;  
       VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ() = 0.;       
                 
    }
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       VSPGeom().Grid(MGLevel_).LoopList(i).pFxo_pGamma() = 0.;
       VSPGeom().Grid(MGLevel_).LoopList(i).pFyo_pGamma() = 0.;
       VSPGeom().Grid(MGLevel_).LoopList(i).pFzo_pGamma() = 0.;
                                                            
       VSPGeom().Grid(MGLevel_).LoopList(i).pMxo_pGamma() = 0.;
       VSPGeom().Grid(MGLevel_).LoopList(i).pMyo_pGamma() = 0.;
       VSPGeom().Grid(MGLevel_).LoopList(i).pMzo_pGamma() = 0.;

    }

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFxo_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFyo_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pFzo_pStallFactor() = 0.;
                                                                       
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMxo_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMyo_pStallFactor() = 0.;
          VSPGeom().VortexSheet(k).TrailingVortex(i).pMzo_pStallFactor() = 0.;
      
       }
       
    }
                  
    // Viscous force gradients
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          LE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).LE_Edge());

          TE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
         
          // Only work on loops on surfaces we are calculating gradients for
          
          if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).ComponentID()] ) {
                    
             // Chord and it's gradients
             
             Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
   
             SVec[0] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Xc();                               
             SVec[1] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Yc();                               
             SVec[2] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Zc(); 
   
             // Gradients of SVec_ 
             
             dSVecX_dXcLE = -1.;
             dSVecX_dYcLE =  0.;
             dSVecX_dZcLE =  0.;
                      
             dSVecY_dXcLE =  0.;
             dSVecY_dYcLE = -1.;
             dSVecY_dZcLE =  0.;
                      
             dSVecZ_dXcLE =  0.;
             dSVecZ_dYcLE =  0.;
             dSVecZ_dZcLE = -1.;
                     
             dSVecX_dXcTE =  1.;
             dSVecX_dYcTE =  0.;
             dSVecX_dZcTE =  0.;
                      
             dSVecY_dXcTE =  0.;
             dSVecY_dYcTE =  1.;
             dSVecY_dZcTE =  0.;
                      
             dSVecZ_dXcTE =  0.;
             dSVecZ_dYcTE =  0.;
             dSVecZ_dZcTE =  1.;
               
             Chord = sqrt(vector_dot(SVec,SVec));
             
             dChord_dXcLE = (SVec[0]*dSVecX_dXcLE + SVec[1]*dSVecY_dXcLE + SVec[2]*dSVecZ_dXcLE)/Chord; 
             dChord_dYcLE = (SVec[0]*dSVecX_dYcLE + SVec[1]*dSVecY_dYcLE + SVec[2]*dSVecZ_dYcLE)/Chord;
             dChord_dZcLE = (SVec[0]*dSVecX_dZcLE + SVec[1]*dSVecY_dZcLE + SVec[2]*dSVecZ_dZcLE)/Chord;
                                                               
             dChord_dXcTE = (SVec[0]*dSVecX_dXcTE + SVec[1]*dSVecY_dXcTE + SVec[2]*dSVecZ_dXcTE)/Chord;
             dChord_dYcTE = (SVec[0]*dSVecX_dYcTE + SVec[1]*dSVecY_dYcTE + SVec[2]*dSVecZ_dYcTE)/Chord;
             dChord_dZcTE = (SVec[0]*dSVecX_dZcTE + SVec[1]*dSVecY_dZcTE + SVec[2]*dSVecZ_dZcTE)/Chord;
                 
             u = SVec[0];
             v = SVec[1];
             w = SVec[2];
             
             SVec[0] /= Chord;
             SVec[1] /= Chord;
             SVec[2] /= Chord;
            
             // Gradients of normalized SVec_
            
             dSVecX_dXcLE = dSVecX_dXcLE/Chord - u * dChord_dXcLE / (Chord * Chord);
             dSVecX_dYcLE = dSVecX_dYcLE/Chord - u * dChord_dYcLE / (Chord * Chord); 
             dSVecX_dZcLE = dSVecX_dZcLE/Chord - u * dChord_dZcLE / (Chord * Chord); 
                                   
             dSVecY_dXcLE = dSVecY_dXcLE/Chord - v * dChord_dXcLE / (Chord * Chord); 
             dSVecY_dYcLE = dSVecY_dYcLE/Chord - v * dChord_dYcLE / (Chord * Chord); 
             dSVecY_dZcLE = dSVecY_dZcLE/Chord - v * dChord_dZcLE / (Chord * Chord); 
                                   
             dSVecZ_dXcLE = dSVecZ_dXcLE/Chord - w * dChord_dXcLE / (Chord * Chord);  
             dSVecZ_dYcLE = dSVecZ_dYcLE/Chord - w * dChord_dYcLE / (Chord * Chord);  
             dSVecZ_dZcLE = dSVecZ_dZcLE/Chord - w * dChord_dZcLE / (Chord * Chord);  
                             
             dSVecX_dXcTE = dSVecX_dXcTE/Chord - u * dChord_dXcTE / (Chord * Chord);
             dSVecX_dYcTE = dSVecX_dYcTE/Chord - u * dChord_dYcTE / (Chord * Chord); 
             dSVecX_dZcTE = dSVecX_dZcTE/Chord - u * dChord_dZcTE / (Chord * Chord); 
                     
             dSVecY_dXcTE = dSVecY_dXcTE/Chord - v * dChord_dXcTE / (Chord * Chord); 
             dSVecY_dYcTE = dSVecY_dYcTE/Chord - v * dChord_dYcTE / (Chord * Chord); 
             dSVecY_dZcTE = dSVecY_dZcTE/Chord - v * dChord_dZcTE / (Chord * Chord); 
                      
             dSVecZ_dXcTE = dSVecZ_dXcTE/Chord - w * dChord_dXcTE / (Chord * Chord);  
             dSVecZ_dYcTE = dSVecZ_dYcTE/Chord - w * dChord_dYcTE / (Chord * Chord);  
             dSVecZ_dZcTE = dSVecZ_dZcTE/Chord - w * dChord_dZcTE / (Chord * Chord);  
   
             // Span and it's gradients
             
             Span = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Length() + VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Length() );
             
             // Gradient of span wrt leading edge xyz nodes
             
             VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).SetupGradients(dLength_dX1, 
                                                                       dLength_dY1,
                                                                       dLength_dZ1,
                                                                       
                                                                       dLength_dX2,
                                                                       dLength_dY2,
                                                                       dLength_dZ2,
                                                                       
                                                                       dVecX_dX1,
                                                                       dVecX_dY1,
                                                                       dVecX_dZ1,
                                                                               
                                                                       dVecY_dX1,
                                                                       dVecY_dY1,
                                                                       dVecY_dZ1,
                                                                              
                                                                       dVecZ_dX1,
                                                                       dVecZ_dY1,
                                                                       dVecZ_dZ1,
                                                                              
                                                                       dVecX_dX2,
                                                                       dVecX_dY2,
                                                                       dVecX_dZ2,
                                                                              
                                                                       dVecY_dX2,
                                                                       dVecY_dY2,
                                                                       dVecY_dZ2,
                                                                              
                                                                       dVecZ_dX2,
                                                                       dVecZ_dY2,
                                                                       dVecZ_dZ2);           
                   
             
             pSpan_pXLE_1 = 0.5*dLength_dX1;
             pSpan_pYLE_1 = 0.5*dLength_dY1;
             pSpan_pZLE_1 = 0.5*dLength_dZ1;
             
             pSpan_pXLE_2 = 0.5*dLength_dX2;
             pSpan_pYLE_2 = 0.5*dLength_dY2;
             pSpan_pZLE_2 = 0.5*dLength_dZ2;          
             
             // Gradient of span wrt trailing edge xyz nodes
             
             VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).SetupGradients(dLength_dX1, 
                                                                       dLength_dY1,
                                                                       dLength_dZ1,
                                                                       
                                                                       dLength_dX2,
                                                                       dLength_dY2,
                                                                       dLength_dZ2,
                                                                       
                                                                       dVecX_dX1,
                                                                       dVecX_dY1,
                                                                       dVecX_dZ1,
                                                                               
                                                                       dVecY_dX1,
                                                                       dVecY_dY1,
                                                                       dVecY_dZ1,
                                                                              
                                                                       dVecZ_dX1,
                                                                       dVecZ_dY1,
                                                                       dVecZ_dZ1,
                                                                              
                                                                       dVecX_dX2,
                                                                       dVecX_dY2,
                                                                       dVecX_dZ2,
                                                                              
                                                                       dVecY_dX2,
                                                                       dVecY_dY2,
                                                                       dVecY_dZ2,
                                                                              
                                                                       dVecZ_dX2,
                                                                       dVecZ_dY2,
                                                                       dVecZ_dZ2);           
                   
             
             pSpan_pXTE_1 = 0.5*dLength_dX1;
             pSpan_pYTE_1 = 0.5*dLength_dY1;
             pSpan_pZTE_1 = 0.5*dLength_dZ1;
                 
             pSpan_pXTE_2 = 0.5*dLength_dX2;
             pSpan_pYTE_2 = 0.5*dLength_dY2;
             pSpan_pZTE_2 = 0.5*dLength_dZ2;                 
             
           // Velocity = 0.5*( sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[0], 2.)
           //                      + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[1], 2.)
           //                      + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[2], 2.) )
           //                + sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[0], 2.)
           //                      + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[1], 2.)
           //                      + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[2], 2.) ) );
           //
             VLE = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[0], 2.)
                       + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[1], 2.)
                       + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[2], 2.) );
                                  
             VTE = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[0], 2.)
                       + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[1], 2.)
                       + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[2], 2.) );
                                                      
             Velocity = 0.5*( VLE + VTE );
             
             pVelocity_pBodyVelocity[0][0] = -0.5*(FreeStreamVelocity_[0] - LocalBodySurfaceVelocityForEdge_[LE_Edge][0])/VLE;                                    
             pVelocity_pBodyVelocity[0][1] = -0.5*(FreeStreamVelocity_[1] - LocalBodySurfaceVelocityForEdge_[LE_Edge][1])/VLE;           
             pVelocity_pBodyVelocity[0][2] = -0.5*(FreeStreamVelocity_[2] - LocalBodySurfaceVelocityForEdge_[LE_Edge][2])/VLE;           
                                             
             pVelocity_pBodyVelocity[1][0] = -0.5*(FreeStreamVelocity_[0] - LocalBodySurfaceVelocityForEdge_[TE_Edge][0])/VTE;                                    
             pVelocity_pBodyVelocity[1][1] = -0.5*(FreeStreamVelocity_[1] - LocalBodySurfaceVelocityForEdge_[TE_Edge][1])/VTE;           
             pVelocity_pBodyVelocity[1][2] = -0.5*(FreeStreamVelocity_[2] - LocalBodySurfaceVelocityForEdge_[TE_Edge][2])/VTE;           
   
             StallFactor = 1. - VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor();
    
             Gamma = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Gamma();
             
             Cl = ABS(Gamma/(0.5*Velocity*Chord));
             
             pCl_pGamma = 1./(0.5*Velocity*Chord);
   
             if ( Gamma < 0. ) pCl_pGamma *= -1.;
             
             pCl_pVelocity = -ABS(Gamma/(0.5*Velocity*Velocity*Chord));
             
             pCl_pChord = -ABS(Gamma/(0.5*Velocity*Chord*Chord));
                    
             Re = MAX(2.,ReCref_ * Velocity * Chord / Cref_);
             
             pRe_pChord = ReCref_ * Velocity / Cref_;
             
             if ( Re <= 2. ) pRe_pChord = 0.;
   
             pRe_pVelocity = 0.;
             
             if ( Re > 2. ) pRe_pVelocity = ReCref_ * Chord / Cref_;
   
             pCf_pCl2 = 0.00625 + 0.01*ABS(Clo_2d_);
             
             StallBumpFactor = 1. + 100.*StallFactor;
             
             pStallBumpFactor_pStall = 100.;
           
             Cfi = 2. * 1.5 * 1.037 / pow(log10(Re),2.58) + pCf_pCl2*pow(Cl-Clo_2d_, 2.);
   
             pCfi_pRe = -2. * 1.5 * 2.58 * 1.037 / ( Re * log(10.) * pow(log10(Re),3.58) );
             
             pCfi_pCl = 2.*pCf_pCl2*(Cl-Clo_2d_);
             
             Cf = Cfi * StallBumpFactor;
                        
             pCf_pCl = pCfi_pCl * StallBumpFactor;
             
             pCf_pStallFactor = -Cfi * pStallBumpFactor_pStall;
            
             pCf_pRe = pCfi_pRe * StallBumpFactor;
             
             // Forces
              
             Fx = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[0];
             Fy = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[1];
             Fz = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[2];
             
             pFx_pCf = 0.5 * Velocity * Velocity * Chord * Span * SVec[0];
             pFy_pCf = 0.5 * Velocity * Velocity * Chord * Span * SVec[1];
             pFz_pCf = 0.5 * Velocity * Velocity * Chord * Span * SVec[2];
             
             pFx_pChord = 0.5 * Cf * Velocity * Velocity * Span * SVec[0];
             pFy_pChord = 0.5 * Cf * Velocity * Velocity * Span * SVec[1];
             pFz_pChord = 0.5 * Cf * Velocity * Velocity * Span * SVec[2];
             
             pFx_pSpan = 0.5 * Cf * Velocity * Velocity * Chord * SVec[0];
             pFy_pSpan = 0.5 * Cf * Velocity * Velocity * Chord * SVec[1];
             pFz_pSpan = 0.5 * Cf * Velocity * Velocity * Chord * SVec[2];    
             
             pFx_pSVecX = 0.5 * Cf * Velocity * Velocity * Chord * Span;
             pFy_pSVecY = 0.5 * Cf * Velocity * Velocity * Chord * Span;
             pFz_pSVecZ = 0.5 * Cf * Velocity * Velocity * Chord * Span;             
   
             pFx_pVelocity = 0.5 * pCf_pRe * pRe_pVelocity * Velocity * Velocity * Chord * Span * SVec[0] + 0.5 * pCf_pCl * pCl_pVelocity * Velocity * Velocity * Chord * Span * SVec[0] + Cf * Velocity * Chord * Span * SVec[0];
             pFy_pVelocity = 0.5 * pCf_pRe * pRe_pVelocity * Velocity * Velocity * Chord * Span * SVec[1] + 0.5 * pCf_pCl * pCl_pVelocity * Velocity * Velocity * Chord * Span * SVec[1] + Cf * Velocity * Chord * Span * SVec[1];
             pFz_pVelocity = 0.5 * pCf_pRe * pRe_pVelocity * Velocity * Velocity * Chord * Span * SVec[2] + 0.5 * pCf_pCl * pCl_pVelocity * Velocity * Velocity * Chord * Span * SVec[2] + Cf * Velocity * Chord * Span * SVec[2];
   
             // Moments ... we assume forces act about centroid of airfoil section
             
             RVec[0] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Xc() );                               
             RVec[1] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Yc() );                               
             RVec[2] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Zc() );    
             
             pRVecX_pXc_TE = 0.5;       
             pRVecY_pYc_TE = 0.5;       
             pRVecZ_pZc_TE = 0.5;       
   
             pRVecX_pXc_LE = 0.5;       
             pRVecY_pYc_LE = 0.5;       
             pRVecZ_pZc_LE = 0.5;    
             
             Mx = Fz * ( RVec[1] - XYZcg_[1] ) - Fy * ( RVec[2] - XYZcg_[2] );   // Roll
             My = Fx * ( RVec[2] - XYZcg_[2] ) - Fz * ( RVec[0] - XYZcg_[0] );   // Pitch
             Mz = Fy * ( RVec[0] - XYZcg_[0] ) - Fx * ( RVec[1] - XYZcg_[1] );   // Yaw
                                
             pMx_pFx =  0.;
             pMx_pFy = -( RVec[2] - XYZcg_[2] );
             pMx_pFz =  ( RVec[1] - XYZcg_[1] );
   
             pMy_pFx =  ( RVec[2] - XYZcg_[2] );
             pMy_pFy =  0.;
             pMy_pFz = -( RVec[0] - XYZcg_[0] );
   
             pMz_pFx = -( RVec[1] - XYZcg_[1] );
             pMz_pFy =  ( RVec[0] - XYZcg_[0] );
             pMz_pFz =  0.;
             
             pMx_pRVecX =  0.;
             pMx_pRVecY =  Fz;
             pMx_pRVecZ = -Fy;
   
             pMy_pRVecX = -Fz;
             pMy_pRVecY =  0.;
             pMy_pRVecZ =  Fx;
             
             pMz_pRVecX =  Fy;
             pMz_pRVecY = -Fx;
             pMz_pRVecZ =  0.;
   
             pMx_pVelocity = pFz_pVelocity * ( RVec[1] - XYZcg_[1] ) - pFy_pVelocity * ( RVec[2] - XYZcg_[2] );   // Roll
             pMy_pVelocity = pFx_pVelocity * ( RVec[2] - XYZcg_[2] ) - pFz_pVelocity * ( RVec[0] - XYZcg_[0] );   // Pitch
             pMz_pVelocity = pFy_pVelocity * ( RVec[0] - XYZcg_[0] ) - pFx_pVelocity * ( RVec[1] - XYZcg_[1] );   // Yaw
   
             // Distribute partial wrt gamma
   
             LoopL = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LoopL();
             LoopR = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LoopR();
   
             if ( LoopL > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopL).pFxo_pGamma() += pFx_pCf * pCf_pCl * pCl_pGamma;
             if ( LoopL > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopL).pFyo_pGamma() += pFy_pCf * pCf_pCl * pCl_pGamma; 
             if ( LoopL > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopL).pFzo_pGamma() += pFz_pCf * pCf_pCl * pCl_pGamma; 
                                                                          
             if ( LoopR > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopR).pFxo_pGamma() -= pFx_pCf * pCf_pCl * pCl_pGamma; 
             if ( LoopR > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopR).pFyo_pGamma() -= pFy_pCf * pCf_pCl * pCl_pGamma; 
             if ( LoopR > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopR).pFzo_pGamma() -= pFz_pCf * pCf_pCl * pCl_pGamma; 
                                                                          
             if ( LoopL > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopL).pMxo_pGamma() += ( pMx_pFx * pFx_pCf + pMx_pFy * pFy_pCf + pMx_pFz * pFz_pCf ) * pCf_pCl * pCl_pGamma;
             if ( LoopL > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopL).pMyo_pGamma() += ( pMy_pFx * pFx_pCf + pMy_pFy * pFy_pCf + pMy_pFz * pFz_pCf ) * pCf_pCl * pCl_pGamma; 
             if ( LoopL > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopL).pMzo_pGamma() += ( pMz_pFx * pFx_pCf + pMz_pFy * pFy_pCf + pMz_pFz * pFz_pCf ) * pCf_pCl * pCl_pGamma; 
                                                                                                                            
             if ( LoopR > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopR).pMxo_pGamma() -= ( pMx_pFx * pFx_pCf + pMx_pFy * pFy_pCf + pMx_pFz * pFz_pCf ) * pCf_pCl * pCl_pGamma;
             if ( LoopR > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopR).pMyo_pGamma() -= ( pMy_pFx * pFx_pCf + pMy_pFy * pFy_pCf + pMy_pFz * pFz_pCf ) * pCf_pCl * pCl_pGamma;  
             if ( LoopR > 0 ) VSPGeom().Grid(MGLevel_).LoopList(LoopR).pMzo_pGamma() -= ( pMz_pFx * pFx_pCf + pMz_pFy * pFy_pCf + pMz_pFz * pFz_pCf ) * pCf_pCl * pCl_pGamma;            
   
             // Distribute partial wrt stall factor
   
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFxo_pStallFactor() += pFx_pCf * pCf_pStallFactor;
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFyo_pStallFactor() += pFy_pCf * pCf_pStallFactor;
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFzo_pStallFactor() += pFz_pCf * pCf_pStallFactor;
                                                         
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMxo_pStallFactor() += ( pMx_pFx * pFx_pCf + pMx_pFy * pFy_pCf + pMx_pFz * pFz_pCf ) * pCf_pStallFactor;
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMyo_pStallFactor() += ( pMy_pFx * pFx_pCf + pMy_pFy * pFy_pCf + pMy_pFz * pFz_pCf ) * pCf_pStallFactor; 
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMzo_pStallFactor() += ( pMz_pFx * pFx_pCf + pMz_pFy * pFy_pCf + pMz_pFz * pFz_pCf ) * pCf_pStallFactor; 
         
             // Distribute force and moment partials wrt surface mesh @ LE node 1
             
                LE_Node1 = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Node1();
   
                pFx_pX = pFx_pSpan * pSpan_pXLE_1 + 0.5 * pFx_pChord * dChord_dXcLE + 0.5 * pFx_pSVecX * dSVecX_dXcLE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dXcLE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dXcLE;
                pFx_pY = pFx_pSpan * pSpan_pYLE_1 + 0.5 * pFx_pChord * dChord_dYcLE + 0.5 * pFx_pSVecX * dSVecX_dYcLE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dYcLE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dYcLE;
                pFx_pZ = pFx_pSpan * pSpan_pZLE_1 + 0.5 * pFx_pChord * dChord_dZcLE + 0.5 * pFx_pSVecX * dSVecX_dZcLE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dZcLE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dZcLE;
                                                                                                                                                          
                pFy_pX = pFy_pSpan * pSpan_pXLE_1 + 0.5 * pFy_pChord * dChord_dXcLE + 0.5 * pFy_pSVecY * dSVecY_dXcLE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dXcLE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dXcLE;
                pFy_pY = pFy_pSpan * pSpan_pYLE_1 + 0.5 * pFy_pChord * dChord_dYcLE + 0.5 * pFy_pSVecY * dSVecY_dYcLE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dYcLE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dYcLE;
                pFy_pZ = pFy_pSpan * pSpan_pZLE_1 + 0.5 * pFy_pChord * dChord_dZcLE + 0.5 * pFy_pSVecY * dSVecY_dZcLE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dZcLE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dZcLE;
                                                                                                                                                              
                pFz_pX = pFz_pSpan * pSpan_pXLE_1 + 0.5 * pFz_pChord * dChord_dXcLE + 0.5 * pFz_pSVecZ * dSVecZ_dXcLE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dXcLE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dXcLE;
                pFz_pY = pFz_pSpan * pSpan_pYLE_1 + 0.5 * pFz_pChord * dChord_dYcLE + 0.5 * pFz_pSVecZ * dSVecZ_dYcLE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dYcLE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dYcLE;
                pFz_pZ = pFz_pSpan * pSpan_pZLE_1 + 0.5 * pFz_pChord * dChord_dZcLE + 0.5 * pFz_pSVecZ * dSVecZ_dZcLE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dZcLE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dZcLE;
                
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFox_pX() += pFx_pX;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFox_pY() += pFx_pY; 
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFox_pZ() += pFx_pZ;         
                                                                    
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFoy_pX() += pFy_pX;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFoy_pY() += pFy_pY; 
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFoy_pZ() += pFy_pZ;         
                                                                    
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFoz_pX() += pFz_pX;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFoz_pY() += pFz_pY; 
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pFoz_pZ() += pFz_pZ;         
                                                               
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMox_pX() += pMx_pFx * pFx_pX + pMx_pFy * pFy_pX + pMx_pFz * pFz_pX + pMx_pRVecX * pRVecX_pXc_LE * 0.5;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMox_pY() += pMx_pFx * pFx_pY + pMx_pFy * pFy_pY + pMx_pFz * pFz_pY + pMx_pRVecY * pRVecY_pYc_LE * 0.5;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMox_pZ() += pMx_pFx * pFx_pZ + pMx_pFy * pFy_pZ + pMx_pFz * pFz_pZ + pMx_pRVecZ * pRVecZ_pZc_LE * 0.5;       
                                                                                                                                                                   
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMoy_pX() += pMy_pFx * pFx_pX + pMy_pFy * pFy_pX + pMy_pFz * pFz_pX + pMy_pRVecX * pRVecX_pXc_LE * 0.5;    
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMoy_pY() += pMy_pFx * pFx_pY + pMy_pFy * pFy_pY + pMy_pFz * pFz_pY + pMy_pRVecY * pRVecY_pYc_LE * 0.5;   
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMoy_pZ() += pMy_pFx * pFx_pZ + pMy_pFy * pFy_pZ + pMy_pFz * pFz_pZ + pMy_pRVecZ * pRVecZ_pZc_LE * 0.5;             
                                                                                                                                                                   
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMoz_pX() += pMz_pFx * pFx_pX + pMz_pFy * pFy_pX + pMz_pFz * pFz_pX + pMz_pRVecX * pRVecX_pXc_LE * 0.5; 
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMoz_pY() += pMz_pFx * pFx_pY + pMz_pFy * pFy_pY + pMz_pFz * pFz_pY + pMz_pRVecY * pRVecY_pYc_LE * 0.5;   
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node1).pMoz_pZ() += pMz_pFx * pFx_pZ + pMz_pFy * pFy_pZ + pMz_pFz * pFz_pZ + pMz_pRVecZ * pRVecZ_pZc_LE * 0.5;                   
                                    
             // Distribute force and moment partials wrt surface mesh @ LE node 2
   
                LE_Node2 = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Node2();
   
                pFx_pX = pFx_pSpan * pSpan_pXLE_2 + 0.5 * pFx_pChord * dChord_dXcLE + 0.5 * pFx_pSVecX * dSVecX_dXcLE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dXcLE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dXcLE;
                pFx_pY = pFx_pSpan * pSpan_pYLE_2 + 0.5 * pFx_pChord * dChord_dYcLE + 0.5 * pFx_pSVecX * dSVecX_dYcLE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dYcLE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dYcLE;
                pFx_pZ = pFx_pSpan * pSpan_pZLE_2 + 0.5 * pFx_pChord * dChord_dZcLE + 0.5 * pFx_pSVecX * dSVecX_dZcLE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dZcLE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dZcLE;
                                                                                                                                                       
                pFy_pX = pFy_pSpan * pSpan_pXLE_2 + 0.5 * pFy_pChord * dChord_dXcLE + 0.5 * pFy_pSVecY * dSVecY_dXcLE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dXcLE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dXcLE;
                pFy_pY = pFy_pSpan * pSpan_pYLE_2 + 0.5 * pFy_pChord * dChord_dYcLE + 0.5 * pFy_pSVecY * dSVecY_dYcLE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dYcLE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dYcLE;
                pFy_pZ = pFy_pSpan * pSpan_pZLE_2 + 0.5 * pFy_pChord * dChord_dZcLE + 0.5 * pFy_pSVecY * dSVecY_dZcLE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dZcLE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dZcLE;
                                                                                                                                                          
                pFz_pX = pFz_pSpan * pSpan_pXLE_2 + 0.5 * pFz_pChord * dChord_dXcLE + 0.5 * pFz_pSVecZ * dSVecZ_dXcLE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dXcLE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dXcLE;
                pFz_pY = pFz_pSpan * pSpan_pYLE_2 + 0.5 * pFz_pChord * dChord_dYcLE + 0.5 * pFz_pSVecZ * dSVecZ_dYcLE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dYcLE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dYcLE;
                pFz_pZ = pFz_pSpan * pSpan_pZLE_2 + 0.5 * pFz_pChord * dChord_dZcLE + 0.5 * pFz_pSVecZ * dSVecZ_dZcLE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dZcLE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dZcLE;
   
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFox_pX() += pFx_pX;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFox_pY() += pFx_pY;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFox_pZ() += pFx_pZ;        
                                                                         
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFoy_pX() += pFy_pX;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFoy_pY() += pFy_pY;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFoy_pZ() += pFy_pZ;        
                                                                        
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFoz_pX() += pFz_pX;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFoz_pY() += pFz_pY;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pFoz_pZ() += pFz_pZ;        
   
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMox_pX() += pMx_pFx * pFx_pX + pMx_pFy * pFy_pX + pMx_pFz * pFz_pX + pMx_pRVecX * pRVecX_pXc_LE * 0.5;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMox_pY() += pMx_pFx * pFx_pY + pMx_pFy * pFy_pY + pMx_pFz * pFz_pY + pMx_pRVecY * pRVecY_pYc_LE * 0.5;
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMox_pZ() += pMx_pFx * pFx_pZ + pMx_pFy * pFy_pZ + pMx_pFz * pFz_pZ + pMx_pRVecZ * pRVecZ_pZc_LE * 0.5;       
                                                                                                                                                                
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMoy_pX() += pMy_pFx * pFx_pX + pMy_pFy * pFy_pX + pMy_pFz * pFz_pX + pMy_pRVecX * pRVecX_pXc_LE * 0.5;    
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMoy_pY() += pMy_pFx * pFx_pY + pMy_pFy * pFy_pY + pMy_pFz * pFz_pY + pMy_pRVecY * pRVecY_pYc_LE * 0.5;   
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMoy_pZ() += pMy_pFx * pFx_pZ + pMy_pFy * pFy_pZ + pMy_pFz * pFz_pZ + pMy_pRVecZ * pRVecZ_pZc_LE * 0.5;             
                                                                                                                                                                 
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMoz_pX() += pMz_pFx * pFx_pX + pMz_pFy * pFy_pX + pMz_pFz * pFz_pX + pMz_pRVecX * pRVecX_pXc_LE * 0.5; 
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMoz_pY() += pMz_pFx * pFx_pY + pMz_pFy * pFy_pY + pMz_pFz * pFz_pY + pMz_pRVecY * pRVecY_pYc_LE * 0.5;   
                VSPGeom().Grid(MGLevel_).NodeList(LE_Node2).pMoz_pZ() += pMz_pFx * pFx_pZ + pMz_pFy * pFy_pZ + pMz_pFz * pFz_pZ + pMz_pRVecZ * pRVecZ_pZc_LE * 0.5;      
                
             // Distribute force and moment partials wrt surface mesh @ TE node 1
   
                TE_Node1 = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Node1();
   
                pFx_pX = pFx_pSpan * pSpan_pXTE_1 + 0.5 * pFx_pChord * dChord_dXcTE + 0.5 * pFx_pSVecX * dSVecX_dXcTE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dXcTE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dXcTE;
                pFx_pY = pFx_pSpan * pSpan_pYTE_1 + 0.5 * pFx_pChord * dChord_dYcTE + 0.5 * pFx_pSVecX * dSVecX_dYcTE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dYcTE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dYcTE;
                pFx_pZ = pFx_pSpan * pSpan_pZTE_1 + 0.5 * pFx_pChord * dChord_dZcTE + 0.5 * pFx_pSVecX * dSVecX_dZcTE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dZcTE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dZcTE;
                                                                                                                                                                                                                   
                pFy_pX = pFy_pSpan * pSpan_pXTE_1 + 0.5 * pFy_pChord * dChord_dXcTE + 0.5 * pFy_pSVecY * dSVecY_dXcTE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dXcTE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dXcTE;
                pFy_pY = pFy_pSpan * pSpan_pYTE_1 + 0.5 * pFy_pChord * dChord_dYcTE + 0.5 * pFy_pSVecY * dSVecY_dYcTE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dYcTE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dYcTE;
                pFy_pZ = pFy_pSpan * pSpan_pZTE_1 + 0.5 * pFy_pChord * dChord_dZcTE + 0.5 * pFy_pSVecY * dSVecY_dZcTE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dZcTE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dZcTE;
                                                                                                                                                       
                pFz_pX = pFz_pSpan * pSpan_pXTE_1 + 0.5 * pFz_pChord * dChord_dXcTE + 0.5 * pFz_pSVecZ * dSVecZ_dXcTE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dXcTE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dXcTE;
                pFz_pY = pFz_pSpan * pSpan_pYTE_1 + 0.5 * pFz_pChord * dChord_dYcTE + 0.5 * pFz_pSVecZ * dSVecZ_dYcTE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dYcTE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dYcTE;
                pFz_pZ = pFz_pSpan * pSpan_pZTE_1 + 0.5 * pFz_pChord * dChord_dZcTE + 0.5 * pFz_pSVecZ * dSVecZ_dZcTE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dZcTE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dZcTE;
                               
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFox_pX() += pFx_pX; 
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFox_pY() += pFx_pY;  
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFox_pZ() += pFx_pZ;          
                                                                      
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFoy_pX() += pFy_pX; 
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFoy_pY() += pFy_pY;  
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFoy_pZ() += pFy_pZ;          
                                                                      
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFoz_pX() += pFz_pX; 
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFoz_pY() += pFz_pY;  
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pFoz_pZ() += pFz_pZ;          
   
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMox_pX() += pMx_pFx * pFx_pX + pMx_pFy * pFy_pX + pMx_pFz * pFz_pX + pMx_pRVecX * pRVecX_pXc_TE * 0.5;
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMox_pY() += pMx_pFx * pFx_pY + pMx_pFy * pFy_pY + pMx_pFz * pFz_pY + pMx_pRVecY * pRVecY_pYc_TE * 0.5;
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMox_pZ() += pMx_pFx * pFx_pZ + pMx_pFy * pFy_pZ + pMx_pFz * pFz_pZ + pMx_pRVecZ * pRVecZ_pZc_TE * 0.5;       
                                                                                                                                                        
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMoy_pX() += pMy_pFx * pFx_pX + pMy_pFy * pFy_pX + pMy_pFz * pFz_pX + pMy_pRVecX * pRVecX_pXc_TE * 0.5;     
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMoy_pY() += pMy_pFx * pFx_pY + pMy_pFy * pFy_pY + pMy_pFz * pFz_pY + pMy_pRVecY * pRVecY_pYc_TE * 0.5;   
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMoy_pZ() += pMy_pFx * pFx_pZ + pMy_pFy * pFy_pZ + pMy_pFz * pFz_pZ + pMy_pRVecZ * pRVecZ_pZc_TE * 0.5;             
                                                                                                                                                        
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMoz_pX() += pMz_pFx * pFx_pX + pMz_pFy * pFy_pX + pMz_pFz * pFz_pX + pMz_pRVecX * pRVecX_pXc_TE * 0.5; 
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMoz_pY() += pMz_pFx * pFx_pY + pMz_pFy * pFy_pY + pMz_pFz * pFz_pY + pMz_pRVecY * pRVecY_pYc_TE * 0.5;   
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node1).pMoz_pZ() += pMz_pFx * pFx_pZ + pMz_pFy * pFy_pZ + pMz_pFz * pFz_pZ + pMz_pRVecZ * pRVecZ_pZc_TE * 0.5;   
                
                
             // Distribute force and moment partials wrt surface mesh @ TE node 2
                  
                TE_Node2 = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Node2();
   
                pFx_pX = pFx_pSpan * pSpan_pXTE_2 + 0.5 * pFx_pChord * dChord_dXcTE + 0.5 * pFx_pSVecX * dSVecX_dXcTE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dXcTE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dXcTE;
                pFx_pY = pFx_pSpan * pSpan_pYTE_2 + 0.5 * pFx_pChord * dChord_dYcTE + 0.5 * pFx_pSVecX * dSVecX_dYcTE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dYcTE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dYcTE;
                pFx_pZ = pFx_pSpan * pSpan_pZTE_2 + 0.5 * pFx_pChord * dChord_dZcTE + 0.5 * pFx_pSVecX * dSVecX_dZcTE + 0.5 * pFx_pCf * pCf_pCl * pCl_pChord * dChord_dZcTE + 0.5 * pFx_pCf * pCf_pRe * pRe_pChord * dChord_dZcTE;
                                                                                                                                                                                                                     
                pFy_pX = pFy_pSpan * pSpan_pXTE_2 + 0.5 * pFy_pChord * dChord_dXcTE + 0.5 * pFy_pSVecY * dSVecY_dXcTE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dXcTE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dXcTE;
                pFy_pY = pFy_pSpan * pSpan_pYTE_2 + 0.5 * pFy_pChord * dChord_dYcTE + 0.5 * pFy_pSVecY * dSVecY_dYcTE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dYcTE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dYcTE;
                pFy_pZ = pFy_pSpan * pSpan_pZTE_2 + 0.5 * pFy_pChord * dChord_dZcTE + 0.5 * pFy_pSVecY * dSVecY_dZcTE + 0.5 * pFy_pCf * pCf_pCl * pCl_pChord * dChord_dZcTE + 0.5 * pFy_pCf * pCf_pRe * pRe_pChord * dChord_dZcTE;
                                                                                                                                                          
                pFz_pX = pFz_pSpan * pSpan_pXTE_2 + 0.5 * pFz_pChord * dChord_dXcTE + 0.5 * pFz_pSVecZ * dSVecZ_dXcTE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dXcTE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dXcTE;
                pFz_pY = pFz_pSpan * pSpan_pYTE_2 + 0.5 * pFz_pChord * dChord_dYcTE + 0.5 * pFz_pSVecZ * dSVecZ_dYcTE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dYcTE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dYcTE;
                pFz_pZ = pFz_pSpan * pSpan_pZTE_2 + 0.5 * pFz_pChord * dChord_dZcTE + 0.5 * pFz_pSVecZ * dSVecZ_dZcTE + 0.5 * pFz_pCf * pCf_pCl * pCl_pChord * dChord_dZcTE + 0.5 * pFz_pCf * pCf_pRe * pRe_pChord * dChord_dZcTE;
                                                                                       
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFox_pX() += pFx_pX; 
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFox_pY() += pFx_pY;  
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFox_pZ() += pFx_pZ;   
                                                                       
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFoy_pX() += pFy_pX; 
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFoy_pY() += pFy_pY;  
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFoy_pZ() += pFy_pZ;   
                                                                        
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFoz_pX() += pFz_pX; 
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFoz_pY() += pFz_pY;  
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pFoz_pZ() += pFz_pZ;   
       
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMox_pX() += pMx_pFx * pFx_pX + pMx_pFy * pFy_pX + pMx_pFz * pFz_pX + pMx_pRVecX * pRVecX_pXc_TE * 0.5;
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMox_pY() += pMx_pFx * pFx_pY + pMx_pFy * pFy_pY + pMx_pFz * pFz_pY + pMx_pRVecY * pRVecY_pYc_TE * 0.5;
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMox_pZ() += pMx_pFx * pFx_pZ + pMx_pFy * pFy_pZ + pMx_pFz * pFz_pZ + pMx_pRVecZ * pRVecZ_pZc_TE * 0.5;       
                                                                                                                                                      
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMoy_pX() += pMy_pFx * pFx_pX + pMy_pFy * pFy_pX + pMy_pFz * pFz_pX + pMy_pRVecX * pRVecX_pXc_TE * 0.5;     
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMoy_pY() += pMy_pFx * pFx_pY + pMy_pFy * pFy_pY + pMy_pFz * pFz_pY + pMy_pRVecY * pRVecY_pYc_TE * 0.5;   
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMoy_pZ() += pMy_pFx * pFx_pZ + pMy_pFy * pFy_pZ + pMy_pFz * pFz_pZ + pMy_pRVecZ * pRVecZ_pZc_TE * 0.5;             
                                                                                                                                                    
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMoz_pX() += pMz_pFx * pFx_pX + pMz_pFy * pFy_pX + pMz_pFz * pFz_pX + pMz_pRVecX * pRVecX_pXc_TE * 0.5; 
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMoz_pY() += pMz_pFx * pFx_pY + pMz_pFy * pFy_pY + pMz_pFz * pFz_pY + pMz_pRVecY * pRVecY_pYc_TE * 0.5;   
                VSPGeom().Grid(MGLevel_).NodeList(TE_Node2).pMoz_pZ() += pMz_pFx * pFx_pZ + pMz_pFy * pFy_pZ + pMz_pFz * pFz_pZ + pMz_pRVecZ * pRVecZ_pZc_TE * 0.5;   
       
             // For rotor cases we need to add in the partials wrt omega, wrt x
             
             g = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Group();
             
             if ( VSPGeom().ComponentGroupList(g).GeometryIsARotor() ) {
   
                OVec[0] = VSPGeom().ComponentGroupList(g).OVec(0); // Rotation origin
                OVec[1] = VSPGeom().ComponentGroupList(g).OVec(1);
                OVec[2] = VSPGeom().ComponentGroupList(g).OVec(2);
                                                      
                RVec[0] = VSPGeom().ComponentGroupList(g).RVec(0); // Rotation vector
                RVec[1] = VSPGeom().ComponentGroupList(g).RVec(1);
                RVec[2] = VSPGeom().ComponentGroupList(g).RVec(2);
                                                      
                TVec[0] = VSPGeom().ComponentGroupList(g).TVec(0); // Translation vector
                TVec[1] = VSPGeom().ComponentGroupList(g).TVec(1);
                TVec[2] = VSPGeom().ComponentGroupList(g).TVec(2);
                
                VSPGeom().ComponentGroupList(g).Update();
         
                Quat = VSPGeom().ComponentGroupList(g).Quat();
                
                InvQuat = VSPGeom().ComponentGroupList(g).InvQuat();
                
                WQuat = VSPGeom().ComponentGroupList(g).WQuat();
                
                // Loop over Leading and Trailing edges
                
                for ( j = 0 ; j <= 1 ; j ++ ) {
                   
                   // Loop over x,y, and z
      
                   for ( p = 0 ; p <= 2 ; p++ ) {
                    
                      pVec1_pXYZC(0) = 0.;
                      pVec1_pXYZC(1) = 0.;
                      pVec1_pXYZC(2) = 0.;
                               
                      pVec1_pXYZC(p) = 1.;
                      
                      // Body point location after rotation
                      
                      Vec2 = Quat * Vec1 * InvQuat;
                      
                      pVec2_pXYZC = Quat * pVec1_pXYZC * InvQuat;
                      
                      // Body point velocity
                      
                      BodyVelocity = WQuat * Vec2;
                      
                      pBodyVelocity_pXYZC = WQuat * pVec2_pXYZC;
                 
                      if ( p == 0 ) {
                         
                         pFx_pX = pFx_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                         pFy_pX = pFy_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                         pFz_pX = pFz_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                                                                                                                                
                         pMx_pX = pMx_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                         pMy_pX = pMy_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                         pMz_pX = pMz_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                                                                                                                                    
                      }                                                                                                             
                                                                                                                                    
                      else if ( p == 1 ) {                                                                                          
                                                                                                                                    
                         pFx_pY = pFx_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                         pFy_pY = pFy_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                         pFz_pY = pFz_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                                                                                                                                   
                         pMx_pY = pMx_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                         pMy_pY = pMy_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                         pMz_pY = pMz_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                                                                                                                                   
                      }                                                                                                            
                                                                                                                                   
                      else if ( p == 2 ) {                                                                                         
                                                                                                                                   
                         pFx_pZ = pFx_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                         pFy_pZ = pFy_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                         pFz_pZ = pFz_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) );
                                                                                                                                   
                         pMx_pZ = pMx_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                         pMy_pZ = pMy_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                         pMz_pZ = pMz_pVelocity * ( pVelocity_pBodyVelocity[j][0] * pBodyVelocity_pXYZC(0) + pVelocity_pBodyVelocity[j][1] * pBodyVelocity_pXYZC(1) + pVelocity_pBodyVelocity[j][2] * pBodyVelocity_pXYZC(2) ); 
                         
                      }         
                          
                   } 
               
                   // Distribute force and moment partials wrt surface mesh @ LE node 1
                         
                   if ( j == 0 ) {
                            
                     Node1 = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Node1();
                     Node2 = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Node2();
                     
                   }
                   
                   else if ( j == 1 ) {
                            
                     Node1 = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Node1();
                     Node2 = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Node2();
                     
                   }
                                        
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFox_pX() += 0.5*pFx_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFox_pY() += 0.5*pFx_pY; 
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFox_pZ() += 0.5*pFx_pZ;         
                                                                      
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFoy_pX() += 0.5*pFy_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFoy_pY() += 0.5*pFy_pY; 
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFoy_pZ() += 0.5*pFy_pZ;         
                                                                      
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFoz_pX() += 0.5*pFz_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFoz_pY() += 0.5*pFz_pY; 
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pFoz_pZ() += 0.5*pFz_pZ;         
                                                                      
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMox_pX() += 0.5*pMx_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMox_pY() += 0.5*pMx_pY;
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMox_pZ() += 0.5*pMx_pZ;       
                                                                                                                                                             
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMoy_pX() += 0.5*pMy_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMoy_pY() += 0.5*pMy_pY;   
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMoy_pZ() += 0.5*pMy_pZ;             
                                                                                                                                                          
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMoz_pX() += 0.5*pMz_pX; 
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMoz_pY() += 0.5*pMz_pY;   
                   VSPGeom().Grid(MGLevel_).NodeList(Node1).pMoz_pZ() += 0.5*pMz_pZ;                   
                                           
                   // Distribute force and moment partials wrt surface mesh @ LE node 2
                   
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFox_pX() += 0.5*pFx_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFox_pY() += 0.5*pFx_pY; 
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFox_pZ() += 0.5*pFx_pZ;         
                                                                   
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFoy_pX() += 0.5*pFy_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFoy_pY() += 0.5*pFy_pY; 
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFoy_pZ() += 0.5*pFy_pZ;         
                                                                   
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFoz_pX() += 0.5*pFz_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFoz_pY() += 0.5*pFz_pY; 
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pFoz_pZ() += 0.5*pFz_pZ;         
                                                             
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMox_pX() += 0.5*pMx_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMox_pY() += 0.5*pMx_pY;
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMox_pZ() += 0.5*pMx_pZ;       
                                                                                                                                                       
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMoy_pX() += 0.5*pMy_pX;
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMoy_pY() += 0.5*pMy_pY;   
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMoy_pZ() += 0.5*pMy_pZ;             
                                                                                                                                                       
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMoz_pX() += 0.5*pMz_pX; 
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMoz_pY() += 0.5*pMz_pY;   
                   VSPGeom().Grid(MGLevel_).NodeList(Node2).pMoz_pZ() += 0.5*pMz_pZ;            
    
                }
                       
             }      
             
          }
               
       }
       
    }

}

/*##############################################################################
#                                                                              #
#         VSP_SOLVER CalculateTimeAccurateAdjointCouplingTerms                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateTimeAccurateAdjointCouplingTerms(int ForceCase, int Dir, int UnsteadyAdjointCase)
{

    int i, j, k, iLoop, Edge, EqnX, EqnY, EqnZ, Case;
    double Forces[3], Moments[3], KuttaWeight, dx, dy, dz;
    
    Case = ForceCase;
    
    if ( ForceCase == 3 ) Case = 1;
        
    // Add in unsteady wake terms
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
 
          for ( j = 2 ; j <= VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes() ; j++ ) {
  
             // Modify the right hand side of the adjoint system
             
             EqnX = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberX(j);
             EqnY = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberY(j);
             EqnZ = VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberZ(j);
             
             // There's an offset in space and time due to the warp field effect... ie, 
             // the node at i was the node at i-1 in the previous time step since we
             // convect the wake... ;-) ... hence the -3 ... Live long and prosper.
            
             pF_pSoln_[EqnX-3] -= -Psi_[UnsteadyAdjointCase+1][(Case-1)*6 + Dir][EqnX];
             pF_pSoln_[EqnY-3] -= -Psi_[UnsteadyAdjointCase+1][(Case-1)*6 + Dir][EqnY];
             pF_pSoln_[EqnZ-3] -= -Psi_[UnsteadyAdjointCase+1][(Case-1)*6 + Dir][EqnZ];
          
          }

       }
       
    }
    
    // Add in unsteady force terms... only for inviscid forces
    
    if ( ForceCase == 1 || ForceCase == 3 ) {       

       for ( iLoop = 1 ; iLoop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; iLoop++ ) {
          
          
          
          if ( Dir == 1 ) pF_pSoln_[iLoop] += pF_pSoln_NP1_[1][iLoop];
          if ( Dir == 2 ) pF_pSoln_[iLoop] += pF_pSoln_NP1_[2][iLoop];
          if ( Dir == 3 ) pF_pSoln_[iLoop] += pF_pSoln_NP1_[3][iLoop];
                                                         
          if ( Dir == 4 ) pF_pSoln_[iLoop] += pF_pSoln_NP1_[4][iLoop];
          if ( Dir == 5 ) pF_pSoln_[iLoop] += pF_pSoln_NP1_[5][iLoop];
          if ( Dir == 6 ) pF_pSoln_[iLoop] += pF_pSoln_NP1_[6][iLoop];

       }
       
    }

}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CreateAdjointCoarseEdgeList                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateAdjointCoarseEdgeList(void) 
{

    int j, k, p, InList, Edge, Side, LevelC, EdgeC, EdgeF, LoopC, LoopF;
    int NumberOfAdjointEdges, *AdjointEdgeList;
    double *AdjointEdgeFactor;
    
    AdjointEdgeList = new int[VSPGeom().Grid(MGLevel_).NumberOfEdges() + 1];
    AdjointEdgeFactor = new double[VSPGeom().Grid(MGLevel_).NumberOfEdges() + 1];
    
    // Moving up the grids from coarsest to finest
    
    for ( LevelC = NumberOfMGLevels_ ; LevelC > 1 ; LevelC-- ) {
   
       for ( Edge = 1 ; Edge <= VSPGeom().Grid(LevelC).NumberOfEdges() ; Edge++ ) {

          NumberOfAdjointEdges = 0;
          
          for ( Side = 1 ; Side <= 2 ; Side++ ) {
             
             if ( Side == 1 ) LoopC = VSPGeom().Grid(LevelC).EdgeList(Edge).LoopL();
             if ( Side == 2 ) LoopC = VSPGeom().Grid(LevelC).EdgeList(Edge).LoopR();
             
             if ( LoopC > 0 ) {
                                
                for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
                
                   LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
                
                   for ( k = 1 ; k <= VSPGeom().Grid(LevelC-1).LoopList(LoopF).NumberOfEdges() ; k++ ) {
                   
                      EdgeF = VSPGeom().Grid(LevelC-1).LoopList(LoopF).Edge(k);
                      
                      EdgeC = VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).CoarseGridEdge();
                   
                      // If EdgeC is not on fine grid, or EdgeC is Edge...
                      
                      if ( EdgeC == 0 || EdgeC == Edge ) {
                         
                         InList = 0;
                         
                         p = 1;
                         
                         while ( p <= NumberOfAdjointEdges && !InList ) {
                            
                            if ( ABS(AdjointEdgeList[p]) == EdgeF ) InList = 1;
                            
                            p++;
                            
                         }
                         
                         if ( !InList ) {
       
                             // Edge is not on fine grid
                             
                             if ( EdgeC == 0 ) {
                                
                                NumberOfAdjointEdges++;
                                
                                AdjointEdgeList[NumberOfAdjointEdges] = EdgeF;
                                
                                AdjointEdgeFactor[NumberOfAdjointEdges] = 1./VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
                                
                             }
                             
                             // Edge is on fine grid
                             
                             if ( EdgeC == Edge ) {
                                
                                NumberOfAdjointEdges++;
                                
                                AdjointEdgeList[NumberOfAdjointEdges] = -EdgeF;
                                
                                AdjointEdgeFactor[NumberOfAdjointEdges] = 1.;

                             }                                
                         
                         }
                         
                      }                      
                      
                   }
                   
                }
                
             }
             
          }
  
          VSPGeom().Grid(LevelC).EdgeList(Edge).SizeAdjointEdgeList(NumberOfAdjointEdges);
          
          for ( j = 1 ; j <= NumberOfAdjointEdges ; j++ ) {
             
             VSPGeom().Grid(LevelC).EdgeList(Edge).AdjointEdgeList(j) = AdjointEdgeList[j];

             VSPGeom().Grid(LevelC).EdgeList(Edge).AdjointEdgeFactor(j) = AdjointEdgeFactor[j];
             
          }
          
       }
       
    }
    
    delete [] AdjointEdgeList;
    delete [] AdjointEdgeFactor;
           
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CalculateAdjointForceGradient                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateAdjointForceGradient(int LevelC, int EdgeC, double q[3], double Fact, double *Forces, double *Moments, double *qw, double *WakeForces, int NumCases) 
{
    
    // On finest level, evalulate forces

    if ( LevelC == MGLevel_ ) {
                 
       int i;
       double dx, dy, dz;
       double dForces[3], StallFactor;

       StallFactor = 1.;

       if ( VSPGeom().Grid(LevelC).EdgeList(EdgeC).IsTrailingEdge() ) StallFactor = VSPGeom().Grid(LevelC).EdgeList(EdgeC).TrailingEdgeStallFactor();

       dx = VSPGeom().Grid(LevelC).EdgeList(EdgeC).Xc() - XYZcg_[0];
       dy = VSPGeom().Grid(LevelC).EdgeList(EdgeC).Yc() - XYZcg_[1];
       dz = VSPGeom().Grid(LevelC).EdgeList(EdgeC).Zc() - XYZcg_[2];
       
       // Edge is on component we are calculating force gradients for
       
       if ( ComponentIsInAdjointForceAndMomentList_[VSPGeom().Grid(LevelC).EdgeList(EdgeC).ComponentID()] ) {
       
          for ( i = 0 ; i < NumCases ; i++ ) {
   
             VSPGeom().Grid(LevelC).EdgeList(EdgeC).CalculateForces_dVelocity(&q[3*i],dForces);
   
             // Apply stall factor
             
             dForces[0] *= Fact * StallFactor;
             dForces[1] *= Fact * StallFactor;
             dForces[2] *= Fact * StallFactor;
             
             // Forces
             
             Forces[3*i + 0] = dForces[0];
             Forces[3*i + 1] = dForces[1];
             Forces[3*i + 2] = dForces[2];
             
             // Moments
             
             Moments[3*i + 0] = dForces[2] * dy - dForces[1] * dz;
             Moments[3*i + 1] = dForces[0] * dz - dForces[2] * dx;
             Moments[3*i + 2] = dForces[1] * dx - dForces[0] * dy;          
   
             // Wake forces
             
             WakeForces[3*i + 0] = 0.;
             WakeForces[3*i + 1] = 0.;
             WakeForces[3*i + 2] = 0.;
                          
             if ( VSPGeom().Grid(LevelC).EdgeList(EdgeC).IsTrailingEdge() ) {
   
                VSPGeom().Grid(LevelC).EdgeList(EdgeC).CalculateForces_dVelocity(&qw[3*i],dForces);
   
                WakeForces[3*i + 0] = -dForces[0];
                WakeForces[3*i + 1] = -dForces[1];
                WakeForces[3*i + 2] = -dForces[2];
             
             }             
                          
          }
          
       }

       // Edge is NOT on component we are calculating force gradients for
       
       else {
          
          for ( i = 0 ; i < NumCases ; i++ ) {

             // Forces
             
             Forces[3*i + 0] = 0.;
             Forces[3*i + 1] = 0.;
             Forces[3*i + 2] = 0.;
             
             // Moments
             
             Moments[3*i + 0] = 0.;
             Moments[3*i + 1] = 0.;
             Moments[3*i + 2] = 0.;          
   
             // Wake forces
             
             WakeForces[3*i + 0] = 0.;
             WakeForces[3*i + 1] = 0.;
             WakeForces[3*i + 2] = 0.;
                 
          }
          
       }
       
    }
    
    // Prolongate over edges
    
    else {
       
       int i, j, Edge;

       double NewFact;
       double dForces[18];
       double dMoments[18];
       double dWakeForces[18];
  
       // Loop over adjoint edges...
       
       for ( i = 0 ; i < 3*NumCases ; i++ ) {
       
          Forces[i] = Moments[i] = WakeForces[i] = 0.; 

       }
                 
       for ( j = 1 ; j <= VSPGeom().Grid(LevelC).EdgeList(EdgeC).NumberOfAdjointEdges() ; j++ ) {
          
          Edge = ABS(VSPGeom().Grid(LevelC).EdgeList(EdgeC).AdjointEdgeList(j));

          NewFact = Fact * VSPGeom().Grid(LevelC).EdgeList(EdgeC).AdjointEdgeFactor(j);
          
          CalculateAdjointForceGradient(LevelC - 1, Edge, q, NewFact, dForces, dMoments, qw, dWakeForces, NumCases);

          for ( i = 0 ; i < 3*NumCases ; i++ ) {

             Forces[i] += dForces[i];

             Moments[i] += dMoments[i];

             WakeForces[i] += dWakeForces[i];

          }
          
       }

    }
            
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER DistributeForceGammaVelocities                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DistributeForceGammaVelocities(int LevelC, int LoopC) 
{

    if ( LevelC > MGLevel_ ) {
        
       int Level, j, k, LoopF, EdgeC, EdgeF;   
       double dU, dV, dW;
       double Fact;
   
       // Create averaged velocity across loop, based on edge values
       
       dU = dV = dW = 0.;

       for ( k = 1 ; k <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges() ; k++ ) {
          
          EdgeC = VSPGeom().Grid(LevelC).LoopList(LoopC).Edge(k);
          
          dU += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dU_dGamma();
          dV += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dV_dGamma();
          dW += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dW_dGamma();
                          
       }
       
       dU /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dV /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dW /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();

       for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
          
          LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
          
          for ( k = 1 ; k <= VSPGeom().Grid(LevelC-1).LoopList(LoopF).NumberOfEdges() ; k++ ) {
             
             EdgeF = VSPGeom().Grid(LevelC-1).LoopList(LoopF).Edge(k);
             
             EdgeC = VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).CoarseGridEdge();
             
             Fact = 0.5;
             
             if ( VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).LoopL() == 0 ||
                  VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).LoopR() == 0 ) Fact = 1.;
                                        
             // Edge does not exist on coarse grid
             
             if ( EdgeC == 0 ) {
      
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dU_dGamma() += Fact*dU;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dV_dGamma() += Fact*dV;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dW_dGamma() += Fact*dW;
          
             }
             
             else {
      
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dU_dGamma() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dU_dGamma();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dV_dGamma() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dV_dGamma();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dW_dGamma() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dW_dGamma();
      
             }   
             
          }
          
       }
       
       // Move up a level
       
       if ( LevelC - 1 > MGLevel_ ) {
          
          for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
             
             LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
             
             DistributeForceGammaVelocities(LevelC-1, LoopF);
             
          }
          
       } 
          
    }
            
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER DistributeForceMeshVelocities                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DistributeForceMeshVelocities(int LevelC, int LoopC) 
{

    if ( LevelC > MGLevel_ ) {
        
       int Level, j, k, LoopF, EdgeC, EdgeF;
   
       double dq0_dx1, dq1_dx1, dq2_dx1;
       double dq0_dy1, dq1_dy1, dq2_dy1;
       double dq0_dz1, dq1_dz1, dq2_dz1;
   
       double dq0_dx2, dq1_dx2, dq2_dx2;
       double dq0_dy2, dq1_dy2, dq2_dy2;
       double dq0_dz2, dq1_dz2, dq2_dz2;
       
       double Fact;
   
       // Create averaged velocity across loop, based on edge values
       
       dq0_dx1 = dq1_dx1 = dq2_dx1 = 0.;
       dq0_dy1 = dq1_dy1 = dq2_dy1 = 0.;
       dq0_dz1 = dq1_dz1 = dq2_dz1 = 0.;
           
       dq0_dx2 = dq1_dx2 = dq2_dx2 = 0.;
       dq0_dy2 = dq1_dy2 = dq2_dy2 = 0.;
       dq0_dz2 = dq1_dz2 = dq2_dz2 = 0.;
   
       for ( k = 1 ; k <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges() ; k++ ) {
          
          EdgeC = VSPGeom().Grid(LevelC).LoopList(LoopC).Edge(k);
          
          dq0_dx1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dx1();
          dq1_dx1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dx1();
          dq2_dx1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dx1();
                                                     
          dq0_dy1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dy1();
          dq1_dy1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dy1();
          dq2_dy1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dy1();
                                                     
          dq0_dz1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dz1();
          dq1_dz1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dz1();
          dq2_dz1 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dz1();
                                                     
          dq0_dx2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dx2();
          dq1_dx2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dx2();
          dq2_dx2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dx2();
                                                     
          dq0_dy2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dy2();
          dq1_dy2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dy2();
          dq2_dy2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dy2();
                                                     
          dq0_dz2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dz2();
          dq1_dz2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dz2();
          dq2_dz2 += VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dz2();
                                    
       }
       
       dq0_dx1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq1_dx1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq2_dx1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
                                                  
       dq0_dy1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq1_dy1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq2_dy1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
                                                  
       dq0_dz1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq1_dz1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq2_dz1 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
                                                  
       dq0_dx2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq1_dx2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq2_dx2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
                                                  
       dq0_dy2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq1_dy2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq2_dy2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
                                                  
       dq0_dz2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq1_dz2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
       dq2_dz2 /= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges();
   
       for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
          
          LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
          
          for ( k = 1 ; k <= VSPGeom().Grid(LevelC-1).LoopList(LoopF).NumberOfEdges() ; k++ ) {
             
             EdgeF = VSPGeom().Grid(LevelC-1).LoopList(LoopF).Edge(k);
             
             EdgeC = VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).CoarseGridEdge();
             
             Fact = 0.5;
             
             if ( VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).LoopL() == 0 ||
                  VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).LoopR() == 0 ) Fact = 1.;
                                        
             // Edge does not exist on coarse grid
             
             if ( EdgeC == 0 ) {
      
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dx1() += Fact*dq0_dx1;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dx1() += Fact*dq1_dx1;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dx1() += Fact*dq2_dx1;
                                                      
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dy1() += Fact*dq0_dy1;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dy1() += Fact*dq1_dy1;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dy1() += Fact*dq2_dy1;
                                                        
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dz1() += Fact*dq0_dz1;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dz1() += Fact*dq1_dz1;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dz1() += Fact*dq2_dz1;
                                                       
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dx2() += Fact*dq0_dx2;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dx2() += Fact*dq1_dx2;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dx2() += Fact*dq2_dx2;
                                                        
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dy2() += Fact*dq0_dy2;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dy2() += Fact*dq1_dy2;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dy2() += Fact*dq2_dy2;
                                                       
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dz2() += Fact*dq0_dz2;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dz2() += Fact*dq1_dz2;
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dz2() += Fact*dq2_dz2;
          
             }
             
             else {
      
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dx1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dx1();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dx1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dx1();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dx1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dx1();
                                                                                                           
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dy1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dy1();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dy1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dy1();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dy1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dy1();
                                                                                                           
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dz1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dz1();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dz1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dz1();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dz1() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dz1();
                                                                                                           
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dx2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dx2();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dx2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dx2();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dx2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dx2();
                                                                                                           
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dy2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dy2();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dy2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dy2();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dy2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dy2();
                                                                                                           
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dz2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dz2();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dz2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dz2();
                VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dz2() += Fact*VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dz2();
      
             }   
             
          }
          
       }
       
       // Move up a level
       
       if ( LevelC - 1 > MGLevel_ ) {
          
          for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
             
             LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
             
             DistributeForceMeshVelocities(LevelC-1, LoopF);
             
          }
          
       } 
          
    }
            
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER ZeroForceMeshVelocities                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroForceGammaVelocities(int LevelC, int LoopC) 
{

    int Level, j, k, LoopF, EdgeC, EdgeF;
    
    if ( LevelC > 0 ) {
       
       for ( k = 1 ; k <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges() ; k++ ) {
          
          EdgeC = VSPGeom().Grid(LevelC).LoopList(LoopC).Edge(k);
          
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dU_dGamma() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dV_dGamma() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dW_dGamma() = 0.;
                                    
       }
       
    }

    if ( LevelC > MGLevel_ ) {
        
       for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
   
          LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
          
          for ( k = 1 ; k <= VSPGeom().Grid(LevelC-1).LoopList(LoopF).NumberOfEdges() ; k++ ) {
             
             EdgeF = VSPGeom().Grid(LevelC-1).LoopList(LoopF).Edge(k);
   
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dU_dGamma() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dV_dGamma() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dW_dGamma() = 0.;

          }
          
       }
       
       // Move up a level
       
       if (1|| LevelC - 1 > MGLevel_ ) {

          for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
             
             LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
             
             ZeroForceGammaVelocities(LevelC-1, LoopF);
             
          }
          
       } 
          
    }
            
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER ZeroForceMeshVelocities                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroForceMeshVelocities(int LevelC, int LoopC) 
{

    int Level, j, k, LoopF, EdgeC, EdgeF;
    
    if ( LevelC > 0 ) {
       
       for ( k = 1 ; k <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfEdges() ; k++ ) {
          
          EdgeC = VSPGeom().Grid(LevelC).LoopList(LoopC).Edge(k);
          
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dx1() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dx1() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dx1() = 0.;
                                                         
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dy1() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dy1() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dy1() = 0.;
                                                         
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dz1() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dz1() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dz1() = 0.;
                                                          
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dx2() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dx2() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dx2() = 0.;
                                                         
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dy2() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dy2() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dy2() = 0.;
                                                         
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq0_dz2() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq1_dz2() = 0.;
          VSPGeom().Grid(LevelC).EdgeList(EdgeC).dq2_dz2() = 0.;
                                    
       }
       
    }

    if ( LevelC > MGLevel_ ) {
        
       for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
   
          LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
          
          for ( k = 1 ; k <= VSPGeom().Grid(LevelC-1).LoopList(LoopF).NumberOfEdges() ; k++ ) {
             
             EdgeF = VSPGeom().Grid(LevelC-1).LoopList(LoopF).Edge(k);
   
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dx1() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dx1() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dx1() = 0.;
                                                               
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dy1() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dy1() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dy1() = 0.;
                                                              
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dz1() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dz1() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dz1() = 0.;
                                                               
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dx2() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dx2() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dx2() = 0.;
                                                              
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dy2() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dy2() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dy2() = 0.;
                                                               
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq0_dz2() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq1_dz2() = 0.;
             VSPGeom().Grid(LevelC-1).EdgeList(EdgeF).dq2_dz2() = 0.;
   
          }
          
       }
       
       // Move up a level
       
       if (1|| LevelC - 1 > MGLevel_ ) {

          for ( j = 1 ; j <= VSPGeom().Grid(LevelC).LoopList(LoopC).NumberOfFineGridLoops() ; j++ ) {
             
             LoopF = VSPGeom().Grid(LevelC).LoopList(LoopC).FineGridLoop(j);
             
             ZeroForceMeshVelocities(LevelC-1, LoopF);
             
          }
          
       } 
          
    }
            
}

/*##############################################################################
#                                                                              #
#                      VSP_SOLVER ProlongateGammaForces                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateGammaForces(void) 
{
 
    int Level, i_c, i_f, j;

    for ( Level = NumberOfMGLevels_ ; Level > 1; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfLoops() ; i_c++ ) {
         
          for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfFineGridLoops() ; j++ ) {
             
             i_f = VSPGeom().Grid(Level).LoopList(i_c).FineGridLoop(j);

             VSPGeom().Grid(Level-1).LoopList(i_f).pFx_pGamma() += VSPGeom().Grid(Level).LoopList(i_c).pFx_pGamma();
             VSPGeom().Grid(Level-1).LoopList(i_f).pFy_pGamma() += VSPGeom().Grid(Level).LoopList(i_c).pFy_pGamma();
             VSPGeom().Grid(Level-1).LoopList(i_f).pFz_pGamma() += VSPGeom().Grid(Level).LoopList(i_c).pFz_pGamma();

          }
          
       }
       
    }          
                  
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER ProlongateMeshForces                          #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateMeshForces(void) 
{
 
    int Level, i_c, i_f;

    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfNodes() ; i_c++ ) {
          
          i_f = VSPGeom().Grid(Level).NodeList(i_c).FineGridNode();

          VSPGeom().Grid(Level-1).NodeList(i_f).pFix_pX() += VSPGeom().Grid(Level).NodeList(i_c).pFix_pX();
          VSPGeom().Grid(Level-1).NodeList(i_f).pFiy_pX() += VSPGeom().Grid(Level).NodeList(i_c).pFiy_pX();
          VSPGeom().Grid(Level-1).NodeList(i_f).pFiz_pX() += VSPGeom().Grid(Level).NodeList(i_c).pFiz_pX();
                                                                                
          VSPGeom().Grid(Level-1).NodeList(i_f).pFix_pY() += VSPGeom().Grid(Level).NodeList(i_c).pFix_pY();
          VSPGeom().Grid(Level-1).NodeList(i_f).pFiy_pY() += VSPGeom().Grid(Level).NodeList(i_c).pFiy_pY();
          VSPGeom().Grid(Level-1).NodeList(i_f).pFiz_pY() += VSPGeom().Grid(Level).NodeList(i_c).pFiz_pY();
                                                                                 
          VSPGeom().Grid(Level-1).NodeList(i_f).pFix_pZ() += VSPGeom().Grid(Level).NodeList(i_c).pFix_pZ();
          VSPGeom().Grid(Level-1).NodeList(i_f).pFiy_pZ() += VSPGeom().Grid(Level).NodeList(i_c).pFiy_pZ();
          VSPGeom().Grid(Level-1).NodeList(i_f).pFiz_pZ() += VSPGeom().Grid(Level).NodeList(i_c).pFiz_pZ();
        
       }
       
    }          
                  
}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER DistributeAdjointForcesOverEdges                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::DistributeAdjointForcesOverEdges(int &Level, int &Loop, double Forces[3], double *pF_pM)
{
  
   if ( Level == MGLevel_ ) {

      int i, j, i1, i2, Edge;
      double Fact;
      
      if ( Loop > 0 ) {

         Fact = 0.5;
         
         for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfEdges() ; j++ ) {

            Edge =  VSPGeom().Grid(Level).LoopList(Loop).Edge(j);

            pF_pM[3*VSPGeom().Grid(Level).EdgeList(Edge).Node1()-2] += 0.5*Forces[0];
            pF_pM[3*VSPGeom().Grid(Level).EdgeList(Edge).Node1()-1] += 0.5*Forces[1];
            pF_pM[3*VSPGeom().Grid(Level).EdgeList(Edge).Node1()  ] += 0.5*Forces[2];
                                                                     
            pF_pM[3*VSPGeom().Grid(Level).EdgeList(Edge).Node2()-2] += 0.5*Forces[0];
            pF_pM[3*VSPGeom().Grid(Level).EdgeList(Edge).Node2()-1] += 0.5*Forces[1];
            pF_pM[3*VSPGeom().Grid(Level).EdgeList(Edge).Node2()  ] += 0.5*Forces[2];
                              
         }
         
      }
    
   }
   
   else {
      
      int i, j, k, LevelF, LoopF, EdgeF;

      LevelF = Level - 1;

      if ( Loop > 0 ) {
   
         for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; j++ ) {
          
            LoopF = VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(j);

            DistributeAdjointForcesOverEdges(LevelF, LoopF, Forces, pF_pM);

         }  
      
      }      

   }
   
}

/*##############################################################################
#                                                                              #
#       VSP_SOLVER CalculatePsiT_PartialResidualPartialMesh                    #
#                                                                              #
#  [ R_gamma ]                                                                 # 
#  [         ]                                                                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculatePsiT_PartialResidualPartialMesh(void)
{   
   
    int i, j, k, Loop, Level;

    // Update velocities
    
    CalculateVelocities(ALL_WAKE_GAMMAS);    
    
    // Initialize loops with Psi solution

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).LoopList(i).Psi() = 0.;
       
    }
        
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).LoopList(i).Psi() = CurrentPsi_[i];
       
    }

    // Initialize nodes with Psi solution

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(0) = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(1) = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(2) = 0.;
       
    }   
     
    for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() + 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       j = i - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();

       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(0) = CurrentPsi_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j - 2];
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(1) = CurrentPsi_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j - 1];
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(2) = CurrentPsi_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j    ];
       
    }   

    // Initialize stall factor Psi solution

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
        
          VSPGeom().VortexSheet(k).TrailingVortex(i).Psi() = CurrentPsi_[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()];

       }
       
    }    
    
    // Initialize the vortex stretching ratio
    
    if ( TimeAccurate_ ) {
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
             
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {

                VSPGeom().VortexSheet(k).WakeLoopList(i).Psi() = CurrentPsi_[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()];
                
             }
  
          }    
          
       }
       
    }

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {

       PsiT_pR_pMesh_[3*i-2] = 0.;
       PsiT_pR_pMesh_[3*i-1] = 0.;
       PsiT_pR_pMesh_[3*i  ] = 0.;
       
    }
    
    for ( Level = MGLevel_ ; Level < NumberOfMGLevels_ ; Level++ ) {
            
       RestrictAdjointSolutionFromGrid(Level);
       
    }    

    
    // Wake equations

    CalculatePsiT_PartialResidualPartialMesh_WakeEquations();

    // Vorticity equations

    CalculatePsiT_PartialResidualPartialMesh_VorticityEquations();
    
    // Stall factor equations
    
    if ( StallModelIsOn_ ) CalculatePsiT_PartialResidualPartialMesh_StallEquations();
    
    // Vortex stretching ratio equations
    
    if ( TimeAccurate_ ) CalculatePsiT_PartialResidualPartialMesh_VortexStretchingRatioEquations();
    
}

/*##############################################################################
#                                                                              #
#     VSP_SOLVER CalculatePsiT_PartialResidualPartialMesh_VorticityEquations   #
#                                                                              #
#            [ pRGamma_pMesh ]                                                 # 
#  [Psi]^T x [               ]                                                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculatePsiT_PartialResidualPartialMesh_VorticityEquations(void)
{

    int i, j, k, v, Loop, Node, Node1, Node2, iLevel, iLoop, jLevel, jEdge, Edge, Level;
    int LoopType, MaxLoopTypes, NumberOfSheets, *MG_OffSet;
    int i_c, i_f, NodeC, NodeF, ArraySize;
    double dq[3], q[3], dxyz_i[3], xyz[3], Coef, *PsiT_pR_pMesh, Psi;
    double *NormalGradients, *AreaGradients, SymFact;
    VSP_EDGE *VortexEdge;
    
    double dq0_dx1;
    double dq0_dy1;
    double dq0_dz1;
    double dq0_dx2;
    double dq0_dy2;
    double dq0_dz2;
                          
    double dq1_dx1;
    double dq1_dy1;
    double dq1_dz1;
    double dq1_dx2;
    double dq1_dy2;
    double dq1_dz2;
                          
    double dq2_dx1;
    double dq2_dy1;
    double dq2_dz1;
    double dq2_dx2;
    double dq2_dy2;
    double dq2_dz2;
                          
    double dq0_dxp;
    double dq0_dyp;
    double dq0_dzp;
                          
    double dq1_dxp;
    double dq1_dyp;
    double dq1_dzp;
                          
    double dq2_dxp;
    double dq2_dyp;
    double dq2_dzp; 

    double dq0_dMach;
    double dq1_dMach;
    double dq2_dMach;    
        
    // Symmetry
    
    double dq0_dx1_s;
    double dq0_dy1_s;
    double dq0_dz1_s;
    double dq0_dx2_s;
    double dq0_dy2_s;
    double dq0_dz2_s;
                         
    double dq1_dx1_s;
    double dq1_dy1_s;
    double dq1_dz1_s;
    double dq1_dx2_s;
    double dq1_dy2_s;
    double dq1_dz2_s;
                        
    double dq2_dx1_s;
    double dq2_dy1_s;
    double dq2_dz1_s;
    double dq2_dx2_s;
    double dq2_dy2_s;
    double dq2_dz2_s;
                         
    double dq0_dxp_s;
    double dq0_dyp_s;
    double dq0_dzp_s;
                        
    double dq1_dxp_s;
    double dq1_dyp_s;
    double dq1_dzp_s;
                        
    double dq2_dxp_s;
    double dq2_dyp_s;
    double dq2_dzp_s; 

    double dq0_dMach_s;
    double dq1_dMach_s;
    double dq2_dMach_s;   
            
    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + 3*VSPGeom().Grid(i-1).NumberOfNodes();
       
    }
    
    // Partial wrt mesh accumalation array
    
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
   
    PsiT_pR_pMesh = new double[ArraySize];
    
    zero_double_array(PsiT_pR_pMesh, ArraySize-1);
          
    // Surface vortex induced velocities 

    MaxLoopTypes = 0;

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:PsiT_pR_pMesh[:ArraySize]) private(iLevel,iLoop,Psi,j,jLevel,VortexEdge,\
                                                                                                     dq0_dx1,\
                                                                                                     dq0_dy1,\
                                                                                                     dq0_dz1,\
                                                                                                     dq0_dx2,\
                                                                                                     dq0_dy2,\
                                                                                                     dq0_dz2,\
                                                                                                     dq1_dx1,\
                                                                                                     dq1_dy1,\
                                                                                                     dq1_dz1,\
                                                                                                     dq1_dx2,\
                                                                                                     dq1_dy2,\
                                                                                                     dq1_dz2,\
                                                                                                     dq2_dx1,\
                                                                                                     dq2_dy1,\
                                                                                                     dq2_dz1,\
                                                                                                     dq2_dx2,\
                                                                                                     dq2_dy2,\
                                                                                                     dq2_dz2,\
                                                                                                     dq0_dxp,\
                                                                                                     dq0_dyp,\
                                                                                                     dq0_dzp,\
                                                                                                     dq1_dxp,\
                                                                                                     dq1_dyp,\
                                                                                                     dq1_dzp,\
                                                                                                     dq2_dxp,\
                                                                                                     dq2_dyp,\
                                                                                                     dq2_dzp,\
                                                                                                     dq0_dMach,\
                                                                                                     dq1_dMach,\
                                                                                                     dq2_dMach,\
                                                                                                     dq0_dx1_s,\
                                                                                                     dq0_dy1_s,\
                                                                                                     dq0_dz1_s,\
                                                                                                     dq0_dx2_s,\
                                                                                                     dq0_dy2_s,\
                                                                                                     dq0_dz2_s,\
                                                                                                     dq1_dx1_s,\
                                                                                                     dq1_dy1_s,\
                                                                                                     dq1_dz1_s,\
                                                                                                     dq1_dx2_s,\
                                                                                                     dq1_dy2_s,\
                                                                                                     dq1_dz2_s,\
                                                                                                     dq2_dx1_s,\
                                                                                                     dq2_dy1_s,\
                                                                                                     dq2_dz1_s,\
                                                                                                     dq2_dx2_s,\
                                                                                                     dq2_dy2_s,\
                                                                                                     dq2_dz2_s,\
                                                                                                     dq0_dxp_s,\
                                                                                                     dq0_dyp_s,\
                                                                                                     dq0_dzp_s,\
                                                                                                     dq1_dxp_s,\
                                                                                                     dq1_dyp_s,\
                                                                                                     dq1_dzp_s,\
                                                                                                     dq2_dxp_s,\
                                                                                                     dq2_dyp_s,\
                                                                                                     dq2_dzp_s,\
                                                                                                     dq0_dMach_s,\
                                                                                                     dq1_dMach_s,\
                                                                                                     dq2_dMach_s,\
                                                                                                     Node1, Node2, q, xyz, Coef, k) schedule(dynamic)     
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {

          iLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();
                                                 
          iLoop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();

          // Only need to look at surface loop vorticity equations
          
          if ( VSPGeom().Grid(iLevel).LoopList(iLoop).SurfaceID() > 0 ) {
             
             Psi = VSPGeom().Grid(iLevel).LoopList(iLoop).Psi();
    
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
             
                jLevel = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
                
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
   
                VortexEdge->dInducedVelocity_dMesh_Transpose(VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c(),
                                                             dq0_dx1,
                                                             dq0_dy1,
                                                             dq0_dz1,
                                                             dq0_dx2,
                                                             dq0_dy2,
                                                             dq0_dz2,
                                                             
                                                             dq1_dx1,
                                                             dq1_dy1,
                                                             dq1_dz1,
                                                             dq1_dx2,
                                                             dq1_dy2,
                                                             dq1_dz2,
                                                             
                                                             dq2_dx1,
                                                             dq2_dy1,
                                                             dq2_dz1,
                                                             dq2_dx2,
                                                             dq2_dy2,
                                                             dq2_dz2,
                                                             
                                                             dq0_dxp,
                                                             dq0_dyp,
                                                             dq0_dzp,
                                                                
                                                             dq1_dxp,
                                                             dq1_dyp,
                                                             dq1_dzp,
                                                                   
                                                             dq2_dxp,
                                                             dq2_dyp,
                                                             dq2_dzp,
                                                             
                                                             dq0_dMach,
                                                             dq1_dMach,
                                                             dq2_dMach);                                                                 

                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] =  VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(iLevel).LoopList(iLoop).xyz_c()[2];
                   
                   VortexEdge->dInducedVelocity_dMesh_Transpose(xyz,
                                                                dq0_dx1_s,
                                                                dq0_dy1_s,
                                                                dq0_dz1_s,
                                                                dq0_dx2_s,
                                                                dq0_dy2_s,
                                                                dq0_dz2_s,
                                                                  
                                                                dq1_dx1_s,
                                                                dq1_dy1_s,
                                                                dq1_dz1_s,
                                                                dq1_dx2_s,
                                                                dq1_dy2_s,
                                                                dq1_dz2_s,
                                                                    
                                                                dq2_dx1_s,
                                                                dq2_dy1_s,
                                                                dq2_dz1_s,
                                                                dq2_dx2_s,
                                                                dq2_dy2_s,
                                                                dq2_dz2_s,
                                                               
                                                                dq0_dxp_s,
                                                                dq0_dyp_s,
                                                                dq0_dzp_s,
                                                                    
                                                                dq1_dxp_s,
                                                                dq1_dyp_s,
                                                                dq1_dzp_s,
                                                                    
                                                                dq2_dxp_s,
                                                                dq2_dyp_s,
                                                                dq2_dzp_s,
                                                                
                                                                dq0_dMach_s,
                                                                dq1_dMach_s,
                                                                dq2_dMach_s);                                                      

                   dq0_dx1 += dq0_dx1_s;
                   dq0_dy1 -= dq0_dy1_s;
                   dq0_dz1 += dq0_dz1_s;
                   dq0_dx2 += dq0_dx2_s;
                   dq0_dy2 -= dq0_dy2_s;
                   dq0_dz2 += dq0_dz2_s;
                                        
                   dq1_dx1 -= dq1_dx1_s;
                   dq1_dy1 += dq1_dy1_s;
                   dq1_dz1 -= dq1_dz1_s;
                   dq1_dx2 -= dq1_dx2_s;
                   dq1_dy2 += dq1_dy2_s;
                   dq1_dz2 -= dq1_dz2_s;
                                     
                   dq2_dx1 += dq2_dx1_s;
                   dq2_dy1 -= dq2_dy1_s;
                   dq2_dz1 += dq2_dz1_s;
                   dq2_dx2 += dq2_dx2_s;
                   dq2_dy2 -= dq2_dy2_s;
                   dq2_dz2 += dq2_dz2_s;
                                        
                   dq0_dxp += dq0_dxp_s;
                   dq0_dyp -= dq0_dyp_s;
                   dq0_dzp += dq0_dzp_s;
                                        
                   dq1_dxp -= dq1_dxp_s;
                   dq1_dyp += dq1_dyp_s;
                   dq1_dzp -= dq1_dzp_s;
                                        
                   dq2_dxp += dq2_dxp_s;
                   dq2_dyp -= dq2_dyp_s;
                   dq2_dzp += dq2_dzp_s;
                   
                   dq0_dMach += dq0_dMach_s;
                   dq1_dMach -= dq1_dMach_s;
                   dq2_dMach += dq2_dMach_s;
                   
                }    
                                                                
                // j edge nodes
                                                 
                   Node1 = VortexEdge->Node1();
                   Node2 = VortexEdge->Node2();
                   
                   // Node 1, x
                   
                   q[0] = dq0_dx1 * Psi;
                   q[1] = dq1_dx1 * Psi;
                   q[2] = dq2_dx1 * Psi;
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                 
                   PsiT_pR_pMesh[3*Node1 - 2 + MG_OffSet[jLevel]] += Coef;
                   
                   // Node 1, y
                   
                   q[0] = dq0_dy1 * Psi;
                   q[1] = dq1_dy1 * Psi;
                   q[2] = dq2_dy1 * Psi;
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                      
                   PsiT_pR_pMesh[3*Node1 - 1 + MG_OffSet[jLevel]] += Coef;
                                                                         
                   // Node 1, z
                   
                   q[0] = dq0_dz1 * Psi;
                   q[1] = dq1_dz1 * Psi;
                   q[2] = dq2_dz1 * Psi;
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                      
                   PsiT_pR_pMesh[3*Node1     + MG_OffSet[jLevel]] += Coef;
                   
                   // Node 2, x
                   
                   q[0] = dq0_dx2 * Psi;
                   q[1] = dq1_dx2 * Psi;
                   q[2] = dq2_dx2 * Psi;
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                      
                   PsiT_pR_pMesh[3*Node2 - 2 + MG_OffSet[jLevel]] += Coef;
                   
                   // Node 2, y
                   
                   q[0] = dq0_dy2 * Psi;
                   q[1] = dq1_dy2 * Psi;
                   q[2] = dq2_dy2 * Psi;
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                      
                   PsiT_pR_pMesh[3*Node2 - 1 + MG_OffSet[jLevel]] += Coef;
                                                                         
                   // Node 2, z
                   
                   q[0] = dq0_dz2 * Psi;
                   q[1] = dq1_dz2 * Psi;
                   q[2] = dq2_dz2 * Psi;
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                      
                   PsiT_pR_pMesh[3*Node2     + MG_OffSet[jLevel]] += Coef;       
        
                // i loop nodes
         
                   // X
                   
                   q[0] = dq0_dxp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes(); 
                   q[1] = dq1_dxp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes();
                   q[2] = dq2_dxp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes();
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                        
                   for ( k = 1 ; k <= VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes() ; k++ ) {
                      
                      Node1 = VSPGeom().Grid(iLevel).LoopList(iLoop).Node(k);
                                   
                      PsiT_pR_pMesh[3*Node1 - 2 + MG_OffSet[iLevel]] += Coef;     
                   
                   }  
                   
                   // Y
                   
                   q[0] = dq0_dyp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes(); 
                   q[1] = dq1_dyp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes();
                   q[2] = dq2_dyp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes();
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                                     
                   for ( k = 1 ; k <= VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes() ; k++ ) {
                      
                      Node1 = VSPGeom().Grid(iLevel).LoopList(iLoop).Node(k);
                      
                      if ( !VSPGeom().Grid(iLevel).NodeList(Node1).IsSymmetryPlaneNode() ) {
                   
                         PsiT_pR_pMesh[3*Node1 - 1 + MG_OffSet[iLevel]] += Coef;   
                         
                      }
                   
                   }  
                   
                   // Z
                     
                   q[0] = dq0_dzp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes(); 
                   q[1] = dq1_dzp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes();
                   q[2] = dq2_dzp * Psi / VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes();
                   
                   Coef = CalculateMeshPiAdjointExpansionOverLoops(iLevel, iLoop, q);
                                                
                   for ( k = 1 ; k <= VSPGeom().Grid(iLevel).LoopList(iLoop).NumberOfNodes() ; k++ ) {
                      
                      Node1 = VSPGeom().Grid(iLevel).LoopList(iLoop).Node(k);
                   
                      PsiT_pR_pMesh[3*Node1     + MG_OffSet[iLevel]] += Coef;    
                      
                   }                                        

             }
                          
          }
          
       }
       
    }
    
    // Prolongate gradients
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfNodes() ; i_c++ ) {
  
          i_f = VSPGeom().Grid(Level).NodeList(i_c).FineGridNode();

          PsiT_pR_pMesh[3*i_f - 2 + MG_OffSet[Level-1]] += PsiT_pR_pMesh[3*i_c - 2 + MG_OffSet[Level]];
          PsiT_pR_pMesh[3*i_f - 1 + MG_OffSet[Level-1]] += PsiT_pR_pMesh[3*i_c - 1 + MG_OffSet[Level]];
          PsiT_pR_pMesh[3*i_f     + MG_OffSet[Level-1]] += PsiT_pR_pMesh[3*i_c     + MG_OffSet[Level]];
          
       }
       
    }

    // Copy over terms at trailing edge from wakes
    
    for ( i = 1 ; i <= VSPGeom().NumberOfVortexSheets() ; i++ ) {
       
       for ( j = 1 ; j <= VSPGeom().VortexSheet(i).NumberOfTrailingVortices() ; j++ ) {
          
          Node1 = VSPGeom().VortexSheet(i).TrailingVortex(j).TE_Node();
          
          Node2 = VSPGeom().VortexSheet(i).TrailingVortex(j).GlobalNode(1);
  
          PsiT_pR_pMesh[3*Node1 - 2 + MG_OffSet[MGLevel_]] += PsiT_pR_pMesh[3*Node2 - 2 + MG_OffSet[MGLevel_]];
          PsiT_pR_pMesh[3*Node1 - 1 + MG_OffSet[MGLevel_]] += PsiT_pR_pMesh[3*Node2 - 1 + MG_OffSet[MGLevel_]];
          PsiT_pR_pMesh[3*Node1     + MG_OffSet[MGLevel_]] += PsiT_pR_pMesh[3*Node2     + MG_OffSet[MGLevel_]];
         
       }
       
    }     
              
    // Add in the terms due to the gradients of the surface normal
    
    for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; Loop++ ) {
       
       Psi = VSPGeom().Grid(MGLevel_).LoopList(Loop).Psi();

       q[0] = VSPGeom().Grid(MGLevel_).LoopList(Loop).U();
       q[1] = VSPGeom().Grid(MGLevel_).LoopList(Loop).V();
       q[2] = VSPGeom().Grid(MGLevel_).LoopList(Loop).W();
       
       NormalGradients = new double[9*VSPGeom().Grid(Level).LoopList(Loop).NumberOfNodes() + 1];
       
       AreaGradients = new double[3*VSPGeom().Grid(Level).LoopList(Loop).NumberOfNodes() + 1];

       CalculateLoopNormalGradients_wrt_Mesh(MGLevel_,Loop,NormalGradients,AreaGradients);
 
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() ; i++ ) {
          
          Node = VSPGeom().Grid(MGLevel_).LoopList(Loop).Node(i);
          
          SymFact = 1.;
          
          if ( VSPGeom().Grid(MGLevel_).NodeList(Node).IsSymmetryPlaneNode() ) SymFact = 0.;

          PsiT_pR_pMesh[3*Node - 2 + MG_OffSet[MGLevel_]] +=         ( q[0] * NormalGradients[9*i - 8] + q[1] * NormalGradients[9*i - 5] + q[2] * NormalGradients[9*i - 2] )*Psi;
          PsiT_pR_pMesh[3*Node - 1 + MG_OffSet[MGLevel_]] += SymFact*( q[0] * NormalGradients[9*i - 7] + q[1] * NormalGradients[9*i - 4] + q[2] * NormalGradients[9*i - 1] )*Psi;
          PsiT_pR_pMesh[3*Node     + MG_OffSet[MGLevel_]] +=         ( q[0] * NormalGradients[9*i - 6] + q[1] * NormalGradients[9*i - 3] + q[2] * NormalGradients[9*i    ] )*Psi;

       }
       
       delete [] NormalGradients;
       delete [] AreaGradients;
       
    }    
    
    // Add in terms due to body rotation
    
    int p, g, *ComponentGroup;
    double OVec[3], RVec[3], TVec[3], pVelocity[3], pForce[3];
    double Omega, Angle, Fact;  
    QUAT Quat, InvQuat, Vec1, pVec1_pXYZC, Vec2, pVec2_pXYZC, BodyVelocity, WQuat;
    QUAT pBodyVelocity_pXYZC; 
         
    ComponentGroup = new int[VSPGeom().NumberOfComponents() + 1];

    for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {

       for ( j = 1 ; j <= VSPGeom().ComponentGroupList(g).NumberOfComponents() ; j++ ) {
       
          ComponentGroup[VSPGeom().ComponentGroupList(g).ComponentList(j)] = g;
          
       }
       
    }
              
    for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; Loop++ ) {
       
       g = ComponentGroup[VSPGeom().Grid(MGLevel_).LoopList(Loop).ComponentID()];
       
       if ( VSPGeom().ComponentGroupList(g).GeometryIsARotor() ) {
       
          OVec[0] = VSPGeom().ComponentGroupList(g).OVec(0); // Rotation origin
          OVec[1] = VSPGeom().ComponentGroupList(g).OVec(1);
          OVec[2] = VSPGeom().ComponentGroupList(g).OVec(2);
                                                
          RVec[0] = VSPGeom().ComponentGroupList(g).RVec(0); // Rotation vector
          RVec[1] = VSPGeom().ComponentGroupList(g).RVec(1);
          RVec[2] = VSPGeom().ComponentGroupList(g).RVec(2);
                                                
          TVec[0] = VSPGeom().ComponentGroupList(g).TVec(0); // Translation vector
          TVec[1] = VSPGeom().ComponentGroupList(g).TVec(1);
          TVec[2] = VSPGeom().ComponentGroupList(g).TVec(2);
          
          VSPGeom().ComponentGroupList(g).Update();
   
          Quat = VSPGeom().ComponentGroupList(g).Quat();
          
          InvQuat = VSPGeom().ComponentGroupList(g).InvQuat();
          
          WQuat = VSPGeom().ComponentGroupList(g).WQuat();
                 
          // Calculate surface velocity for edge centroids
          
          Vec1(0) = VSPGeom().Grid(MGLevel_).LoopList(Loop).Xc() - OVec[0];
          Vec1(1) = VSPGeom().Grid(MGLevel_).LoopList(Loop).Yc() - OVec[1];
          Vec1(2) = VSPGeom().Grid(MGLevel_).LoopList(Loop).Zc() - OVec[2];

          Psi = VSPGeom().Grid(MGLevel_).LoopList(Loop).Psi();

          for ( p = 0 ; p <= 2 ; p++ ) {
          
             pVec1_pXYZC(0) = 0.;
             pVec1_pXYZC(1) = 0.;
             pVec1_pXYZC(2) = 0.;
                      
             pVec1_pXYZC(p) = 1.;
      
             // Body point location after rotation
             
             Vec2 = Quat * Vec1 * InvQuat;
             
             pVec2_pXYZC = Quat * pVec1_pXYZC * InvQuat;

             // Body point velocity
             
             BodyVelocity = WQuat * Vec2;
             
             pBodyVelocity_pXYZC = WQuat * pVec2_pXYZC;
             
             pVelocity[0] = -pBodyVelocity_pXYZC(0);
             pVelocity[1] = -pBodyVelocity_pXYZC(1);
             pVelocity[2] = -pBodyVelocity_pXYZC(2);

             Fact = 1./VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes();
                  
             for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() ; i++ ) {
       
                Node = VSPGeom().Grid(MGLevel_).LoopList(Loop).Node(i);
       
                if ( p == 0 ) {
               
                   PsiT_pR_pMesh[3*Node - 2 + MG_OffSet[MGLevel_]] +=         Fact*( pVelocity[0] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nx()
                                                                                   + pVelocity[1] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Ny()
                                                                                   + pVelocity[2] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nz() )*Psi;
                }
                
                else if ( p == 1 ) {
                   
                   PsiT_pR_pMesh[3*Node - 1 + MG_OffSet[MGLevel_]] += SymFact*Fact*( pVelocity[0] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nx()
                                                                                   + pVelocity[1] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Ny()
                                                                                   + pVelocity[2] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nz() )*Psi;
                }
                
                else if ( p == 2 ) {
                   
                   PsiT_pR_pMesh[3*Node     + MG_OffSet[MGLevel_]] +=         Fact*( pVelocity[0] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nx()
                                                                                   + pVelocity[1] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Ny()
                                                                                   + pVelocity[2] * VSPGeom().Grid(MGLevel_).LoopList(Loop).Nz() )*Psi;

                }  
               
             }
             
          }             

       }
       
    }        
    
    delete [] ComponentGroup;
    
    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {

       j = i;
       
       PsiT_pR_pMesh_[3*i-2] += PsiT_pR_pMesh[3*j-2 + MG_OffSet[MGLevel_]];
       PsiT_pR_pMesh_[3*i-1] += PsiT_pR_pMesh[3*j-1 + MG_OffSet[MGLevel_]];
       PsiT_pR_pMesh_[3*i  ] += PsiT_pR_pMesh[3*j   + MG_OffSet[MGLevel_]];
       
    }
    
    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] PsiT_pR_pMesh;
   
}

/*##############################################################################
#                                                                              #
#       VSP_SOLVER CalculatePsiT_PartialResidualPartialMesh_WakeEquations      #
#                                                                              #
#            [              ]                                                  # 
#  [Psi]^T x [ pRWake_pMesh ]                                                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculatePsiT_PartialResidualPartialMesh_WakeEquations(void)
{
    
    int i, j, MaxLoopTypes, LoopType, Level, Edge, jLevel, *MG_OffSet;
    int i_c, i_f, Node1, Node2, NodeC, NodeF, ArraySize, Node, Eqn;
    double q[3], Coef[9], xyz[3], *PsiT_pR_pMesh, Psi[3];
    
    double dq0_dx1;
    double dq0_dy1;
    double dq0_dz1;
    double dq0_dx2;
    double dq0_dy2;
    double dq0_dz2;
                         
    double dq1_dx1;
    double dq1_dy1;
    double dq1_dz1;
    double dq1_dx2;
    double dq1_dy2;
    double dq1_dz2;
                         
    double dq2_dx1;
    double dq2_dy1;
    double dq2_dz1;
    double dq2_dx2;
    double dq2_dy2;
    double dq2_dz2; 
    
    double dq0_dxp;
    double dq0_dyp;
    double dq0_dzp;
                          
    double dq1_dxp;
    double dq1_dyp;
    double dq1_dzp;
                          
    double dq2_dxp;
    double dq2_dyp;
    double dq2_dzp;     
                                              
    double dq0_dMach;
    double dq1_dMach;
    double dq2_dMach;   

    // Symmetry
    
    double dq0_dx1_s;
    double dq0_dy1_s;
    double dq0_dz1_s;
    double dq0_dx2_s;
    double dq0_dy2_s;
    double dq0_dz2_s;
                         
    double dq1_dx1_s;
    double dq1_dy1_s;
    double dq1_dz1_s;
    double dq1_dx2_s;
    double dq1_dy2_s;
    double dq1_dz2_s;
                         
    double dq2_dx1_s;
    double dq2_dy1_s;
    double dq2_dz1_s;
    double dq2_dx2_s;
    double dq2_dy2_s;
    double dq2_dz2_s; 
                        
    double dq0_dxp_s;
    double dq0_dyp_s;
    double dq0_dzp_s;
                         
    double dq1_dxp_s;
    double dq1_dyp_s;
    double dq1_dzp_s;
                         
    double dq2_dxp_s;
    double dq2_dyp_s;
    double dq2_dzp_s;     
                                              
    double dq0_dMach_s;
    double dq1_dMach_s;
    double dq2_dMach_s;   
            
    VSP_EDGE *VortexEdge;

    // MG offset array
    
    MG_OffSet = new int[NumberOfMGLevels_ + 2];
    
    MG_OffSet[0] = 0;
    
    for ( i = 1 ; i <= NumberOfMGLevels_ + 1 ; i++ ) {
       
       MG_OffSet[i] = MG_OffSet[i-1] + 3*VSPGeom().Grid(i-1).NumberOfNodes();
       
    }
    
    // Partial wrt mesh accumalation array
       
    ArraySize = MG_OffSet[NumberOfMGLevels_+1] + 1;
       
    PsiT_pR_pMesh = new double[ArraySize];
    
    zero_double_array(PsiT_pR_pMesh, ArraySize-1);
        
    MaxLoopTypes = 0;

    // Mesh perturbation induced gamma perturbation velocities across wake loops

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#ifdef _OPENMP
#if _OPENMP >= 201511
#pragma omp parallel for reduction(+:PsiT_pR_pMesh[:ArraySize]) private(Level,Edge,Node1,Node2,Psi,j,jLevel,VortexEdge,\
                                                                                                               dq0_dx1,\
                                                                                                               dq0_dy1,\
                                                                                                               dq0_dz1,\
                                                                                                               dq0_dx2,\
                                                                                                               dq0_dy2,\
                                                                                                               dq0_dz2,\
                                                                                                               dq1_dx1,\
                                                                                                               dq1_dy1,\
                                                                                                               dq1_dz1,\
                                                                                                               dq1_dx2,\
                                                                                                               dq1_dy2,\
                                                                                                               dq1_dz2,\
                                                                                                               dq2_dx1,\
                                                                                                               dq2_dy1,\
                                                                                                               dq2_dz1,\
                                                                                                               dq2_dx2,\
                                                                                                               dq2_dy2,\
                                                                                                               dq2_dz2,\
                                                                                                               dq0_dxp,\
                                                                                                               dq0_dyp,\
                                                                                                               dq0_dzp,\
                                                                                                               dq1_dxp,\
                                                                                                               dq1_dyp,\
                                                                                                               dq1_dzp,\
                                                                                                               dq2_dxp,\
                                                                                                               dq2_dyp,\
                                                                                                               dq2_dzp,\
                                                                                                               dq0_dMach,\
                                                                                                               dq1_dMach,\
                                                                                                               dq2_dMach,\
                                                                                                               dq0_dx1_s,\
                                                                                                               dq0_dy1_s,\
                                                                                                               dq0_dz1_s,\
                                                                                                               dq0_dx2_s,\
                                                                                                               dq0_dy2_s,\
                                                                                                               dq0_dz2_s,\
                                                                                                               dq1_dx1_s,\
                                                                                                               dq1_dy1_s,\
                                                                                                               dq1_dz1_s,\
                                                                                                               dq1_dx2_s,\
                                                                                                               dq1_dy2_s,\
                                                                                                               dq1_dz2_s,\
                                                                                                               dq2_dx1_s,\
                                                                                                               dq2_dy1_s,\
                                                                                                               dq2_dz1_s,\
                                                                                                               dq2_dx2_s,\
                                                                                                               dq2_dy2_s,\
                                                                                                               dq2_dz2_s,\
                                                                                                               dq0_dxp_s,\
                                                                                                               dq0_dyp_s,\
                                                                                                               dq0_dzp_s,\
                                                                                                               dq1_dxp_s,\
                                                                                                               dq1_dyp_s,\
                                                                                                               dq1_dzp_s,\
                                                                                                               dq2_dxp_s,\
                                                                                                               dq2_dyp_s,\
                                                                                                               dq2_dzp_s,\
                                                                                                               dq0_dMach_s,\
                                                                                                               dq1_dMach_s,\
                                                                                                               dq2_dMach_s,\
                                                                                                               xyz,Coef) schedule(dynamic)    
#endif
#endif
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
   
          Level = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          Edge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          // Only need to calculate perturbation wrt to mesh on wakes

          if ( VSPGeom().Grid(Level).EdgeList(Edge).SurfaceID() == 0 && VSPGeom().Grid(Level).EdgeList(Edge).IsWakeEdge()  ) {
   
             Node1 = VSPGeom().Grid(Level).EdgeList(Edge).Node1();
             Node2 = VSPGeom().Grid(Level).EdgeList(Edge).Node2();
             
             if ( VSPGeom().Grid(Level).EdgeList(Edge).WakeEdgeData().Direction() > 0 ) {
                
                Psi[0] = VSPGeom().Grid(Level).NodeList(Node2).Psi(0);
                Psi[1] = VSPGeom().Grid(Level).NodeList(Node2).Psi(1);
                Psi[2] = VSPGeom().Grid(Level).NodeList(Node2).Psi(2);
                
             }
             
             else {
                
                Psi[0] = VSPGeom().Grid(Level).NodeList(Node1).Psi(0);
                Psi[1] = VSPGeom().Grid(Level).NodeList(Node1).Psi(1);
                Psi[2] = VSPGeom().Grid(Level).NodeList(Node1).Psi(2);
                
             }
               
             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
      
                jLevel = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j)->Level();
      
                VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

                VortexEdge->dInducedVelocity_dMesh_Transpose(VSPGeom().Grid(Level).EdgeList(Edge).xyz_c(), 
                                                             dq0_dx1,
                                                             dq0_dy1,
                                                             dq0_dz1,
                                                             dq0_dx2,
                                                             dq0_dy2,
                                                             dq0_dz2,
                                                             
                                                             dq1_dx1,
                                                             dq1_dy1,
                                                             dq1_dz1,
                                                             dq1_dx2,
                                                             dq1_dy2,
                                                             dq1_dz2,
                                                             
                                                             dq2_dx1,
                                                             dq2_dy1,
                                                             dq2_dz1,
                                                             dq2_dx2,
                                                             dq2_dy2,
                                                             dq2_dz2,
                                                             
                                                             dq0_dxp,
                                                             dq0_dyp,
                                                             dq0_dzp,
                                                                
                                                             dq1_dxp,
                                                             dq1_dyp,
                                                             dq1_dzp,
                                                                  
                                                             dq2_dxp,
                                                             dq2_dyp,
                                                             dq2_dzp,
                                                             
                                                             dq0_dMach,
                                                             dq1_dMach,
                                                             dq2_dMach);                                                                         

                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] =  VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                   xyz[1] = -VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                   xyz[2] =  VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
                  
                   VortexEdge->dInducedVelocity_dMesh_Transpose(xyz, 
                                                                dq0_dx1_s,
                                                                dq0_dy1_s,
                                                                dq0_dz1_s,
                                                                dq0_dx2_s,
                                                                dq0_dy2_s,
                                                                dq0_dz2_s,
                                                                      
                                                                dq1_dx1_s,
                                                                dq1_dy1_s,
                                                                dq1_dz1_s,
                                                                dq1_dx2_s,
                                                                dq1_dy2_s,
                                                                dq1_dz2_s,
                                                                      
                                                                dq2_dx1_s,
                                                                dq2_dy1_s,
                                                                dq2_dz1_s,
                                                                dq2_dx2_s,
                                                                dq2_dy2_s,
                                                                dq2_dz2_s,
                                                                       
                                                                dq0_dxp_s,
                                                                dq0_dyp_s,
                                                                dq0_dzp_s,
                                                                     
                                                                dq1_dxp_s,
                                                                dq1_dyp_s,
                                                                dq1_dzp_s,
                                                                     
                                                                dq2_dxp_s,
                                                                dq2_dyp_s,
                                                                dq2_dzp_s,
                                                                
                                                                dq0_dMach_s,
                                                                dq1_dMach_s,
                                                                dq2_dMach_s);    

                   dq0_dx1 += dq0_dx1_s;
                   dq0_dy1 -= dq0_dy1_s;
                   dq0_dz1 += dq0_dz1_s;
                   dq0_dx2 += dq0_dx2_s;
                   dq0_dy2 -= dq0_dy2_s;
                   dq0_dz2 += dq0_dz2_s;
                                
                   dq1_dx1 -= dq1_dx1_s;
                   dq1_dy1 += dq1_dy1_s;
                   dq1_dz1 -= dq1_dz1_s;
                   dq1_dx2 -= dq1_dx2_s;
                   dq1_dy2 += dq1_dy2_s;
                   dq1_dz2 -= dq1_dz2_s;
                          
                   dq2_dx1 += dq2_dx1_s;
                   dq2_dy1 -= dq2_dy1_s;
                   dq2_dz1 += dq2_dz1_s;
                   dq2_dx2 += dq2_dx2_s;
                   dq2_dy2 -= dq2_dy2_s;
                   dq2_dz2 += dq2_dz2_s;
                              
                   dq0_dxp += dq0_dxp_s;
                   dq0_dyp -= dq0_dyp_s;
                   dq0_dzp += dq0_dzp_s;
                              
                   dq1_dxp -= dq1_dxp_s;
                   dq1_dyp += dq1_dyp_s;
                   dq1_dzp -= dq1_dzp_s;
                           
                   dq2_dxp += dq2_dxp_s;
                   dq2_dyp -= dq2_dyp_s;
                   dq2_dzp += dq2_dzp_s;
                   
                   dq0_dMach += dq0_dMach_s;
                   dq1_dMach -= dq1_dMach_s;
                   dq2_dMach += dq2_dMach_s;   
                   
                } 
                
                if ( !TimeAccurate_ ) {
                                                                                                                                                                                                                  
                   VSPGeom().Grid(Level).EdgeList(Edge).PsiT_pR_pMesh(dq0_dx1,
                                                                      dq0_dy1,
                                                                      dq0_dz1,
                                                                      dq0_dx2,
                                                                      dq0_dy2,
                                                                      dq0_dz2,
                                                                      
                                                                      dq1_dx1,
                                                                      dq1_dy1,
                                                                      dq1_dz1,
                                                                      dq1_dx2,
                                                                      dq1_dy2,
                                                                      dq1_dz2,
                                                                      
                                                                      dq2_dx1,
                                                                      dq2_dy1,
                                                                      dq2_dz1,
                                                                      dq2_dx2,
                                                                      dq2_dy2,
                                                                      dq2_dz2,
                                                                      
                                                                      dq0_dxp,
                                                                      dq0_dyp,
                                                                      dq0_dzp,
                                                                         
                                                                      dq1_dxp,
                                                                      dq1_dyp,
                                                                      dq1_dzp,
                                                                           
                                                                      dq2_dxp,
                                                                      dq2_dyp,
                                                                      dq2_dzp,    
                                                                      
                                                                      Psi, 
                                                                                                                                      
                                                                      Coef);     
                                                                      
                }
                
                else {
                   
                   VSPGeom().Grid(Level).EdgeList(Edge).UnsteadyPsiT_pR_pMesh(dq0_dx1,
                                                                              dq0_dy1,
                                                                              dq0_dz1,
                                                                              dq0_dx2,
                                                                              dq0_dy2,
                                                                              dq0_dz2,
                                                                              
                                                                              dq1_dx1,
                                                                              dq1_dy1,
                                                                              dq1_dz1,
                                                                              dq1_dx2,
                                                                              dq1_dy2,
                                                                              dq1_dz2,
                                                                              
                                                                              dq2_dx1,
                                                                              dq2_dy1,
                                                                              dq2_dz1,
                                                                              dq2_dx2,
                                                                              dq2_dy2,
                                                                              dq2_dz2,
                                                                              
                                                                              dq0_dxp,
                                                                              dq0_dyp,
                                                                              dq0_dzp,
                                                                                 
                                                                              dq1_dxp,
                                                                              dq1_dyp,
                                                                              dq1_dzp,
                                                                                   
                                                                              dq2_dxp,
                                                                              dq2_dyp,
                                                                              dq2_dzp,    
                                                                              
                                                                              Psi, 
                                                                              
                                                                              DeltaTime_,
                                                                                                                                              
                                                                              Coef);     
                                                                      
                }                   
     
                // j nodes
                                                                                            
                   Node1 = VortexEdge->Node1();
                   Node2 = VortexEdge->Node2();
                      
                   // j Node 1
                         
                   PsiT_pR_pMesh[3*Node1 - 2 + MG_OffSet[jLevel]] += Coef[0];
                   PsiT_pR_pMesh[3*Node1 - 1 + MG_OffSet[jLevel]] += Coef[1];
                   PsiT_pR_pMesh[3*Node1     + MG_OffSet[jLevel]] += Coef[2];

                   // j Node 2
                         
                   PsiT_pR_pMesh[3*Node2 - 2 + MG_OffSet[jLevel]] += Coef[3];
                   PsiT_pR_pMesh[3*Node2 - 1 + MG_OffSet[jLevel]] += Coef[4];
                   PsiT_pR_pMesh[3*Node2     + MG_OffSet[jLevel]] += Coef[5];

                // i nodes

                   Node1 = VSPGeom().Grid(Level).EdgeList(Edge).Node1();
                   Node2 = VSPGeom().Grid(Level).EdgeList(Edge).Node2();
                      
                   // i Node 1

                   PsiT_pR_pMesh[3*Node1 - 2 + MG_OffSet[Level]] += Coef[6];
                   
                   if ( !VSPGeom().Grid(Level).NodeList(Node1).IsSymmetryPlaneNode() ) {
                      
                      PsiT_pR_pMesh[3*Node1 - 1 + MG_OffSet[Level]] += Coef[7];
                   
                   }
                   
                   PsiT_pR_pMesh[3*Node1     + MG_OffSet[Level]] += Coef[8];
    
                   // i Node 2
                         
                   PsiT_pR_pMesh[3*Node2 - 2 + MG_OffSet[Level]] += Coef[6];
                   
                   if ( !VSPGeom().Grid(Level).NodeList(Node2).IsSymmetryPlaneNode() ) {
                      
                      PsiT_pR_pMesh[3*Node2 - 1 + MG_OffSet[Level]] += Coef[7];
                      
                   }
                   
                   PsiT_pR_pMesh[3*Node2     + MG_OffSet[Level]] += Coef[8];
                          
             }
             
          }

       }   
       
    }    

    // Prolongate gradients
    
    for ( Level = NumberOfMGLevels_ ; Level > 1 ; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfNodes() ; i_c++ ) {
     
          i_f = VSPGeom().Grid(Level).NodeList(i_c).FineGridNode();
     
          PsiT_pR_pMesh[3*i_f - 2 + MG_OffSet[Level-1]] += PsiT_pR_pMesh[3*i_c - 2 + MG_OffSet[Level]];
          PsiT_pR_pMesh[3*i_f - 1 + MG_OffSet[Level-1]] += PsiT_pR_pMesh[3*i_c - 1 + MG_OffSet[Level]];
          PsiT_pR_pMesh[3*i_f     + MG_OffSet[Level-1]] += PsiT_pR_pMesh[3*i_c     + MG_OffSet[Level]];
          
       }
       
    }

    // Copy over terms at trailing edge from wakes
    
    for ( i = 1 ; i <= VSPGeom().NumberOfVortexSheets() ; i++ ) {
       
       for ( j = 1 ; j <= VSPGeom().VortexSheet(i).NumberOfTrailingVortices() ; j++ ) {
          
          Node1 = VSPGeom().VortexSheet(i).TrailingVortex(j).TE_Node();
          
          Node2 = VSPGeom().VortexSheet(i).TrailingVortex(j).GlobalNode(1);
  
          PsiT_pR_pMesh[3*Node1 - 2 + MG_OffSet[MGLevel_]] += PsiT_pR_pMesh[3*Node2 - 2 + MG_OffSet[MGLevel_]];
          PsiT_pR_pMesh[3*Node1 - 1 + MG_OffSet[MGLevel_]] += PsiT_pR_pMesh[3*Node2 - 1 + MG_OffSet[MGLevel_]];
          PsiT_pR_pMesh[3*Node1     + MG_OffSet[MGLevel_]] += PsiT_pR_pMesh[3*Node2     + MG_OffSet[MGLevel_]];
         
       }
       
    }   

    // Add in trailing edge equation terms
    
    if ( !TimeAccurate_ ) {
       
       for ( i = 1 ; i <= VSPGeom().NumberOfVortexSheets() ; i++ ) {
          
          for ( j = 1 ; j <= VSPGeom().VortexSheet(i).NumberOfTrailingVortices() ; j++ ) {
             
             Node = VSPGeom().VortexSheet(i).TrailingVortex(j).TE_Node();
             
             Eqn = VSPGeom().VortexSheet(i).TrailingVortex(j).WakeResidualEquationNumberX(2);
             
             if ( !VSPGeom().VortexSheet(i).TrailingVortex(j).IsARotor() ) {
           
                PsiT_pR_pMesh[3*Node - 2 + MG_OffSet[MGLevel_]] -= CurrentPsi_[Eqn    ];
                PsiT_pR_pMesh[3*Node - 1 + MG_OffSet[MGLevel_]] -= CurrentPsi_[Eqn + 1]; 
                PsiT_pR_pMesh[3*Node     + MG_OffSet[MGLevel_]] -= CurrentPsi_[Eqn + 2];   
                
             }
             
             else {
                
               PsiT_pR_pMesh[3*Node - 2 + MG_OffSet[MGLevel_]] -= CurrentPsi_[Eqn    ] * VSPGeom().VortexSheet(i).TrailingVortex(j).RotorThrustVector(0) * VSPGeom().VortexSheet(i).TrailingVortex(j).RotorThrustVector(0);
               PsiT_pR_pMesh[3*Node - 1 + MG_OffSet[MGLevel_]] -= CurrentPsi_[Eqn + 1] * VSPGeom().VortexSheet(i).TrailingVortex(j).RotorThrustVector(1) * VSPGeom().VortexSheet(i).TrailingVortex(j).RotorThrustVector(1);
               PsiT_pR_pMesh[3*Node     + MG_OffSet[MGLevel_]] -= CurrentPsi_[Eqn + 2] * VSPGeom().VortexSheet(i).TrailingVortex(j).RotorThrustVector(2) * VSPGeom().VortexSheet(i).TrailingVortex(j).RotorThrustVector(2);
  
             }
            
          }
          
       }   
       
    } 
    
    // Need to add in body rotation terms

    if ( !TimeAccurate_ ) {
    
       int g, p;
       double OVec[3], RVec[3], TVec[3], pVelocity[3], pForce[3];
       double Omega, Angle;
       double pResidual_pVinf[3][3];  
       QUAT Quat, InvQuat, Vec1, pVec1_pXYZC, Vec2, pVec2_pXYZC, BodyVelocity, WQuat;
       QUAT pBodyVelocity_pXYZC; 
   
       for ( i = 1 ; i <= VSPGeom().NumberOfVortexSheets() ; i++ ) {
          
          for ( j = 1 ; j <= VSPGeom().VortexSheet(i).NumberOfTrailingVortices() ; j++ ) {
             
             if ( VSPGeom().VortexSheet(i).TrailingVortex(j).IsARotor() ) {
   
                Node = VSPGeom().VortexSheet(i).TrailingVortex(j).TE_Node();
                
                Edge = VSPGeom().VortexSheet(i).TrailingVortex(j).GlobalEdge(1);
   
                g = VSPGeom().VortexSheet(i).TrailingVortex(j).Group();
   
                OVec[0] = VSPGeom().ComponentGroupList(g).OVec(0); // Rotation origin
                OVec[1] = VSPGeom().ComponentGroupList(g).OVec(1);
                OVec[2] = VSPGeom().ComponentGroupList(g).OVec(2);
                                                      
                RVec[0] = VSPGeom().ComponentGroupList(g).RVec(0); // Rotation vector
                RVec[1] = VSPGeom().ComponentGroupList(g).RVec(1);
                RVec[2] = VSPGeom().ComponentGroupList(g).RVec(2);
                                                      
                TVec[0] = VSPGeom().ComponentGroupList(g).TVec(0); // Translation vector
                TVec[1] = VSPGeom().ComponentGroupList(g).TVec(1);
                TVec[2] = VSPGeom().ComponentGroupList(g).TVec(2);
                
                VSPGeom().ComponentGroupList(g).Update();
                
                Quat = VSPGeom().ComponentGroupList(g).Quat();
                
                InvQuat = VSPGeom().ComponentGroupList(g).InvQuat();
                
                WQuat = VSPGeom().ComponentGroupList(g).WQuat();
                
                // Calculate surface velocity for edge centroids
                
                Vec1(0) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - OVec[0];
                Vec1(1) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - OVec[1];
                Vec1(2) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - OVec[2];
             
                VSPGeom().Grid(MGLevel_).EdgeList(Edge).Wake_pResidual_pVinf(pResidual_pVinf);
                
                Psi[0] = CurrentPsi_[VSPGeom().VortexSheet(i).TrailingVortex(j).WakeResidualEquationNumberX(2)];
                Psi[1] = CurrentPsi_[VSPGeom().VortexSheet(i).TrailingVortex(j).WakeResidualEquationNumberY(2)];
                Psi[2] = CurrentPsi_[VSPGeom().VortexSheet(i).TrailingVortex(j).WakeResidualEquationNumberZ(2)];
   
                for ( p = 0 ; p <= 2 ; p++ ) {
                
                   pVec1_pXYZC(0) = 0.;
                   pVec1_pXYZC(1) = 0.;
                   pVec1_pXYZC(2) = 0.;
                            
                   pVec1_pXYZC(p) = 1.;
            
                   // Body point location after rotation
                   
                   Vec2 = Quat * Vec1 * InvQuat;
                   
                   pVec2_pXYZC = Quat * pVec1_pXYZC * InvQuat;
      
                   // Body point velocity
                   
                   BodyVelocity = WQuat * Vec2;
                   
                   pBodyVelocity_pXYZC = WQuat * pVec2_pXYZC;
                   
                   pVelocity[0] = -pBodyVelocity_pXYZC(0);
                   pVelocity[1] = -pBodyVelocity_pXYZC(1);
                   pVelocity[2] = -pBodyVelocity_pXYZC(2);
                
                   if ( p == 0 ) {
                                                                                                
                      PsiT_pR_pMesh[3*Node - 2 + MG_OffSet[MGLevel_]] -= 0.5 * Psi[0] * ( pResidual_pVinf[0][0] * pVelocity[0] + pResidual_pVinf[0][1] * pVelocity[1] + pResidual_pVinf[0][2] * pVelocity[2] );
                      PsiT_pR_pMesh[3*Node - 2 + MG_OffSet[MGLevel_]] -= 0.5 * Psi[1] * ( pResidual_pVinf[1][0] * pVelocity[0] + pResidual_pVinf[1][1] * pVelocity[1] + pResidual_pVinf[1][2] * pVelocity[2] );
                      PsiT_pR_pMesh[3*Node - 2 + MG_OffSet[MGLevel_]] -= 0.5 * Psi[2] * ( pResidual_pVinf[2][0] * pVelocity[0] + pResidual_pVinf[2][1] * pVelocity[1] + pResidual_pVinf[2][2] * pVelocity[2] );
                   
                   }
                   
                   else if ( p == 1 ) {
                      
                      PsiT_pR_pMesh[3*Node - 1 + MG_OffSet[MGLevel_]] -= 0.5 * Psi[0] * ( pResidual_pVinf[0][0] * pVelocity[0] + pResidual_pVinf[0][1] * pVelocity[1] + pResidual_pVinf[0][2] * pVelocity[2] );
                      PsiT_pR_pMesh[3*Node - 1 + MG_OffSet[MGLevel_]] -= 0.5 * Psi[1] * ( pResidual_pVinf[1][0] * pVelocity[0] + pResidual_pVinf[1][1] * pVelocity[1] + pResidual_pVinf[1][2] * pVelocity[2] );
                      PsiT_pR_pMesh[3*Node - 1 + MG_OffSet[MGLevel_]] -= 0.5 * Psi[2] * ( pResidual_pVinf[2][0] * pVelocity[0] + pResidual_pVinf[2][1] * pVelocity[1] + pResidual_pVinf[2][2] * pVelocity[2] );
                   
                   }    
                   
                   else if ( p == 2 ) {               
                      
                      PsiT_pR_pMesh[3*Node     + MG_OffSet[MGLevel_]] -= 0.5 * Psi[0] * ( pResidual_pVinf[0][0] * pVelocity[0] + pResidual_pVinf[0][1] * pVelocity[1] + pResidual_pVinf[0][2] * pVelocity[2] );
                      PsiT_pR_pMesh[3*Node     + MG_OffSet[MGLevel_]] -= 0.5 * Psi[1] * ( pResidual_pVinf[1][0] * pVelocity[0] + pResidual_pVinf[1][1] * pVelocity[1] + pResidual_pVinf[1][2] * pVelocity[2] );
                      PsiT_pR_pMesh[3*Node     + MG_OffSet[MGLevel_]] -= 0.5 * Psi[2] * ( pResidual_pVinf[2][0] * pVelocity[0] + pResidual_pVinf[2][1] * pVelocity[1] + pResidual_pVinf[2][2] * pVelocity[2] );
                   
                   }    
                                   
                }
                
             }
             
          }
     
       }      
       
    }
    
    // Copy over results

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {

       j = i;
       
       PsiT_pR_pMesh_[3*i-2] = PsiT_pR_pMesh[3*j-2 + MG_OffSet[MGLevel_]];
       PsiT_pR_pMesh_[3*i-1] = PsiT_pR_pMesh[3*j-1 + MG_OffSet[MGLevel_]];
       PsiT_pR_pMesh_[3*i  ] = PsiT_pR_pMesh[3*j   + MG_OffSet[MGLevel_]];
       
    }
      
    // Free up memory    
    
    delete [] MG_OffSet;
    delete [] PsiT_pR_pMesh;
           
}

/*##############################################################################
#                                                                              #
#       VSP_SOLVER CalculatePsiT_PartialResidualPartialMesh_StallEquations     #
#                                                                              #
#            [               ]                                                 # 
#  [Psi]^T x [ pRStall_pMesh ]                                                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculatePsiT_PartialResidualPartialMesh_StallEquations(void)
{
   
    int i, k, LE_Edge, TE_Edge, Sign, Node1, Node2;
    double GammaTE, Chord, Velocity, Cl_Ratio, dCl_Ratio_dGammaTE;
    double Fstall, pFstall_pX, dCl_Ratio_dChord, dABS_Cl_Ratio_dCl_Ratio;
    double XYZ_TEc[3], XYZ_LEc[3], pChord_pXYZ_TEc[3], pChord_pXYZ_LEc[3];
    double dR_dXYZ_LEc[3], dR_dXYZ_TEc[3], Psi;

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          LE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).LE_Edge());

          TE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
          
          Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());

          GammaTE = Sign * VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Gamma();
          
          Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
          
          Psi = VSPGeom().VortexSheet(k).TrailingVortex(i).Psi();
          
          Velocity = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[0], 2.)
                         + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[1], 2.)
                         + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[2], 2.) );

          // Leading edge mid point
                         
          XYZ_LEc[0] = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Xc();
          XYZ_LEc[1] = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Yc();
          XYZ_LEc[2] = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Zc();
          
          // Trailing edge mid point
          
          XYZ_TEc[0] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc();
          XYZ_TEc[1] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc();
          XYZ_TEc[2] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc();
          
          // Partials wrt leading edge mid point
          
          pChord_pXYZ_LEc[0] =  (XYZ_LEc[0] - XYZ_TEc[0])/Chord;
          pChord_pXYZ_LEc[1] =  (XYZ_LEc[1] - XYZ_TEc[1])/Chord;
          pChord_pXYZ_LEc[2] =  (XYZ_LEc[2] - XYZ_TEc[2])/Chord;
                    
          // Partials wrt trailing edge mid point
          
          pChord_pXYZ_TEc[0] = -(XYZ_LEc[0] - XYZ_TEc[0])/Chord;
          pChord_pXYZ_TEc[1] = -(XYZ_LEc[1] - XYZ_TEc[1])/Chord;
          pChord_pXYZ_TEc[2] = -(XYZ_LEc[2] - XYZ_TEc[2])/Chord;

          if ( Velocity > 0. ) {
            
             Cl_Ratio = GammaTE / ( 0.5 * Chord * Velocity * Clmax_2d_ );
             
             dCl_Ratio_dChord = -GammaTE / ( 0.5 * Chord * Chord * Velocity * Clmax_2d_ );

             StallFunction(ABS(Cl_Ratio),Fstall,pFstall_pX);
             
             dABS_Cl_Ratio_dCl_Ratio = 1.;
             
             if ( Cl_Ratio < 0. ) dABS_Cl_Ratio_dCl_Ratio = -1.;

             dR_dXYZ_TEc[0] = -pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dChord * pChord_pXYZ_TEc[0];
             dR_dXYZ_TEc[1] = -pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dChord * pChord_pXYZ_TEc[1];
             dR_dXYZ_TEc[2] = -pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dChord * pChord_pXYZ_TEc[2];
                             
             dR_dXYZ_LEc[0] = -pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dChord * pChord_pXYZ_LEc[0];
             dR_dXYZ_LEc[1] = -pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dChord * pChord_pXYZ_LEc[1];
             dR_dXYZ_LEc[2] = -pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dChord * pChord_pXYZ_LEc[2];

             // Trailing edge
             
             Node1 = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Node1();
             Node2 = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Node2();
          
             PsiT_pR_pMesh_[3*Node1 - 2] += 0.5*dR_dXYZ_TEc[0] * Psi;
             PsiT_pR_pMesh_[3*Node1 - 1] += 0.5*dR_dXYZ_TEc[1] * Psi;
             PsiT_pR_pMesh_[3*Node1    ] += 0.5*dR_dXYZ_TEc[2] * Psi;
                                                            
             PsiT_pR_pMesh_[3*Node2 - 2] += 0.5*dR_dXYZ_TEc[0] * Psi;
             PsiT_pR_pMesh_[3*Node2 - 1] += 0.5*dR_dXYZ_TEc[1] * Psi;
             PsiT_pR_pMesh_[3*Node2    ] += 0.5*dR_dXYZ_TEc[2] * Psi;

             // Leading edge
             
             Node1 = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Node1();
             Node2 = VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Node2();
          
             PsiT_pR_pMesh_[3*Node1 - 2] += 0.5*dR_dXYZ_LEc[0] * Psi;
             PsiT_pR_pMesh_[3*Node1 - 1] += 0.5*dR_dXYZ_LEc[1] * Psi;
             PsiT_pR_pMesh_[3*Node1    ] += 0.5*dR_dXYZ_LEc[2] * Psi;
                                                            
             PsiT_pR_pMesh_[3*Node2 - 2] += 0.5*dR_dXYZ_LEc[0] * Psi;
             PsiT_pR_pMesh_[3*Node2 - 1] += 0.5*dR_dXYZ_LEc[1] * Psi;
             PsiT_pR_pMesh_[3*Node2    ] += 0.5*dR_dXYZ_LEc[2] * Psi;

          }             
          
       }
       
    }

}

/*####################################################################################
#                                                                                    #
# VSP_SOLVER CalculatePsiT_PartialResidualPartialMesh_VortexStretchingRatioEquations #
#                                                                                    #
#            [              ]                                                        # 
#  [Psi]^T x [ pRVortexStretchingRatio_pMesh ]                                       #
#                                                                                    #
####################################################################################*/

void VSP_SOLVER::CalculatePsiT_PartialResidualPartialMesh_VortexStretchingRatioEquations(void)
{

    int i, j, k, VortexStretchingRatioEquationNumber, Loop, Edge, Node1, Node2;
    double Psi;
    
    double pCircumference_pLength;
    double pResidual_pRatio;
    double pResidual_pCircumference;
                               
    double dLength_dX1; 
    double dLength_dY1;
    double dLength_dZ1;
                      
    double dLength_dX2;
    double dLength_dY2;
    double dLength_dZ2;
    
    double dVecX_dX1;
    double dVecX_dY1;
    double dVecX_dZ1;
                     
    double dVecY_dX1;
    double dVecY_dY1;
    double dVecY_dZ1;
                      
    double dVecZ_dX1;
    double dVecZ_dY1;
    double dVecZ_dZ1;
                      
    double dVecX_dX2;
    double dVecX_dY2;
    double dVecX_dZ2;
                     
    double dVecY_dX2;
    double dVecY_dY2;
    double dVecY_dZ2;
                       
    double dVecZ_dX2;
    double dVecZ_dY2;
    double dVecZ_dZ2; 
       
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
          
          Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
          
          Psi = VSPGeom().VortexSheet(k).WakeLoopList(i).Psi();
          
          if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() == 1 ) {

             pResidual_pRatio = VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1);
             
             pResidual_pCircumference = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio();
      
             pCircumference_pLength = 1.;
             
             VortexStretchingRatioEquationNumber = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();

             for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; j++ ) {
                
                Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(j);
                
                if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).IsTrailingEdge() ) {
 
                   Node1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node1() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
                                                                       
                   Node2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node2() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();

                   VSPGeom().Grid(MGLevel_).EdgeList(Edge).SetupGradients(dLength_dX1, 
                                                                          dLength_dY1,
                                                                          dLength_dZ1,
                                                                          
                                                                          dLength_dX2,
                                                                          dLength_dY2,
                                                                          dLength_dZ2,
                                                                          
                                                                          dVecX_dX1,
                                                                          dVecX_dY1,
                                                                          dVecX_dZ1,
                                                                                          
                                                                          dVecY_dX1,
                                                                          dVecY_dY1,
                                                                          dVecY_dZ1,
                                                                                         
                                                                          dVecZ_dX1,
                                                                          dVecZ_dY1,
                                                                          dVecZ_dZ1,
                                                                                         
                                                                          dVecX_dX2,
                                                                          dVecX_dY2,
                                                                          dVecX_dZ2,
                                                                                         
                                                                          dVecY_dX2,
                                                                          dVecY_dY2,
                                                                          dVecY_dZ2,
                                                                                         
                                                                          dVecZ_dX2,
                                                                          dVecZ_dY2,
                                                                          dVecZ_dZ2);   
                                                                          
                                                                        
                   PsiT_pR_pMesh_[3*Node1 - 2] += pResidual_pCircumference * pCircumference_pLength * dLength_dX1 * Psi;
                   PsiT_pR_pMesh_[3*Node1 - 1] += pResidual_pCircumference * pCircumference_pLength * dLength_dY1 * Psi;
                   PsiT_pR_pMesh_[3*Node1    ] += pResidual_pCircumference * pCircumference_pLength * dLength_dZ1 * Psi;
                                                                  
                   PsiT_pR_pMesh_[3*Node2 - 2] += pResidual_pCircumference * pCircumference_pLength * dLength_dX2 * Psi;
                   PsiT_pR_pMesh_[3*Node2 - 1] += pResidual_pCircumference * pCircumference_pLength * dLength_dX2 * Psi;
                   PsiT_pR_pMesh_[3*Node2    ] += pResidual_pCircumference * pCircumference_pLength * dLength_dX2 * Psi;
                   
                }
                                                                                     
                                                                        
              //  vec_out[VortexStretchingRatioEquationNumber] += pResidual_pCircumference * pCircumference_pLength * dLength_dX1 * vec_in[Eqn1X  ]
              //                                                + pResidual_pCircumference * pCircumference_pLength * dLength_dY1 * vec_in[Eqn1X+1]   
              //                                                + pResidual_pCircumference * pCircumference_pLength * dLength_dZ1 * vec_in[Eqn1X+2]  
              //                                                
              //                                                + pResidual_pCircumference * pCircumference_pLength * dLength_dX2 * vec_in[Eqn2X  ]
              //                                                + pResidual_pCircumference * pCircumference_pLength * dLength_dY2 * vec_in[Eqn2X+1]   
              //                                                + pResidual_pCircumference * pCircumference_pLength * dLength_dZ2 * vec_in[Eqn2X+2];
              //                                                
             }                                                                      
             
          }

       }
       
    }        
   
}

/*##############################################################################
#                                                                              #
#            VSP_SOLVER CalculateLoopNormalGradients_wrt_Mesh                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateLoopNormalGradients_wrt_Mesh(int Level, int Loop, double *NormalGradients, double *AreaGradients)
{
   
    int i, j, Tri, Node1, Node2, Node3, Found;
    
    if ( Level != MGLevel_ ) {
       
       printf("Loop normal gradients for meshes other than MGLevel_ not working yet! \n");
       fflush(NULL);
       
    }
    
    double Normal[3], Nmag;
    
    double dNx_dx1;
    double dNx_dy1;
    double dNx_dz1;
                         
    double dNy_dx1;
    double dNy_dy1;
    double dNy_dz1;
                         
    double dNz_dx1;
    double dNz_dy1;
    double dNz_dz1;
                       
    double dNx_dx2;
    double dNx_dy2;
    double dNx_dz2;
                         
    double dNy_dx2;
    double dNy_dy2;
    double dNy_dz2;
                          
    double dNz_dx2;
    double dNz_dy2;
    double dNz_dz2;    
                         
    double dNx_dx3;
    double dNx_dy3;
    double dNx_dz3;
                        
    double dNy_dx3;
    double dNy_dy3;
    double dNy_dz3;
                         
    double dNz_dx3;
    double dNz_dy3;
    double dNz_dz3;

    double dNx_Normalized_dx1;
    double dNx_Normalized_dy1;
    double dNx_Normalized_dz1; 
                                     
    double dNy_Normalized_dx1;
    double dNy_Normalized_dy1;
    double dNy_Normalized_dz1; 
                                     
    double dNz_Normalized_dx1;
    double dNz_Normalized_dy1;
    double dNz_Normalized_dz1;
                                     
    double dNx_Normalized_dx2;
    double dNx_Normalized_dy2;
    double dNx_Normalized_dz2; 
                                     
    double dNy_Normalized_dx2;
    double dNy_Normalized_dy2;
    double dNy_Normalized_dz2; 
                                     
    double dNz_Normalized_dx2;
    double dNz_Normalized_dy2;
    double dNz_Normalized_dz2;     
                                     
    double dNx_Normalized_dx3;
    double dNx_Normalized_dy3;
    double dNx_Normalized_dz3; 
                                     
    double dNy_Normalized_dx3;
    double dNy_Normalized_dy3;
    double dNy_Normalized_dz3; 
                                     
    double dNz_Normalized_dx3;
    double dNz_Normalized_dy3;
    double dNz_Normalized_dz3;
                                                
    double dArea_dx1;
    double dArea_dy1;
    double dArea_dz1;            
                           
    double dArea_dx2;
    double dArea_dy2;
    double dArea_dz2;       
                           
    double dArea_dx3;
    double dArea_dy3;
    double dArea_dz3;
                                                          
    // Loop over fine grid tris

    zero_double_array(NormalGradients, 9*VSPGeom().Grid(Level).LoopList(Loop).NumberOfNodes());

    zero_double_array(AreaGradients, 3*VSPGeom().Grid(Level).LoopList(Loop).NumberOfNodes());

    Nmag = 2.*VSPGeom().Grid(Level).LoopList(Loop).Area();
    
    Normal[0] = Nmag * VSPGeom().Grid(Level).LoopList(Loop).Nx();
    Normal[1] = Nmag * VSPGeom().Grid(Level).LoopList(Loop).Ny();
    Normal[2] = Nmag * VSPGeom().Grid(Level).LoopList(Loop).Nz();
           
    for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; i++ ) {
       
       Tri = VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(i);

       Node1 = VSPGeom().Grid(0).LoopList(Tri).Node1();
       Node2 = VSPGeom().Grid(0).LoopList(Tri).Node2();
       Node3 = VSPGeom().Grid(0).LoopList(Tri).Node3();
       
       CalculateTriNormalGradients_wrt_Mesh(Tri,
                                            dNx_dx1,
                                            dNx_dy1,
                                            dNx_dz1, 
                                             
                                            dNy_dx1,
                                            dNy_dy1,
                                            dNy_dz1, 
                                            
                                            dNz_dx1,
                                            dNz_dy1,
                                            dNz_dz1,
                                             
                                            dNx_dx2,
                                            dNx_dy2,
                                            dNx_dz2, 
                                               
                                            dNy_dx2,
                                            dNy_dy2,
                                            dNy_dz2, 
                                              
                                            dNz_dx2,
                                            dNz_dy2,
                                            dNz_dz2,     
                                                
                                            dNx_dx3,
                                            dNx_dy3,
                                            dNx_dz3, 
                                             
                                            dNy_dx3,
                                            dNy_dy3,
                                            dNy_dz3, 
                                            
                                            dNz_dx3,
                                            dNz_dy3,
                                            dNz_dz3,
                                            
                                            dNx_Normalized_dx1,
                                            dNx_Normalized_dy1,
                                            dNx_Normalized_dz1, 
                                               
                                            dNy_Normalized_dx1,
                                            dNy_Normalized_dy1,
                                            dNy_Normalized_dz1, 
                                               
                                            dNz_Normalized_dx1,
                                            dNz_Normalized_dy1,
                                            dNz_Normalized_dz1,
                                               
                                            dNx_Normalized_dx2,
                                            dNx_Normalized_dy2,
                                            dNx_Normalized_dz2, 
                                               
                                            dNy_Normalized_dx2,
                                            dNy_Normalized_dy2,
                                            dNy_Normalized_dz2, 
                                               
                                            dNz_Normalized_dx2,
                                            dNz_Normalized_dy2,
                                            dNz_Normalized_dz2,     
                                                
                                            dNx_Normalized_dx3,
                                            dNx_Normalized_dy3,
                                            dNx_Normalized_dz3, 
                                               
                                            dNy_Normalized_dx3,
                                            dNy_Normalized_dy3,
                                            dNy_Normalized_dz3, 
                                               
                                            dNz_Normalized_dx3,
                                            dNz_Normalized_dy3,
                                            dNz_Normalized_dz3,
                                                                                                  
                                            dArea_dx1,
                                            dArea_dy1,
                                            dArea_dz1,            
                                                    
                                            dArea_dx2,
                                            dArea_dy2,
                                            dArea_dz2,       
                                                    
                                            dArea_dx3,
                                            dArea_dy3,
                                            dArea_dz3);                                         
                        
       Found = 0;
       
       j = 1;
                                            
       while ( Found < 3 && j <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfNodes() ) {
                                          
           if ( VSPGeom().Grid(Level).LoopList(Loop).Node(j) == Node1 ) {
              
              NormalGradients[9*j - 8] += dNx_dx1/Nmag - Normal[0]*(Normal[0]*dNx_dx1 + Normal[1]*dNy_dx1 + Normal[2]*dNz_dx1)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 7] += dNx_dy1/Nmag - Normal[0]*(Normal[0]*dNx_dy1 + Normal[1]*dNy_dy1 + Normal[2]*dNz_dy1)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 6] += dNx_dz1/Nmag - Normal[0]*(Normal[0]*dNx_dz1 + Normal[1]*dNy_dz1 + Normal[2]*dNz_dz1)/(Nmag*Nmag*Nmag);
                                                                                                                
              NormalGradients[9*j - 5] += dNy_dx1/Nmag - Normal[1]*(Normal[0]*dNx_dx1 + Normal[1]*dNy_dx1 + Normal[2]*dNz_dx1)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 4] += dNy_dy1/Nmag - Normal[1]*(Normal[0]*dNx_dy1 + Normal[1]*dNy_dy1 + Normal[2]*dNz_dy1)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 3] += dNy_dz1/Nmag - Normal[1]*(Normal[0]*dNx_dz1 + Normal[1]*dNy_dz1 + Normal[2]*dNz_dz1)/(Nmag*Nmag*Nmag);
                                                                                                                  
              NormalGradients[9*j - 2] += dNz_dx1/Nmag - Normal[2]*(Normal[0]*dNx_dx1 + Normal[1]*dNy_dx1 + Normal[2]*dNz_dx1)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 1] += dNz_dy1/Nmag - Normal[2]*(Normal[0]*dNx_dy1 + Normal[1]*dNy_dy1 + Normal[2]*dNz_dy1)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 0] += dNz_dz1/Nmag - Normal[2]*(Normal[0]*dNx_dz1 + Normal[1]*dNy_dz1 + Normal[2]*dNz_dz1)/(Nmag*Nmag*Nmag);
              
              AreaGradients[3*j - 2] += dArea_dx1;
              AreaGradients[3*j - 1] += dArea_dy1;
              AreaGradients[3*j - 0] += dArea_dz1;

             // NormalGradients[9*j - 5] += dNx_dx1/Nmag; 
             // NormalGradients[9*j - 4] += dNx_dy1/Nmag; 
             // NormalGradients[9*j - 3] += dNx_dz1/Nmag;  
             //                                                                                                   
             // NormalGradients[9*j - 5] += dNy_dx1/Nmag; 
             // NormalGradients[9*j - 4] += dNy_dy1/Nmag; 
             // NormalGradients[9*j - 3] += dNy_dz1/Nmag;  
             //                                        
             // NormalGradients[9*j - 2] += dNz_dx1/Nmag; 
             // NormalGradients[9*j - 1] += dNz_dy1/Nmag; 
             // NormalGradients[9*j    ] += dNz_dz1/Nmag; 
              
              Found++;
              
           }
           
           if ( VSPGeom().Grid(Level).LoopList(Loop).Node(j) == Node2 ) {

              NormalGradients[9*j - 8] += dNx_dx2/Nmag - Normal[0]*(Normal[0]*dNx_dx2 + Normal[1]*dNy_dx2 + Normal[2]*dNz_dx2)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 7] += dNx_dy2/Nmag - Normal[0]*(Normal[0]*dNx_dy2 + Normal[1]*dNy_dy2 + Normal[2]*dNz_dy2)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 6] += dNx_dz2/Nmag - Normal[0]*(Normal[0]*dNx_dz2 + Normal[1]*dNy_dz2 + Normal[2]*dNz_dz2)/(Nmag*Nmag*Nmag);
                                                                                                                  
              NormalGradients[9*j - 5] += dNy_dx2/Nmag - Normal[1]*(Normal[0]*dNx_dx2 + Normal[1]*dNy_dx2 + Normal[2]*dNz_dx2)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 4] += dNy_dy2/Nmag - Normal[1]*(Normal[0]*dNx_dy2 + Normal[1]*dNy_dy2 + Normal[2]*dNz_dy2)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 3] += dNy_dz2/Nmag - Normal[1]*(Normal[0]*dNx_dz2 + Normal[1]*dNy_dz2 + Normal[2]*dNz_dz2)/(Nmag*Nmag*Nmag);
                                                                                                                 
              NormalGradients[9*j - 2] += dNz_dx2/Nmag - Normal[2]*(Normal[0]*dNx_dx2 + Normal[1]*dNy_dx2 + Normal[2]*dNz_dx2)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 1] += dNz_dy2/Nmag - Normal[2]*(Normal[0]*dNx_dy2 + Normal[1]*dNy_dy2 + Normal[2]*dNz_dy2)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 0] += dNz_dz2/Nmag - Normal[2]*(Normal[0]*dNx_dz2 + Normal[1]*dNy_dz2 + Normal[2]*dNz_dz2)/(Nmag*Nmag*Nmag);
                               
              AreaGradients[3*j - 2] += dArea_dx2;
              AreaGradients[3*j - 1] += dArea_dy2;
              AreaGradients[3*j - 0] += dArea_dz2;
                                                                 
            //  NormalGradients[9*j - 8] += dNx_dx2/Nmag;
            //  NormalGradients[9*j - 7] += dNx_dy2/Nmag;
            //  NormalGradients[9*j - 6] += dNx_dz2/Nmag; 
            //                                          
            //  NormalGradients[9*j - 5] += dNy_dx2/Nmag;
            //  NormalGradients[9*j - 4] += dNy_dy2/Nmag;
            //  NormalGradients[9*j - 3] += dNy_dz2/Nmag; 
            //                                          
            //  NormalGradients[9*j - 2] += dNz_dx2/Nmag;
            //  NormalGradients[9*j - 1] += dNz_dy2/Nmag;
            //  NormalGradients[9*j    ] += dNz_dz2/Nmag;
                            
              Found++;
              
           }

           if ( VSPGeom().Grid(Level).LoopList(Loop).Node(j) == Node3 ) {
                                        
              NormalGradients[9*j - 8] += dNx_dx3/Nmag - Normal[0]*(Normal[0]*dNx_dx3 + Normal[1]*dNy_dx3 + Normal[2]*dNz_dx3)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 7] += dNx_dy3/Nmag - Normal[0]*(Normal[0]*dNx_dy3 + Normal[1]*dNy_dy3 + Normal[2]*dNz_dy3)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 6] += dNx_dz3/Nmag - Normal[0]*(Normal[0]*dNx_dz3 + Normal[1]*dNy_dz3 + Normal[2]*dNz_dz3)/(Nmag*Nmag*Nmag);
                                                                                                            
              NormalGradients[9*j - 5] += dNy_dx3/Nmag - Normal[1]*(Normal[0]*dNx_dx3 + Normal[1]*dNy_dx3 + Normal[2]*dNz_dx3)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 4] += dNy_dy3/Nmag - Normal[1]*(Normal[0]*dNx_dy3 + Normal[1]*dNy_dy3 + Normal[2]*dNz_dy3)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 3] += dNy_dz3/Nmag - Normal[1]*(Normal[0]*dNx_dz3 + Normal[1]*dNy_dz3 + Normal[2]*dNz_dz3)/(Nmag*Nmag*Nmag);
                                                                                                              
              NormalGradients[9*j - 2] += dNz_dx3/Nmag - Normal[2]*(Normal[0]*dNx_dx3 + Normal[1]*dNy_dx3 + Normal[2]*dNz_dx3)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 1] += dNz_dy3/Nmag - Normal[2]*(Normal[0]*dNx_dy3 + Normal[1]*dNy_dy3 + Normal[2]*dNz_dy3)/(Nmag*Nmag*Nmag);
              NormalGradients[9*j - 0] += dNz_dz3/Nmag - Normal[2]*(Normal[0]*dNx_dz3 + Normal[1]*dNy_dz3 + Normal[2]*dNz_dz3)/(Nmag*Nmag*Nmag);

              AreaGradients[3*j - 2] += dArea_dx3;
              AreaGradients[3*j - 1] += dArea_dy3;
              AreaGradients[3*j - 0] += dArea_dz3;
              
          //    NormalGradients[9*j - 8] += dNx_dx3/Nmag;
          //    NormalGradients[9*j - 7] += dNx_dy3/Nmag;
          //    NormalGradients[9*j - 6] += dNx_dz3/Nmag; 
          //                                    
          //    NormalGradients[9*j - 5] += dNy_dx3/Nmag;
          //    NormalGradients[9*j - 4] += dNy_dy3/Nmag;
          //    NormalGradients[9*j - 3] += dNy_dz3/Nmag; 
          //                                    
          //    NormalGradients[9*j - 2] += dNz_dx3/Nmag;
          //    NormalGradients[9*j - 1] += dNz_dy3/Nmag;
          //    NormalGradients[9*j    ] += dNz_dz3/Nmag;
                            
              Found++;
                                                 
           }
           
           j++;
           
       }
       
       if ( Found != 3 ) {
          
          printf("Error in distributing the normal gradients! \n");
          fflush(NULL);
          exit(1);
          
       }
       
    }

}

/*##############################################################################
#                                                                              #
#       VSP_SOLVER CalculatePsiT_PartialResidualPartialUserInputs              #
#                                                                              #
#  [ R_gamma ]                                                                 # 
#  [         ]                                                                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculatePsiT_PartialResidualPartialUserInputs(int ForceCase, int Dir, double InviscidWeight, double ViscousWeight, double WakeWeight)
{    
    
    double Fx, Fy, Fz;
    
    // Gradients wrt free stream 
    
    CalculatePsiT_PartialResidualPartialFreeStream(ForceCase, Dir, InviscidWeight, ViscousWeight, WakeWeight);
    
    // Forces and moments wrt cg location

    Fx = ( InviscidWeight*CFix() + ViscousWeight*CFox() ) * 0.5*Sref_*Vref_*Vref_;
    Fy = ( InviscidWeight*CFiy() + ViscousWeight*CFoy() ) * 0.5*Sref_*Vref_*Vref_; 
    Fz = ( InviscidWeight*CFiz() + ViscousWeight*CFoz() ) * 0.5*Sref_*Vref_*Vref_;

    if ( ForceCase == 1 || ForceCase == 3 ) {
    
       // Force derivatives are identically zero
       
       DFi_DCG_[0][0] = 0.;
       DFi_DCG_[1][0] = 0.;
       DFi_DCG_[2][0] = 0.;
       
       DFi_DCG_[0][1] = 0.;
       DFi_DCG_[1][1] = 0.;
       DFi_DCG_[2][1] = 0.;
       
       DFi_DCG_[0][2] = 0.;
       DFi_DCG_[1][2] = 0.;
       DFi_DCG_[2][2] = 0.;
             
       // Moment derivatives wrt x cg movements
       
       DMi_DCG_[0][0] =  Fz;
       DMi_DCG_[1][0] = -Fz;
       DMi_DCG_[2][0] =  Fy;
       
       // Moment derivatives wrt y cg movements
       
       DMi_DCG_[0][1] =  Fz;
       DMi_DCG_[1][1] =  0.;
       DMi_DCG_[2][1] = -Fx;
       
       // Moment derivatives wrt z cg movements
       
       DMi_DCG_[0][2] = -Fy;
       DMi_DCG_[1][2] =  Fx;
       DMi_DCG_[2][2] =  0.; 
       
       // Wake force derivatives are identically zero
       
       DFw_DCG_[0][0] = 0.;
       DFw_DCG_[1][0] = 0.;
       DFw_DCG_[2][0] = 0.;
        
       DFw_DCG_[0][1] = 0.;
       DFw_DCG_[1][1] = 0.;
       DFw_DCG_[2][1] = 0.;
        
       DFw_DCG_[0][2] = 0.;
       DFw_DCG_[1][2] = 0.;
       DFw_DCG_[2][2] = 0.;
       
    }
    
    else if ( ForceCase == 2 ) {
       
       // Force derivatives are identically zero
       
       DFo_DCG_[0][0] = 0.;
       DFo_DCG_[1][0] = 0.;
       DFo_DCG_[2][0] = 0.;
         
       DFo_DCG_[0][1] = 0.;
       DFo_DCG_[1][1] = 0.;
       DFo_DCG_[2][1] = 0.;
        
       DFo_DCG_[0][2] = 0.;
       DFo_DCG_[1][2] = 0.;
       DFo_DCG_[2][2] = 0.;
             
       // Moment derivatives wrt x cg movements
       
       DMo_DCG_[0][0] =  Fz;
       DMo_DCG_[1][0] = -Fz;
       DMo_DCG_[2][0] =  Fy;
       
       // Moment derivatives wrt y cg movements
       
       DMo_DCG_[0][1] =  Fz;
       DMo_DCG_[1][1] =  0.;
       DMo_DCG_[2][1] = -Fx;
       
       // Moment derivatives wrt z cg movements
       
       DMo_DCG_[0][2] = -Fy;
       DMo_DCG_[1][2] =  Fx;
       DMo_DCG_[2][2] =  0.; 
              
    }
    
}
    
/*##############################################################################
#                                                                              #
#       VSP_SOLVER CalculatePsiT_PartialResidualPartialFreeStream              #
#                                                                              #
#  [ R_gamma ]                                                                 # 
#  [         ]                                                                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculatePsiT_PartialResidualPartialFreeStream(int ForceCase, int Dir, double InviscidWeight, double ViscousWeight, double WakeWeight)
{

    int i, j, k, p, Edge;
    double GammaSum, pR_pVinf[3], pR_pBodyVelocity[3], xyz[3];
    double pVinf_pAlpha[3], pVinf_pBeta[3], pVinf_pP[3], pVinf_pQ[3], pVinf_pR[3];
    double CA, CB, SA, SB;
    
    double DF_DAlpha, DF_DBeta, DF_DP, DF_DQ, DF_DR, DF_DMach, *DF_DOmega, Psi;
    
    double pResidual_pVinf[3][3], pResidual_pMach[3];
    double pForces_pVinf[3][3], pForces_pMach[3], pWakeForces_pVinf[3][3], pWakeForces_pMach[3], StallFactor;
    double MomArm[3], pMoments_pVinf[3][3], pMoments_pMach[3];
    double pForces_pBodyVelocity[2][3][3], pMoments_pBodyVelocity[2][3][3];
    
    int g, *ComponentInThisGroup;
    double OVec[3], TVec[3];
    double Omega, Angle, pVinf_pBodyVelocity[3];  
    double pVelocity_pBodyVelocity[2][3];  
    QUAT Quat, InvQuat, Vec1, Vec2, DQuatDt, BodyVelocity, WQuat;
    QUAT OmegaVec, RotationalVelocity;
    QUAT pOmegaVec_pOmega, pBodyVelocity_pOmega, pWQuat_pOmega;

    int LE_Edge, TE_Edge;
    double Chord, Span, VLE, VTE, Velocity, RVec[3], SVec[3], Mag, StallBumpFactor, Gamma, Cl, Re;
    double Cf, Cfi, pCf_pCl2, pCfi_pRe, pCf_pRe, pCfi_pCl, pCf_pCl;
    double pRe_pVelocity, pCl_pVelocity;
    double Fxo, Fyo, Fzo, Mxo, Myo, Mzo;
    double pFxo_pVelocity, pFyo_pVelocity, pFzo_pVelocity;
    double pMxo_pVelocity, pMyo_pVelocity, pMzo_pVelocity;
    double pVelocity_pVinf[3];
    double pFxo_pRe, pFyo_pRe, pFzo_pRe;

    int Sign;
    double GammaTE, Cl_Ratio;
    double Fstall, pFstall_pX, dABS_Cl_Ratio_dCl_Ratio, pR_Velocity, dCl_Ratio_dVelocity;
        
    ComponentInThisGroup = new int[VSPGeom().NumberOfComponents() + 1];
       
    // Initialize loops with Psi solution

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).LoopList(i).Psi() = 0.;
       
    }
        
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).LoopList(i).Psi() = CurrentPsi_[i];
       
    }

    // Initialize nodes with Psi solution

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(0) = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(1) = 0.;
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(2) = 0.;
       
    }   
     
    for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() + 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       j = i - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();

       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(0) = CurrentPsi_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j - 2];
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(1) = CurrentPsi_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j - 1];
       VSPGeom().Grid(MGLevel_).NodeList(i).Psi(2) = CurrentPsi_[VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j    ];
       
    }   

    CA = cos(AngleOfAttack_);
    SA = sin(AngleOfAttack_);

    CB = cos(AngleOfBeta_);
    SB = sin(AngleOfBeta_);

    //FreeStreamVelocity_[0] = CA*CB * Vinf_;
    //FreeStreamVelocity_[1] =   -SB * Vinf_;
    //FreeStreamVelocity_[2] = SA*CB * Vinf_;

    pVinf_pAlpha[0] = -SA*CB * Vinf_;
    pVinf_pAlpha[1] = 0.;
    pVinf_pAlpha[2] =  CA*CB * Vinf_;
    
    pVinf_pBeta[0]  = -CA*SB * Vinf_;
    pVinf_pBeta[1]  =    -CB * Vinf_;
    pVinf_pBeta[2]  = -SA*SB * Vinf_;    
    
    DF_DAlpha = 0.;
    DF_DBeta  = 0.;
    DF_DP     = 0.;
    DF_DQ     = 0.;
    DF_DR     = 0.;
    DF_DMach  = 0.;

    DF_DOmega = new double[VSPGeom().NumberOfComponentGroups() + 1];

    zero_double_array(DF_DOmega, VSPGeom().NumberOfComponentGroups());

    DFi_DRe_[0] = DMi_DRe_[0] = 0.;
    DFi_DRe_[1] = DMi_DRe_[1] = 0.;
    DFi_DRe_[2] = DMi_DRe_[2] = 0.;

    DFo_DRe_[0] = DMo_DRe_[0] = 0.;
    DFo_DRe_[1] = DMo_DRe_[1] = 0.;
    DFo_DRe_[2] = DMo_DRe_[2] = 0.;

    DFw_DRe_[0] = 0.;
    DFw_DRe_[1] = 0.;
    DFw_DRe_[2] = 0.;
                  
    // Invisicid forces and moments... solution independent terms
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; i++ ) {

       StallFactor = 1.;
       
       if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsTrailingEdge() ) StallFactor = VSPGeom().Grid(MGLevel_).EdgeList(i).TrailingEdgeStallFactor();
  
       // Forces
       
       if ( Dir <=  3 ) {
          
          // Forces
          
          VSPGeom().Grid(MGLevel_).EdgeList(i).pForces_pVinf(pForces_pVinf);
          
          VSPGeom().Grid(MGLevel_).EdgeList(i).pForces_pMach(pForces_pMach);

          pForces_pVinf[0][0] *= StallFactor;
          pForces_pVinf[0][1] *= StallFactor;
          pForces_pVinf[0][2] *= StallFactor;
                                 
          pForces_pVinf[1][0] *= StallFactor;
          pForces_pVinf[1][1] *= StallFactor;
          pForces_pVinf[1][2] *= StallFactor;
                                 
          pForces_pVinf[2][0] *= StallFactor;
          pForces_pVinf[2][1] *= StallFactor;
          pForces_pVinf[2][2] *= StallFactor;
                                 
          pForces_pMach[0]    *= StallFactor;
          pForces_pMach[1]    *= StallFactor;
          pForces_pMach[2]    *= StallFactor;

          pForces_pVinf[0][0] *= InviscidWeight;
          pForces_pVinf[0][1] *= InviscidWeight;
          pForces_pVinf[0][2] *= InviscidWeight;

          pForces_pVinf[1][0] *= InviscidWeight;
          pForces_pVinf[1][1] *= InviscidWeight;
          pForces_pVinf[1][2] *= InviscidWeight;
                                 
          pForces_pVinf[2][0] *= InviscidWeight;
          pForces_pVinf[2][1] *= InviscidWeight;
          pForces_pVinf[2][2] *= InviscidWeight;

          pForces_pMach[0]    *= InviscidWeight;
          pForces_pMach[1]    *= InviscidWeight;
          pForces_pMach[2]    *= InviscidWeight;
          
          // Trefftz forces
        
          pWakeForces_pVinf[0][0] = 0.;
          pWakeForces_pVinf[0][1] = 0.;
          pWakeForces_pVinf[0][2] = 0.;
                               
          pWakeForces_pVinf[1][0] = 0.;
          pWakeForces_pVinf[1][1] = 0.;
          pWakeForces_pVinf[1][2] = 0.;
                                
          pWakeForces_pVinf[2][0] = 0.;
          pWakeForces_pVinf[2][1] = 0.;
          pWakeForces_pVinf[2][2] = 0.;
                                
          pWakeForces_pMach[0]    = 0.;
          pWakeForces_pMach[1]    = 0.;
          pWakeForces_pMach[2]    = 0.;
                       
          if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsTrailingEdge() ) {

             VSPGeom().Grid(MGLevel_).EdgeList(i).pTrefftzForces_pVinf(pWakeForces_pVinf);
             
             VSPGeom().Grid(MGLevel_).EdgeList(i).pTrefftzForces_pMach(pWakeForces_pMach);
             
          }

          pForces_pVinf[0][0] += pWakeForces_pVinf[0][0] * WakeWeight;
          pForces_pVinf[0][1] += pWakeForces_pVinf[0][1] * WakeWeight;
          pForces_pVinf[0][2] += pWakeForces_pVinf[0][2] * WakeWeight;
                                                       
          pForces_pVinf[1][0] += pWakeForces_pVinf[1][0] * WakeWeight;
          pForces_pVinf[1][1] += pWakeForces_pVinf[1][1] * WakeWeight;
          pForces_pVinf[1][2] += pWakeForces_pVinf[1][2] * WakeWeight;
                                                       
          pForces_pVinf[2][0] += pWakeForces_pVinf[2][0] * WakeWeight;
          pForces_pVinf[2][1] += pWakeForces_pVinf[2][1] * WakeWeight;
          pForces_pVinf[2][2] += pWakeForces_pVinf[2][2] * WakeWeight;

          pForces_pMach[0]    += pWakeForces_pMach[0] * WakeWeight; 
          pForces_pMach[1]    += pWakeForces_pMach[1] * WakeWeight;
          pForces_pMach[2]    += pWakeForces_pMach[2] * WakeWeight; 
          
          // Alpha
          
          DF_DAlpha += pForces_pVinf[Dir-1][0]*pVinf_pAlpha[0] + pForces_pVinf[Dir-1][1]*pVinf_pAlpha[1] + pForces_pVinf[Dir-1][2]*pVinf_pAlpha[2];
          
          // Beta
          
          DF_DBeta += pForces_pVinf[Dir-1][0]*pVinf_pBeta[0] + pForces_pVinf[Dir-1][1]*pVinf_pBeta[1] + pForces_pVinf[Dir-1][2]*pVinf_pBeta[2];

          // Mach
          
          DF_DMach += pForces_pMach[Dir-1];
          
          // PQR
          
          xyz[0] = VSPGeom().Grid(MGLevel_).EdgeList(i).Xc() - Xcg();            
          xyz[1] = VSPGeom().Grid(MGLevel_).EdgeList(i).Yc() - Ycg();           
          xyz[2] = VSPGeom().Grid(MGLevel_).EdgeList(i).Zc() - Zcg();    
          
          // P - Roll
          
          pVinf_pP[0] = 0.;
          pVinf_pP[1] = -xyz[2];
          pVinf_pP[2] = +xyz[1];      
          
          DF_DP += pForces_pVinf[Dir-1][0]*pVinf_pP[0] + pForces_pVinf[Dir-1][1]*pVinf_pP[1] + pForces_pVinf[Dir-1][2]*pVinf_pP[2];
          
          // Q - Pitch
          
          pVinf_pQ[0] = -xyz[2];
          pVinf_pQ[1] = 0.;
          pVinf_pQ[2] = +xyz[0];    
          
          DF_DQ += pForces_pVinf[Dir-1][0]*pVinf_pQ[0] + pForces_pVinf[Dir-1][1]*pVinf_pQ[1] + pForces_pVinf[Dir-1][2]*pVinf_pQ[2];
          
          // R - Yaw
          
          pVinf_pR[0] = -xyz[1];
          pVinf_pR[1] = +xyz[0];
          pVinf_pR[2] = 0.;    
    
          DF_DR += pForces_pVinf[Dir-1][0]*pVinf_pR[0] + pForces_pVinf[Dir-1][1]*pVinf_pR[1] + pForces_pVinf[Dir-1][2]*pVinf_pR[2];
          
          // Reynold's number
          
          DFi_DRe_[0] = 0.;
          DFi_DRe_[1] = 0.;
          DFi_DRe_[2] = 0.;

       }
       
       // Moments
       
       else if ( Dir > 3 ) {
          
          xyz[0] = VSPGeom().Grid(MGLevel_).EdgeList(i).Xc() - Xcg();            
          xyz[1] = VSPGeom().Grid(MGLevel_).EdgeList(i).Yc() - Ycg();           
          xyz[2] = VSPGeom().Grid(MGLevel_).EdgeList(i).Zc() - Zcg();    
                     
          VSPGeom().Grid(MGLevel_).EdgeList(i).pMoments_pVinf(xyz,pMoments_pVinf);

          VSPGeom().Grid(MGLevel_).EdgeList(i).pMoments_pMach(xyz,pMoments_pMach);

          pMoments_pVinf[0][0] *= StallFactor;
          pMoments_pVinf[0][1] *= StallFactor;
          pMoments_pVinf[0][2] *= StallFactor;
                                  
          pMoments_pVinf[1][0] *= StallFactor;
          pMoments_pVinf[1][1] *= StallFactor;
          pMoments_pVinf[1][2] *= StallFactor;
                                  
          pMoments_pVinf[2][0] *= StallFactor;
          pMoments_pVinf[2][1] *= StallFactor;
          pMoments_pVinf[2][2] *= StallFactor;
                                  
          pMoments_pMach[0]    *= StallFactor;
          pMoments_pMach[1]    *= StallFactor;
          pMoments_pMach[2]    *= StallFactor;

          pMoments_pVinf[0][0] *= InviscidWeight;
          pMoments_pVinf[0][1] *= InviscidWeight;
          pMoments_pVinf[0][2] *= InviscidWeight;
                                  
          pMoments_pVinf[1][0] *= InviscidWeight;
          pMoments_pVinf[1][1] *= InviscidWeight;
          pMoments_pVinf[1][2] *= InviscidWeight;
                                  
          pMoments_pVinf[2][0] *= InviscidWeight;
          pMoments_pVinf[2][1] *= InviscidWeight;
          pMoments_pVinf[2][2] *= InviscidWeight;
                                  
          pMoments_pMach[0]    *= InviscidWeight;
          pMoments_pMach[1]    *= InviscidWeight;
          pMoments_pMach[2]    *= InviscidWeight;

          // Alpha
          
          DF_DAlpha += pMoments_pVinf[Dir-4][0]*pVinf_pAlpha[0] + pMoments_pVinf[Dir-4][1]*pVinf_pAlpha[1] + pMoments_pVinf[Dir-4][2]*pVinf_pAlpha[2];
          
          // Beta
          
          DF_DBeta += pMoments_pVinf[Dir-4][0]*pVinf_pBeta[0] + pMoments_pVinf[Dir-4][1]*pVinf_pBeta[1] + pMoments_pVinf[Dir-4][2]*pVinf_pBeta[2];
          
          // Mach
          
          DF_DMach += pMoments_pMach[Dir-4];
          
          // P - Roll
          
          pVinf_pP[0] = 0.;
          pVinf_pP[1] = -xyz[2];
          pVinf_pP[2] = +xyz[1];      
          
          DF_DP += pMoments_pVinf[Dir-4][0]*pVinf_pP[0] + pMoments_pVinf[Dir-4][1]*pVinf_pP[1] + pMoments_pVinf[Dir-4][2]*pVinf_pP[2];
          
          // Q - Pitch
          
          pVinf_pQ[0] = -xyz[2];
          pVinf_pQ[1] = 0.;
          pVinf_pQ[2] = +xyz[0];    
          
          DF_DQ += pMoments_pVinf[Dir-4][0]*pVinf_pQ[0] + pMoments_pVinf[Dir-4][1]*pVinf_pQ[1] + pMoments_pVinf[Dir-4][2]*pVinf_pQ[2];
          
          // R - Yaw
          
          pVinf_pR[0] = -xyz[1];
          pVinf_pR[1] = +xyz[0];
          pVinf_pR[2] = 0.;    
    
          DF_DR += pMoments_pVinf[Dir-4][0]*pVinf_pR[0] + pMoments_pVinf[Dir-4][1]*pVinf_pR[1] + pMoments_pVinf[Dir-4][2]*pVinf_pR[2];

          // Reynold's number
          
          DMi_DRe_[0] = 0.;
          DMi_DRe_[1] = 0.;
          DMi_DRe_[2] = 0.;
          
       }
       
       // For rotor cases we need to find inviscid partials wrt omega
       
       g = VSPGeom().Grid(MGLevel_).EdgeList(i).Group();
       
       if ( VSPGeom().ComponentGroupList(g).GeometryIsARotor() ) {

          OVec[0] = VSPGeom().ComponentGroupList(g).OVec(0); // Rotation origin
          OVec[1] = VSPGeom().ComponentGroupList(g).OVec(1);
          OVec[2] = VSPGeom().ComponentGroupList(g).OVec(2);
                                                
          RVec[0] = VSPGeom().ComponentGroupList(g).RVec(0); // Rotation vector
          RVec[1] = VSPGeom().ComponentGroupList(g).RVec(1);
          RVec[2] = VSPGeom().ComponentGroupList(g).RVec(2);
                                                
          TVec[0] = VSPGeom().ComponentGroupList(g).TVec(0); // Translation vector
          TVec[1] = VSPGeom().ComponentGroupList(g).TVec(1);
          TVec[2] = VSPGeom().ComponentGroupList(g).TVec(2);
          
          VSPGeom().ComponentGroupList(g).Update();
   
          Quat = VSPGeom().ComponentGroupList(g).Quat();
          
          InvQuat = VSPGeom().ComponentGroupList(g).InvQuat();
          
          WQuat = VSPGeom().ComponentGroupList(g).WQuat();
          
          pWQuat_pOmega = VSPGeom().ComponentGroupList(g).pWQuat_pOmega();

          // Calculate surface velocity for edge centroids
          
          Vec1(0) = VSPGeom().Grid(MGLevel_).EdgeList(i).Xc() - OVec[0];
          Vec1(1) = VSPGeom().Grid(MGLevel_).EdgeList(i).Yc() - OVec[1];
          Vec1(2) = VSPGeom().Grid(MGLevel_).EdgeList(i).Zc() - OVec[2];
      
          // Body point location after rotation
          
          Vec2 = Quat * Vec1 * InvQuat;
   
          // Body point velocity
          
          BodyVelocity = WQuat * Vec2;
          
          pBodyVelocity_pOmega = pWQuat_pOmega * Vec2;
          
          pVinf_pBodyVelocity[0] = -1.;
          pVinf_pBodyVelocity[1] = -1.;
          pVinf_pBodyVelocity[2] = -1.;
          
          // Calculate inviscid gradients wrt omega
       
          if ( Dir <=  3 ) {

             DF_DOmega[g] += pForces_pVinf[Dir-1][0] * pVinf_pBodyVelocity[0] * pBodyVelocity_pOmega(0)
                           + pForces_pVinf[Dir-1][1] * pVinf_pBodyVelocity[1] * pBodyVelocity_pOmega(1)
                           + pForces_pVinf[Dir-1][2] * pVinf_pBodyVelocity[2] * pBodyVelocity_pOmega(2);      

          }
          
          else {

             DF_DOmega[g] += pMoments_pVinf[Dir-4][0] * pVinf_pBodyVelocity[0] * pBodyVelocity_pOmega(0)
                           + pMoments_pVinf[Dir-4][1] * pVinf_pBodyVelocity[1] * pBodyVelocity_pOmega(1)
                           + pMoments_pVinf[Dir-4][2] * pVinf_pBodyVelocity[2] * pBodyVelocity_pOmega(2);      
                                           
          }       
              
       }
       
    }
 
    // Viscous forces and moments... solution independent terms 

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          LE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).LE_Edge());

          TE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
          
          Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
          
          Span = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Length() + VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Length() );

          VLE = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[0], 2.)
                    + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[1], 2.)
                    + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[2], 2.) );
                               
          VTE = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[0], 2.)
                    + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[1], 2.)
                    + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[2], 2.) );
                                                   
          Velocity = 0.5*( VLE + VTE );
                                   
          pVelocity_pVinf[0] = 0.5 * ( (FreeStreamVelocity_[0] - LocalBodySurfaceVelocityForEdge_[LE_Edge][0])/VLE + (FreeStreamVelocity_[0] - LocalBodySurfaceVelocityForEdge_[TE_Edge][0])/VTE );                                    
          pVelocity_pVinf[1] = 0.5 * ( (FreeStreamVelocity_[1] - LocalBodySurfaceVelocityForEdge_[LE_Edge][1])/VLE + (FreeStreamVelocity_[1] - LocalBodySurfaceVelocityForEdge_[TE_Edge][1])/VTE );           
          pVelocity_pVinf[2] = 0.5 * ( (FreeStreamVelocity_[2] - LocalBodySurfaceVelocityForEdge_[LE_Edge][2])/VLE + (FreeStreamVelocity_[2] - LocalBodySurfaceVelocityForEdge_[TE_Edge][2])/VTE );           

          pVelocity_pBodyVelocity[0][0] = -0.5*(FreeStreamVelocity_[0] - LocalBodySurfaceVelocityForEdge_[LE_Edge][0])/VLE;                                    
          pVelocity_pBodyVelocity[0][1] = -0.5*(FreeStreamVelocity_[1] - LocalBodySurfaceVelocityForEdge_[LE_Edge][1])/VLE;           
          pVelocity_pBodyVelocity[0][2] = -0.5*(FreeStreamVelocity_[2] - LocalBodySurfaceVelocityForEdge_[LE_Edge][2])/VLE;           
                                          
          pVelocity_pBodyVelocity[1][0] = -0.5*(FreeStreamVelocity_[0] - LocalBodySurfaceVelocityForEdge_[TE_Edge][0])/VTE;                                    
          pVelocity_pBodyVelocity[1][1] = -0.5*(FreeStreamVelocity_[1] - LocalBodySurfaceVelocityForEdge_[TE_Edge][1])/VTE;           
          pVelocity_pBodyVelocity[1][2] = -0.5*(FreeStreamVelocity_[2] - LocalBodySurfaceVelocityForEdge_[TE_Edge][2])/VTE;           
 
          SVec[0] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Xc();                               
          SVec[1] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Yc();                               
          SVec[2] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Zc(); 
          
          Mag = sqrt(vector_dot(SVec,SVec));
          
          SVec[0] /= Mag;                              
          SVec[1] /= Mag;                              
          SVec[2] /= Mag;                              

          StallFactor = 1. - VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor();
 
          Gamma = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Gamma();
          
          Cl = ABS(Gamma/(0.5*Velocity*Chord));
          
          pCl_pVelocity = -ABS(Gamma/(0.5*Velocity*Velocity*Chord));
          
        //  if ( Gamma/(0.5*Velocity*Velocity*Chord) < 0. ) pCl_pVelocity *= -1.;
          
          Re = MAX(2.,ReCref_ * Velocity * Chord / Cref_);
          
          pRe_pVelocity = 0.;
          
          if ( Re > 2. ) pRe_pVelocity = ReCref_ * Chord / Cref_;

          pCf_pCl2 = 0.00625 + 0.01*ABS(Clo_2d_);
        
          StallBumpFactor = 1. + 100.*StallFactor;
        
          Cfi = 2. * 1.5 * 1.037 / pow(log10(Re),2.58) + pCf_pCl2*pow(Cl-Clo_2d_, 2.);
          
          pCfi_pRe = -2.58 * 2. * 1.5 * 1.037 / ( Re * log(10.) * pow(log10(Re),3.58) );
          
          pCfi_pCl = 2.*pCf_pCl2*(Cl-Clo_2d_);
          
          Cf = Cfi * StallBumpFactor;
                     
          pCf_pCl = pCfi_pCl * StallBumpFactor;

          pCf_pRe = pCfi_pRe * StallBumpFactor;
              
          // Forces
           
          Fxo = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[0];
          Fyo = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[1];
          Fzo = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[2];
   
          pFxo_pVelocity = 0.5 * pCf_pRe * pRe_pVelocity * Velocity * Velocity * Chord * Span * SVec[0] + 0.5 * pCf_pCl * pCl_pVelocity * Velocity * Velocity * Chord * Span * SVec[0] + Cf * Velocity * Chord * Span * SVec[0];
          pFyo_pVelocity = 0.5 * pCf_pRe * pRe_pVelocity * Velocity * Velocity * Chord * Span * SVec[1] + 0.5 * pCf_pCl * pCl_pVelocity * Velocity * Velocity * Chord * Span * SVec[1] + Cf * Velocity * Chord * Span * SVec[1];
          pFzo_pVelocity = 0.5 * pCf_pRe * pRe_pVelocity * Velocity * Velocity * Chord * Span * SVec[2] + 0.5 * pCf_pCl * pCl_pVelocity * Velocity * Velocity * Chord * Span * SVec[2] + Cf * Velocity * Chord * Span * SVec[2];

          pFxo_pRe = 0.5 * pCf_pRe * Velocity * Velocity * Chord * Span * SVec[0];
          pFyo_pRe = 0.5 * pCf_pRe * Velocity * Velocity * Chord * Span * SVec[1];
          pFzo_pRe = 0.5 * pCf_pRe * Velocity * Velocity * Chord * Span * SVec[2]; 
             
          // Moments ... we assume forces act about centroid of airfoil section
          
          RVec[0] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Xc() );                               
          RVec[1] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Yc() );                               
          RVec[2] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Zc() );           

          Mxo = Fzo * ( RVec[1] - XYZcg_[1] ) - Fyo * ( RVec[2] - XYZcg_[2] );   // Roll
          Myo = Fxo * ( RVec[2] - XYZcg_[2] ) - Fzo * ( RVec[0] - XYZcg_[0] );   // Pitch
          Mzo = Fyo * ( RVec[0] - XYZcg_[0] ) - Fxo * ( RVec[1] - XYZcg_[1] );   // Yaw
 
          pMxo_pVelocity = pFzo_pVelocity * ( RVec[1] - XYZcg_[1] ) - pFyo_pVelocity * ( RVec[2] - XYZcg_[2] );   // Roll
          pMyo_pVelocity = pFxo_pVelocity * ( RVec[2] - XYZcg_[2] ) - pFzo_pVelocity * ( RVec[0] - XYZcg_[0] );   // Pitch
          pMzo_pVelocity = pFyo_pVelocity * ( RVec[0] - XYZcg_[0] ) - pFxo_pVelocity * ( RVec[1] - XYZcg_[1] );   // Yaw

          // Forces and moments wrt vinf
          
           pForces_pVinf[0][0] = pFxo_pVelocity * pVelocity_pVinf[0] * ViscousWeight;
           pForces_pVinf[0][1] = pFxo_pVelocity * pVelocity_pVinf[1] * ViscousWeight;
           pForces_pVinf[0][2] = pFxo_pVelocity * pVelocity_pVinf[2] * ViscousWeight;
                                                                    
           pForces_pVinf[1][0] = pFyo_pVelocity * pVelocity_pVinf[0] * ViscousWeight;
           pForces_pVinf[1][1] = pFyo_pVelocity * pVelocity_pVinf[1] * ViscousWeight;
           pForces_pVinf[1][2] = pFyo_pVelocity * pVelocity_pVinf[2] * ViscousWeight;
                                                                    
           pForces_pVinf[2][0] = pFzo_pVelocity * pVelocity_pVinf[0] * ViscousWeight;
           pForces_pVinf[2][1] = pFzo_pVelocity * pVelocity_pVinf[1] * ViscousWeight;
           pForces_pVinf[2][2] = pFzo_pVelocity * pVelocity_pVinf[2] * ViscousWeight;

          pMoments_pVinf[0][0] = pMxo_pVelocity * pVelocity_pVinf[0] * ViscousWeight;
          pMoments_pVinf[0][1] = pMxo_pVelocity * pVelocity_pVinf[1] * ViscousWeight;
          pMoments_pVinf[0][2] = pMxo_pVelocity * pVelocity_pVinf[2] * ViscousWeight;
                                                                 
          pMoments_pVinf[1][0] = pMyo_pVelocity * pVelocity_pVinf[0] * ViscousWeight;
          pMoments_pVinf[1][1] = pMyo_pVelocity * pVelocity_pVinf[1] * ViscousWeight;
          pMoments_pVinf[1][2] = pMyo_pVelocity * pVelocity_pVinf[2] * ViscousWeight;
                                                                 
          pMoments_pVinf[2][0] = pMzo_pVelocity * pVelocity_pVinf[0] * ViscousWeight;
          pMoments_pVinf[2][1] = pMzo_pVelocity * pVelocity_pVinf[1] * ViscousWeight;
          pMoments_pVinf[2][2] = pMzo_pVelocity * pVelocity_pVinf[2] * ViscousWeight;          

          // Forces and moments wrt body velocities for LE
          
           pForces_pBodyVelocity[0][0][0] = pFxo_pVelocity * pVelocity_pBodyVelocity[0][0] * ViscousWeight;
           pForces_pBodyVelocity[0][0][1] = pFxo_pVelocity * pVelocity_pBodyVelocity[0][1] * ViscousWeight;
           pForces_pBodyVelocity[0][0][2] = pFxo_pVelocity * pVelocity_pBodyVelocity[0][2] * ViscousWeight;
                                                                                   
           pForces_pBodyVelocity[0][1][0] = pFyo_pVelocity * pVelocity_pBodyVelocity[0][0] * ViscousWeight;
           pForces_pBodyVelocity[0][1][1] = pFyo_pVelocity * pVelocity_pBodyVelocity[0][1] * ViscousWeight;
           pForces_pBodyVelocity[0][1][2] = pFyo_pVelocity * pVelocity_pBodyVelocity[0][2] * ViscousWeight;
                                                                                  
           pForces_pBodyVelocity[0][2][0] = pFzo_pVelocity * pVelocity_pBodyVelocity[0][0] * ViscousWeight;
           pForces_pBodyVelocity[0][2][1] = pFzo_pVelocity * pVelocity_pBodyVelocity[0][1] * ViscousWeight;
           pForces_pBodyVelocity[0][2][2] = pFzo_pVelocity * pVelocity_pBodyVelocity[0][2] * ViscousWeight;

          pMoments_pBodyVelocity[0][0][0] = pMxo_pVelocity * pVelocity_pBodyVelocity[0][0] * ViscousWeight;
          pMoments_pBodyVelocity[0][0][1] = pMxo_pVelocity * pVelocity_pBodyVelocity[0][1] * ViscousWeight;
          pMoments_pBodyVelocity[0][0][2] = pMxo_pVelocity * pVelocity_pBodyVelocity[0][2] * ViscousWeight;
                                                                                   
          pMoments_pBodyVelocity[0][1][0] = pMyo_pVelocity * pVelocity_pBodyVelocity[0][0] * ViscousWeight;
          pMoments_pBodyVelocity[0][1][1] = pMyo_pVelocity * pVelocity_pBodyVelocity[0][1] * ViscousWeight;
          pMoments_pBodyVelocity[0][1][2] = pMyo_pVelocity * pVelocity_pBodyVelocity[0][2] * ViscousWeight;
                                                                                  
          pMoments_pBodyVelocity[0][2][0] = pMzo_pVelocity * pVelocity_pBodyVelocity[0][0] * ViscousWeight;
          pMoments_pBodyVelocity[0][2][1] = pMzo_pVelocity * pVelocity_pBodyVelocity[0][1] * ViscousWeight;
          pMoments_pBodyVelocity[0][2][2] = pMzo_pVelocity * pVelocity_pBodyVelocity[0][2] * ViscousWeight;         

          // Forces and moments wrt body velocities for TE
          
           pForces_pBodyVelocity[1][0][0] = pFxo_pVelocity * pVelocity_pBodyVelocity[1][0] * ViscousWeight;
           pForces_pBodyVelocity[1][0][1] = pFxo_pVelocity * pVelocity_pBodyVelocity[1][1] * ViscousWeight;
           pForces_pBodyVelocity[1][0][2] = pFxo_pVelocity * pVelocity_pBodyVelocity[1][2] * ViscousWeight;
                              
           pForces_pBodyVelocity[1][1][0] = pFyo_pVelocity * pVelocity_pBodyVelocity[1][0] * ViscousWeight;
           pForces_pBodyVelocity[1][1][1] = pFyo_pVelocity * pVelocity_pBodyVelocity[1][1] * ViscousWeight;
           pForces_pBodyVelocity[1][1][2] = pFyo_pVelocity * pVelocity_pBodyVelocity[1][2] * ViscousWeight;
                              
           pForces_pBodyVelocity[1][2][0] = pFzo_pVelocity * pVelocity_pBodyVelocity[1][0] * ViscousWeight;
           pForces_pBodyVelocity[1][2][1] = pFzo_pVelocity * pVelocity_pBodyVelocity[1][1] * ViscousWeight;
           pForces_pBodyVelocity[1][2][2] = pFzo_pVelocity * pVelocity_pBodyVelocity[1][2] * ViscousWeight;
                               
          pMoments_pBodyVelocity[1][0][0] = pMxo_pVelocity * pVelocity_pBodyVelocity[1][0] * ViscousWeight;
          pMoments_pBodyVelocity[1][0][1] = pMxo_pVelocity * pVelocity_pBodyVelocity[1][1] * ViscousWeight;
          pMoments_pBodyVelocity[1][0][2] = pMxo_pVelocity * pVelocity_pBodyVelocity[1][2] * ViscousWeight;
                          
          pMoments_pBodyVelocity[1][1][0] = pMyo_pVelocity * pVelocity_pBodyVelocity[1][0] * ViscousWeight;
          pMoments_pBodyVelocity[1][1][1] = pMyo_pVelocity * pVelocity_pBodyVelocity[1][1] * ViscousWeight;
          pMoments_pBodyVelocity[1][1][2] = pMyo_pVelocity * pVelocity_pBodyVelocity[1][2] * ViscousWeight;
                               
          pMoments_pBodyVelocity[1][2][0] = pMzo_pVelocity * pVelocity_pBodyVelocity[1][0] * ViscousWeight;
          pMoments_pBodyVelocity[1][2][1] = pMzo_pVelocity * pVelocity_pBodyVelocity[1][1] * ViscousWeight;
          pMoments_pBodyVelocity[1][2][2] = pMzo_pVelocity * pVelocity_pBodyVelocity[1][2] * ViscousWeight;     
                    
          if ( Dir <=  3 ) {
   
             // Alpha
             
             DF_DAlpha += pForces_pVinf[Dir-1][0]*pVinf_pAlpha[0] + pForces_pVinf[Dir-1][1]*pVinf_pAlpha[1] + pForces_pVinf[Dir-1][2]*pVinf_pAlpha[2];
             
             // Beta
             
             DF_DBeta += pForces_pVinf[Dir-1][0]*pVinf_pBeta[0] + pForces_pVinf[Dir-1][1]*pVinf_pBeta[1] + pForces_pVinf[Dir-1][2]*pVinf_pBeta[2];
   
             // Mach
             
             DF_DMach += 0.;
             
             // PQR
             
             xyz[0] = VSPGeom().Grid(MGLevel_).EdgeList(i).Xc() - Xcg();            
             xyz[1] = VSPGeom().Grid(MGLevel_).EdgeList(i).Yc() - Ycg();           
             xyz[2] = VSPGeom().Grid(MGLevel_).EdgeList(i).Zc() - Zcg();    
             
             // P - Roll
             
             pVinf_pP[0] = 0.;
             pVinf_pP[1] = -xyz[2];
             pVinf_pP[2] = +xyz[1];      
             
             DF_DP += pForces_pVinf[Dir-1][0]*pVinf_pP[0] + pForces_pVinf[Dir-1][1]*pVinf_pP[1] + pForces_pVinf[Dir-1][2]*pVinf_pP[2];
             
             // Q - Pitch
             
             pVinf_pQ[0] = -xyz[2];
             pVinf_pQ[1] = 0.;
             pVinf_pQ[2] = +xyz[0];    
             
             DF_DQ += pForces_pVinf[Dir-1][0]*pVinf_pQ[0] + pForces_pVinf[Dir-1][1]*pVinf_pQ[1] + pForces_pVinf[Dir-1][2]*pVinf_pQ[2];
             
             // R - Yaw
             
             pVinf_pR[0] = -xyz[1];
             pVinf_pR[1] = +xyz[0];
             pVinf_pR[2] = 0.;    
       
             DF_DR += pForces_pVinf[Dir-1][0]*pVinf_pR[0] + pForces_pVinf[Dir-1][1]*pVinf_pR[1] + pForces_pVinf[Dir-1][2]*pVinf_pR[2];

             // Reynold's number
             
             DFo_DRe_[0] = +pFxo_pRe;
             DFo_DRe_[1] = +pFyo_pRe;
             DFo_DRe_[2] = +pFzo_pRe;
                   
          }
          
          else if ( Dir > 3 ) {
          
             // Alpha
             
             DF_DAlpha += pMoments_pVinf[Dir-4][0]*pVinf_pAlpha[0] + pMoments_pVinf[Dir-4][1]*pVinf_pAlpha[1] + pMoments_pVinf[Dir-4][2]*pVinf_pAlpha[2];
             
             // Beta
             
             DF_DBeta += pMoments_pVinf[Dir-4][0]*pVinf_pBeta[0] + pMoments_pVinf[Dir-4][1]*pVinf_pBeta[1] + pMoments_pVinf[Dir-4][2]*pVinf_pBeta[2];
             
             // Mach
             
             DF_DMach += 0.;
             
             // P - Roll
             
             pVinf_pP[0] = 0.;
             pVinf_pP[1] = -xyz[2];
             pVinf_pP[2] = +xyz[1];      
             
             DF_DP += pMoments_pVinf[Dir-4][0]*pVinf_pP[0] + pMoments_pVinf[Dir-4][1]*pVinf_pP[1] + pMoments_pVinf[Dir-4][2]*pVinf_pP[2];
             
             // Q - Pitch
             
             pVinf_pQ[0] = -xyz[2];
             pVinf_pQ[1] = 0.;
             pVinf_pQ[2] = +xyz[0];    
             
             DF_DQ += pMoments_pVinf[Dir-4][0]*pVinf_pQ[0] + pMoments_pVinf[Dir-4][1]*pVinf_pQ[1] + pMoments_pVinf[Dir-4][2]*pVinf_pQ[2];
             
             // R - Yaw
             
             pVinf_pR[0] = -xyz[1];
             pVinf_pR[1] = +xyz[0];
             pVinf_pR[2] = 0.;    
       
             DF_DR += pMoments_pVinf[Dir-4][0]*pVinf_pR[0] + pMoments_pVinf[Dir-4][1]*pVinf_pR[1] + pMoments_pVinf[Dir-4][2]*pVinf_pR[2];       
           
             // Reynold's number

             DMo_DRe_[0] += pFzo_pRe * ( RVec[1] - XYZcg_[1] ) - pFyo_pRe * ( RVec[2] - XYZcg_[2] );   // Roll
             DMo_DRe_[1] += pFxo_pRe * ( RVec[2] - XYZcg_[2] ) - pFzo_pRe * ( RVec[0] - XYZcg_[0] );   // Pitch
             DMo_DRe_[2] += pFyo_pRe * ( RVec[0] - XYZcg_[0] ) - pFxo_pRe * ( RVec[1] - XYZcg_[1] );   // Yaw
 
          }
          
          // For rotor cases we need to find inviscid partials wrt omega
          
          g = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Group();
          
          if ( VSPGeom().ComponentGroupList(g).GeometryIsARotor() ) {

             OVec[0] = VSPGeom().ComponentGroupList(g).OVec(0); // Rotation origin
             OVec[1] = VSPGeom().ComponentGroupList(g).OVec(1);
             OVec[2] = VSPGeom().ComponentGroupList(g).OVec(2);
                                                   
             RVec[0] = VSPGeom().ComponentGroupList(g).RVec(0); // Rotation vector
             RVec[1] = VSPGeom().ComponentGroupList(g).RVec(1);
             RVec[2] = VSPGeom().ComponentGroupList(g).RVec(2);
                                                   
             TVec[0] = VSPGeom().ComponentGroupList(g).TVec(0); // Translation vector
             TVec[1] = VSPGeom().ComponentGroupList(g).TVec(1);
             TVec[2] = VSPGeom().ComponentGroupList(g).TVec(2);
             
             VSPGeom().ComponentGroupList(g).Update();
      
             Quat = VSPGeom().ComponentGroupList(g).Quat();
             
             InvQuat = VSPGeom().ComponentGroupList(g).InvQuat();
             
             WQuat = VSPGeom().ComponentGroupList(g).WQuat();
             
             pWQuat_pOmega = VSPGeom().ComponentGroupList(g).pWQuat_pOmega();

             for ( p = 0 ; p <= 1 ; p++ ) {
                
                if ( p == 0 ) j = LE_Edge;
                if ( p == 1 ) j = TE_Edge;
                
                // Calculate surface velocity for edge centroids
                
                Vec1(0) = VSPGeom().Grid(MGLevel_).EdgeList(j).Xc() - OVec[0];
                Vec1(1) = VSPGeom().Grid(MGLevel_).EdgeList(j).Yc() - OVec[1];
                Vec1(2) = VSPGeom().Grid(MGLevel_).EdgeList(j).Zc() - OVec[2];
            
                // Body point location after rotation
                
                Vec2 = Quat * Vec1 * InvQuat;
         
                // Body point velocity
                
                BodyVelocity = WQuat * Vec2;
                
                pBodyVelocity_pOmega = pWQuat_pOmega * Vec2;
     
                // Calculate inviscid gradients wrt omega
             
                if ( Dir <= 3 ) {
                   
                   DF_DOmega[g] += pForces_pBodyVelocity[p][Dir-1][0] * pBodyVelocity_pOmega(0)
                                 + pForces_pBodyVelocity[p][Dir-1][1] * pBodyVelocity_pOmega(1)
                                 + pForces_pBodyVelocity[p][Dir-1][2] * pBodyVelocity_pOmega(2);      

                }
                
                else {
                
                   xyz[0] = VSPGeom().Grid(MGLevel_).EdgeList(j).Xc() - Xcg();            
                   xyz[1] = VSPGeom().Grid(MGLevel_).EdgeList(j).Yc() - Ycg();           
                   xyz[2] = VSPGeom().Grid(MGLevel_).EdgeList(j).Zc() - Zcg();    
                              
                   DF_DOmega[g] += pMoments_pBodyVelocity[p][Dir-4][0] * pBodyVelocity_pOmega(0)
                                 + pMoments_pBodyVelocity[p][Dir-4][1] * pBodyVelocity_pOmega(1)
                                 + pMoments_pBodyVelocity[p][Dir-4][2] * pBodyVelocity_pOmega(2);      
                                                 
                }    
                
             }   
                 
          }          
          
       }
       
    }

    // Calculate partial residual wrt partial free stream (U,V,W) contributuions for vorticity equations

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {

       Psi = VSPGeom().Grid(MGLevel_).LoopList(i).Psi();

       // Alpha and Beta
       
       pR_pVinf[0] = VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[0];
       pR_pVinf[1] = VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[1];
       pR_pVinf[2] = VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[2];
       
       // Alpha
       
       DF_DAlpha -= Psi * ( pR_pVinf[0] * pVinf_pAlpha[0] + pR_pVinf[1] * pVinf_pAlpha[1] + pR_pVinf[2] * pVinf_pAlpha[2] );
       
       // Beta
       
       DF_DBeta -= Psi * ( pR_pVinf[0] *   pVinf_pBeta[0] + pR_pVinf[1] *  pVinf_pBeta[1] + pR_pVinf[2] *  pVinf_pBeta[2] );
       
       // Mach 
       
       DF_DMach -= Psi * ( VSPGeom().Grid(MGLevel_).LoopList(i).dU_dMach() * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[0]
                         + VSPGeom().Grid(MGLevel_).LoopList(i).dV_dMach() * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[1]
                         + VSPGeom().Grid(MGLevel_).LoopList(i).dW_dMach() * VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[2] );
       
       // PQR
       
       xyz[0] = VSPGeom().Grid(MGLevel_).LoopList(i).Xc() - Xcg();            
       xyz[1] = VSPGeom().Grid(MGLevel_).LoopList(i).Yc() - Ycg();           
       xyz[2] = VSPGeom().Grid(MGLevel_).LoopList(i).Zc() - Zcg();    

       // P - Roll

       pVinf_pP[0] = 0.;
       pVinf_pP[1] = -xyz[2];
       pVinf_pP[2] = +xyz[1];      
       
       DF_DP -= Psi * ( pR_pVinf[0] * pVinf_pP[0] + pR_pVinf[1] * pVinf_pP[1] + pR_pVinf[2] * pVinf_pP[2] );

       // Q - Pitch

       pVinf_pQ[0] = -xyz[2];
       pVinf_pQ[1] = 0.;
       pVinf_pQ[2] = +xyz[0];    

       DF_DQ -= Psi * ( pR_pVinf[0] * pVinf_pQ[0] + pR_pVinf[1] * pVinf_pQ[1] + pR_pVinf[2] * pVinf_pQ[2] );

       // R - Yaw

       pVinf_pR[0] = -xyz[1];
       pVinf_pR[1] = +xyz[0];
       pVinf_pR[2] = 0.;    
       
       DF_DR -= Psi * ( pR_pVinf[0] * pVinf_pR[0] + pR_pVinf[1] * pVinf_pR[1] + pR_pVinf[2] * pVinf_pR[2] );
                 
    }  
    
    // Calculate unsteady or quasi-unsteady surface velocity terms

    for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
             
       // If a rotor...
    
       if ( VSPGeom().ComponentGroupList(g).GeometryIsARotor() ) {

          OVec[0] = VSPGeom().ComponentGroupList(g).OVec(0); // Rotation origin
          OVec[1] = VSPGeom().ComponentGroupList(g).OVec(1);
          OVec[2] = VSPGeom().ComponentGroupList(g).OVec(2);
                                                 
          RVec[0] = VSPGeom().ComponentGroupList(g).RVec(0); // Rotation vector
          RVec[1] = VSPGeom().ComponentGroupList(g).RVec(1);
          RVec[2] = VSPGeom().ComponentGroupList(g).RVec(2);
                                                
          TVec[0] = VSPGeom().ComponentGroupList(g).TVec(0); // Translation vector
          TVec[1] = VSPGeom().ComponentGroupList(g).TVec(1);
          TVec[2] = VSPGeom().ComponentGroupList(g).TVec(2);
   
          Quat = VSPGeom().ComponentGroupList(g).Quat();
          
          InvQuat = VSPGeom().ComponentGroupList(g).InvQuat();
          
          WQuat = VSPGeom().ComponentGroupList(g).WQuat();
          
          pWQuat_pOmega = VSPGeom().ComponentGroupList(g).pWQuat_pOmega();
          
          zero_int_array(ComponentInThisGroup, VSPGeom().NumberOfComponents());
          
          for ( j = 1 ; j <= VSPGeom().ComponentGroupList(g).NumberOfComponents() ; j++ ) {
   
             ComponentInThisGroup[VSPGeom().ComponentGroupList(g).ComponentList(j)] = 1;
             
          }
   
          // Calculate PsiT x pResidual_pOmega
          
          for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
        
             pR_pBodyVelocity[0] = -VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[0];
             pR_pBodyVelocity[1] = -VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[1];
             pR_pBodyVelocity[2] = -VSPGeom().Grid(MGLevel_).LoopList(i).Normal()[2];
 
             Psi = VSPGeom().Grid(MGLevel_).LoopList(i).Psi();
             
             if ( ComponentInThisGroup[VSPGeom().Grid(MGLevel_).LoopList(i).ComponentID()] ) {
   
                Vec1(0) = VSPGeom().Grid(MGLevel_).LoopList(i).Xc() - OVec[0];
                Vec1(1) = VSPGeom().Grid(MGLevel_).LoopList(i).Yc() - OVec[1];
                Vec1(2) = VSPGeom().Grid(MGLevel_).LoopList(i).Zc() - OVec[2];
            
                // Body point location after rotation
        
                Vec2 = Quat * Vec1 * InvQuat;
   
                // Body point velocity
   
                BodyVelocity = WQuat * Vec2;
                
                pBodyVelocity_pOmega = pWQuat_pOmega * Vec2;
            
                DF_DOmega[g] -= Psi * ( pR_pBodyVelocity[0] * pBodyVelocity_pOmega(0)
                                      + pR_pBodyVelocity[1] * pBodyVelocity_pOmega(1)
                                      + pR_pBodyVelocity[2] * pBodyVelocity_pOmega(2) );
             
             }
      
          }
          
       }
       
    }
         
    // Calculate partial residual wrt partial free stream (U,V,W) contributuions for wake equations

    for ( i = 1 ; i <= VSPGeom().NumberOfVortexSheets() ; i++ ) {
      
       for ( j = 1 ; j <= VSPGeom().VortexSheet(i).NumberOfTrailingVortices() ; j++ ) {
         
          for ( k = 1 ; k < VSPGeom().VortexSheet(i).TrailingVortex(j).NumberOfNodes() ; k++ ) {
            
             // Wake edge
             
             Edge = VSPGeom().VortexSheet(i).TrailingVortex(j).GlobalEdge(k);
             
             if ( !TimeAccurate_ ) {
             
                // Partial of wake residuals wrt free stream
                
                VSPGeom().Grid(MGLevel_).EdgeList(Edge).Wake_pResidual_pVinf(pResidual_pVinf);
                
                // Partial of wake residuals wrt Mach
                
                VSPGeom().Grid(MGLevel_).EdgeList(Edge).Wake_pResidual_pMach(pResidual_pMach);
                
             }
             
             else {
                
                // Partial of wake residuals wrt free stream
                
                VSPGeom().Grid(MGLevel_).EdgeList(Edge).UnsteadyWake_pResidual_pVinf(pResidual_pVinf, DeltaTime_);
                
                // Partial of wake residuals wrt Mach
                
                VSPGeom().Grid(MGLevel_).EdgeList(Edge).UnsteadyWake_pResidual_pMach(pResidual_pMach, DeltaTime_);
                                
             }
                             
             // Loop over x, y, and z equations
             
             for ( p = 0 ; p <= 2 ; p++ ) {
               
                if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).WakeEdgeData().Direction() == 1 ) {
                
                   Psi = VSPGeom().Grid(MGLevel_).NodeList(VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node2()).Psi(p);
                
                }
                
                else {
                   
                   Psi = VSPGeom().Grid(MGLevel_).NodeList(VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node1()).Psi(p);
                
                }                  
                   
                // Alpha and Beta
                
                pR_pVinf[0] = pResidual_pVinf[p][0];
                pR_pVinf[1] = pResidual_pVinf[p][1];
                pR_pVinf[2] = pResidual_pVinf[p][2];
              
                // Alpha
                
                DF_DAlpha -= Psi * ( pR_pVinf[0] * pVinf_pAlpha[0] + pR_pVinf[1] * pVinf_pAlpha[1] + pR_pVinf[2] * pVinf_pAlpha[2] );
                
                // Beta
                
                DF_DBeta  -= Psi * ( pR_pVinf[0] *  pVinf_pBeta[0] + pR_pVinf[1] *  pVinf_pBeta[1] + pR_pVinf[2] *  pVinf_pBeta[2] );
                
                // Mach 
                
                DF_DMach  -= Psi * pResidual_pMach[p];
                
                // PQR
                
                xyz[0] = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - Xcg();            
                xyz[1] = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - Ycg();           
                xyz[2] = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - Zcg();    
         
                // P - Roll
         
                pVinf_pP[0] = 0.;
                pVinf_pP[1] = -xyz[2];
                pVinf_pP[2] = +xyz[1];      
                
                DF_DP -= Psi * ( pR_pVinf[0] * pVinf_pP[0] + pR_pVinf[1] * pVinf_pP[1] + pR_pVinf[2] * pVinf_pP[2] );
         
                // Q - Pitch
         
                pVinf_pQ[0] = -xyz[2];
                pVinf_pQ[1] = 0.;
                pVinf_pQ[2] = +xyz[0];    
         
                DF_DQ -= Psi * ( pR_pVinf[0] * pVinf_pQ[0] + pR_pVinf[1] * pVinf_pQ[1] + pR_pVinf[2] * pVinf_pQ[2] );
         
                // R - Yaw
         
                pVinf_pR[0] = -xyz[1];
                pVinf_pR[1] = +xyz[0];
                pVinf_pR[2] = 0.;    
                
                DF_DR -= Psi * ( pR_pVinf[0] * pVinf_pR[0] + pR_pVinf[1] * pVinf_pR[1] + pR_pVinf[2] * pVinf_pR[2] );
             
                // If this is a rotor group add in partials wrt omega for quasi unsteady rotor cases
                
                if ( VSPGeom().VortexSheet(i).IsARotor() && !TimeAccurate_ ) {
                   
                   g = VSPGeom().VortexSheet(i).TrailingVortex(j).Group();
                            
                   OVec[0] = VSPGeom().ComponentGroupList(g).OVec(0); // Rotation origin
                   OVec[1] = VSPGeom().ComponentGroupList(g).OVec(1);
                   OVec[2] = VSPGeom().ComponentGroupList(g).OVec(2);
                                                          
                   RVec[0] = VSPGeom().ComponentGroupList(g).RVec(0); // Rotation vector
                   RVec[1] = VSPGeom().ComponentGroupList(g).RVec(1);
                   RVec[2] = VSPGeom().ComponentGroupList(g).RVec(2);
                                                         
                   TVec[0] = VSPGeom().ComponentGroupList(g).TVec(0); // Translation vector
                   TVec[1] = VSPGeom().ComponentGroupList(g).TVec(1);
                   TVec[2] = VSPGeom().ComponentGroupList(g).TVec(2);
                   
                   Quat = VSPGeom().ComponentGroupList(g).Quat();
                   
                   InvQuat = VSPGeom().ComponentGroupList(g).InvQuat();
                   
                   WQuat = VSPGeom().ComponentGroupList(g).WQuat();
                   
                   pWQuat_pOmega = VSPGeom().ComponentGroupList(g).pWQuat_pOmega();
                                                    
                   if ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).WakeEdgeData().Direction() > 0 ) {
                   
                      Vec1(0) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).X2() - OVec[0];
                      Vec1(1) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Y2() - OVec[1];
                      Vec1(2) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Z2() - OVec[2];            
                                
                   }
                          
                   else {
                   
                      Vec1(0) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).X1() - OVec[0];
                      Vec1(1) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Y1() - OVec[1];
                      Vec1(2) = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Z1() - OVec[2];    
                                
                   }     
                                        
                   Vec2 = Quat * Vec1 * InvQuat;
                   
                   // Rotation velocity
                   
                   RotationalVelocity = WQuat * Vec2;
                   
                   pBodyVelocity_pOmega = pWQuat_pOmega * Vec2;
                   
                   // Partial wrt body velocity
                   
                   pVinf_pBodyVelocity[0] = -1.;
                   pVinf_pBodyVelocity[1] = -1.;
                   pVinf_pBodyVelocity[2] = -1.;
                   
                   DF_DOmega[g] -= Psi * ( pR_pVinf[0] * pVinf_pBodyVelocity[0] * pBodyVelocity_pOmega(0) 
                                         + pR_pVinf[1] * pVinf_pBodyVelocity[1] * pBodyVelocity_pOmega(1) 
                                         + pR_pVinf[2] * pVinf_pBodyVelocity[2] * pBodyVelocity_pOmega(2) );
                                  
                }
                
             }               
                    
          }
          
       }
                                            
    }   

    // Calculate partial residual wrt partial free stream (U,V,W) contributuions for stall equations

    if ( StallModelIsOn_ ) {
   
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             LE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).LE_Edge());
   
             TE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
             
             Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
   
             GammaTE = Sign * VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Gamma();
             
             Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
             
             Psi = VSPGeom().VortexSheet(k).TrailingVortex(i).Psi();
             
             Velocity = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[0], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[1], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[2], 2.) );
   
             if ( Velocity > 0. ) {
               
                Cl_Ratio = GammaTE / ( 0.5 * Chord * Velocity * Clmax_2d_ );
                
                dCl_Ratio_dVelocity = -GammaTE / ( 0.5 * Chord  * Velocity * Velocity * Clmax_2d_ );
   
                StallFunction(ABS(Cl_Ratio),Fstall,pFstall_pX);
                
                dABS_Cl_Ratio_dCl_Ratio = 1.;
                
                if ( Cl_Ratio < 0. ) dABS_Cl_Ratio_dCl_Ratio = -1.;
                
                pR_Velocity = pFstall_pX * dABS_Cl_Ratio_dCl_Ratio * dCl_Ratio_dVelocity;
                
                pR_pVinf[0] = -pR_Velocity * VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[0] / Velocity;
                pR_pVinf[1] = -pR_Velocity * VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[1] / Velocity;
                pR_pVinf[2] = -pR_Velocity * VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[2] / Velocity;
                
                // Alpha
                
                DF_DAlpha -= Psi * ( pR_pVinf[0] * pVinf_pAlpha[0] + pR_pVinf[1] * pVinf_pAlpha[1] + pR_pVinf[2] * pVinf_pAlpha[2] );
                
                // Beta
                
                DF_DBeta  -= Psi * ( pR_pVinf[0] *  pVinf_pBeta[0] + pR_pVinf[1] *  pVinf_pBeta[1] + pR_pVinf[2] *  pVinf_pBeta[2] );
                
                // Mach 
                
                DF_DMach  -= Psi * 0.;
                
                // PQR
                
                xyz[0] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc() - Xcg();            
                xyz[1] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc() - Ycg();           
                xyz[2] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc() - Zcg();    
            
                // P - Roll
            
                pVinf_pP[0] = 0.;
                pVinf_pP[1] = -xyz[2];
                pVinf_pP[2] = +xyz[1];      
                
                DF_DP -= Psi * ( pR_pVinf[0] * pVinf_pP[0] + pR_pVinf[1] * pVinf_pP[1] + pR_pVinf[2] * pVinf_pP[2] );
            
                // Q - Pitch
            
                pVinf_pQ[0] = -xyz[2];
                pVinf_pQ[1] = 0.;
                pVinf_pQ[2] = +xyz[0];    
            
                DF_DQ -= Psi * ( pR_pVinf[0] * pVinf_pQ[0] + pR_pVinf[1] * pVinf_pQ[1] + pR_pVinf[2] * pVinf_pQ[2] );
            
                // R - Yaw
            
                pVinf_pR[0] = -xyz[1];
                pVinf_pR[1] = +xyz[0];
                pVinf_pR[2] = 0.;    
                
                DF_DR -= Psi * ( pR_pVinf[0] * pVinf_pR[0] + pR_pVinf[1] * pVinf_pR[1] + pR_pVinf[2] * pVinf_pR[2] );
      
             }             
   
          }
          
       }
       
    }
    
    // Scale for symmetry
    
    if ( DoSymmetryPlaneSolve_ ) {
       
      DF_DAlpha *= 2.;
      DF_DBeta  *= 2.;
      DF_DP     *= 2.;
      DF_DQ     *= 2.;
      DF_DR     *= 2.;
      DF_DMach  *= 2.;
      
      for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
         
         DF_DOmega[g] *= 2.;
         
      }
    
    }       

    // Non-dimensionalize
    
    DF_DAlpha /= (0.5*Sref_*Vref_*Vref_);
    DF_DBeta  /= (0.5*Sref_*Vref_*Vref_);
    DF_DP     /= (0.5*Sref_*Vref_*Vref_);
    DF_DQ     /= (0.5*Sref_*Vref_*Vref_);
    DF_DR     /= (0.5*Sref_*Vref_*Vref_);
    DF_DMach  /= (0.5*Sref_*Vref_*Vref_);

    for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
       
       DF_DOmega[g] /= (0.5*Sref_*Vref_*Vref_);
       
    }
    
    if ( Dir == 4 || Dir == 6 ) {

       DF_DAlpha /= Bref_;
       DF_DBeta  /= Bref_;
       DF_DP     /= Bref_;
       DF_DQ     /= Bref_;
       DF_DR     /= Bref_;
       DF_DMach  /= Bref_;
       
       for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
          
          DF_DOmega[g] /= Bref_;
          
       }       
       
    }
    
    if ( Dir == 5 ) {

       DF_DAlpha /= Cref_;
       DF_DBeta  /= Cref_;
       DF_DP     /= Cref_;
       DF_DQ     /= Cref_;
       DF_DR     /= Cref_;
       DF_DMach  /= Cref_;

       for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
          
          DF_DOmega[g] /= Cref_;
          
       }    
              
    }    
    
    DF_DP  /= (Bref_ * 0.5 / Vref_);
    DF_DQ  /= (Cref_ * 0.5 / Vref_);
    DF_DR  /= (Bref_ * 0.5 / Vref_);
      
    if ( Verbose_ ) {
                   
       printf("DF_DAlpha: %f \n",DF_DAlpha);
       printf("DF_DBeta:  %f \n",DF_DBeta);
       printf("DF_DP:     %f \n",DF_DP);
       printf("DF_DQ:     %f \n",DF_DQ);
       printf("DF_DR:     %f \n",DF_DR);fflush(NULL);
       printf("DF_DMach:  %f \n",DF_DMach);
       
       for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
          
          printf("DF_DOmega[%d]: %f \n",g,DF_DOmega[g]);
           
       }
       
    }
   
    // Forces
    
    if ( Dir <= 3 ) {
       
       if ( ForceCase == 1 || ForceCase == 3 ) {
         
          DFi_DAlpha_[Dir-1] += InviscidWeight * DF_DAlpha;
          DFi_DBeta_[Dir-1]  += InviscidWeight * DF_DBeta;
          DFi_DP_[Dir-1]     += InviscidWeight * DF_DP;
          DFi_DQ_[Dir-1]     += InviscidWeight * DF_DQ;
          DFi_DR_[Dir-1]     += InviscidWeight * DF_DR;
          DFi_DMach_[Dir-1]  += InviscidWeight * DF_DMach; 

          DFw_DAlpha_[Dir-1] +=     WakeWeight * DF_DAlpha;
          DFw_DBeta_[Dir-1]  +=     WakeWeight * DF_DBeta;
          DFw_DP_[Dir-1]     +=     WakeWeight * DF_DP;
          DFw_DQ_[Dir-1]     +=     WakeWeight * DF_DQ;
          DFw_DR_[Dir-1]     +=     WakeWeight * DF_DR;
          DFw_DMach_[Dir-1]  +=     WakeWeight * DF_DMach; 
              
          for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
             
             if ( Dir == 1 ) VSPGeom().ComponentGroupList(g).DCFxi_DOmega() = DF_DOmega[g];
             if ( Dir == 2 ) VSPGeom().ComponentGroupList(g).DCFyi_DOmega() = DF_DOmega[g];
             if ( Dir == 3 ) VSPGeom().ComponentGroupList(g).DCFzi_DOmega() = DF_DOmega[g];
           
             if ( TimeAccurate_ ) {
                
                if ( Dir == 1 ) VSPGeom().ComponentGroupList(g).DCFxi_DOmega(Time_) = DF_DOmega[g];
                if ( Dir == 2 ) VSPGeom().ComponentGroupList(g).DCFyi_DOmega(Time_) = DF_DOmega[g];
                if ( Dir == 3 ) VSPGeom().ComponentGroupList(g).DCFzi_DOmega(Time_) = DF_DOmega[g];
                
             }                
              
          }    
          
       }
       
       else if ( ForceCase == 2 ) {
          
          DFo_DAlpha_[Dir-1] += DF_DAlpha;
          DFo_DBeta_[Dir-1]  += DF_DBeta;
          DFo_DP_[Dir-1]     += DF_DP;
          DFo_DQ_[Dir-1]     += DF_DQ;
          DFo_DR_[Dir-1]     += DF_DR;
          DFo_DMach_[Dir-1]  += DF_DMach; 
         
          for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
             
             if ( Dir == 1 ) VSPGeom().ComponentGroupList(g).DCFxo_DOmega() = DF_DOmega[g];
             if ( Dir == 2 ) VSPGeom().ComponentGroupList(g).DCFyo_DOmega() = DF_DOmega[g];
             if ( Dir == 3 ) VSPGeom().ComponentGroupList(g).DCFzo_DOmega() = DF_DOmega[g];
                
             if ( TimeAccurate_ ) {
                
                if ( Dir == 1 ) VSPGeom().ComponentGroupList(g).DCFxo_DOmega(Time_) = DF_DOmega[g];
                if ( Dir == 2 ) VSPGeom().ComponentGroupList(g).DCFyo_DOmega(Time_) = DF_DOmega[g];
                if ( Dir == 3 ) VSPGeom().ComponentGroupList(g).DCFzo_DOmega(Time_) = DF_DOmega[g];
                
             }                
              
          } 
                    
       }          
               
    }
    
    // Moments
    
    else if ( Dir > 3 ) {
       
       if ( ForceCase == 1 || ForceCase == 3 ) {
       
          DMi_DAlpha_[Dir-4] = InviscidWeight * DF_DAlpha;
          DMi_DBeta_[Dir-4]  = InviscidWeight * DF_DBeta;
          DMi_DP_[Dir-4]     = InviscidWeight * DF_DP;
          DMi_DQ_[Dir-4]     = InviscidWeight * DF_DQ;
          DMi_DR_[Dir-4]     = InviscidWeight * DF_DR;
          DMi_DMach_[Dir-4]  = InviscidWeight * DF_DMach; 

          DMi_DAlpha_[Dir-4] =     WakeWeight * DF_DAlpha;
          DMi_DBeta_[Dir-4]  =     WakeWeight * DF_DBeta;
          DMi_DP_[Dir-4]     =     WakeWeight * DF_DP;
          DMi_DQ_[Dir-4]     =     WakeWeight * DF_DQ;
          DMi_DR_[Dir-4]     =     WakeWeight * DF_DR;
          DMi_DMach_[Dir-4]  =     WakeWeight * DF_DMach; 
                    
          for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
             
             if ( Dir == 4 ) VSPGeom().ComponentGroupList(g).DCMxi_DOmega() = DF_DOmega[g];
             if ( Dir == 5 ) VSPGeom().ComponentGroupList(g).DCMyi_DOmega() = DF_DOmega[g];
             if ( Dir == 6 ) VSPGeom().ComponentGroupList(g).DCMzi_DOmega() = DF_DOmega[g];
          
             if ( TimeAccurate_ ) {
                
                if ( Dir == 4 ) VSPGeom().ComponentGroupList(g).DCMxi_DOmega(Time_) = DF_DOmega[g];
                if ( Dir == 5 ) VSPGeom().ComponentGroupList(g).DCMyi_DOmega(Time_) = DF_DOmega[g];
                if ( Dir == 6 ) VSPGeom().ComponentGroupList(g).DCMzi_DOmega(Time_) = DF_DOmega[g];
                
             }                
              
          }    
                    
       }
       
       else if ( ForceCase == 2 ) {
          
          DMo_DAlpha_[Dir-4] = DF_DAlpha;
          DMo_DBeta_[Dir-4]  = DF_DBeta;
          DMo_DP_[Dir-4]     = DF_DP;
          DMo_DQ_[Dir-4]     = DF_DQ;
          DMo_DR_[Dir-4]     = DF_DR;
          DMo_DMach_[Dir-4]  = DF_DMach; 
          
          for ( g = 1 ; g <= VSPGeom().NumberOfComponentGroups() ; g++ ) {
             
             if ( Dir == 4 ) VSPGeom().ComponentGroupList(g).DCMxo_DOmega() = DF_DOmega[g];
             if ( Dir == 5 ) VSPGeom().ComponentGroupList(g).DCMyo_DOmega() = DF_DOmega[g];
             if ( Dir == 6 ) VSPGeom().ComponentGroupList(g).DCMzo_DOmega() = DF_DOmega[g];
             
             if ( TimeAccurate_ ) {
                
                if ( Dir == 4 ) VSPGeom().ComponentGroupList(g).DCMxo_DOmega(Time_) = DF_DOmega[g];
                if ( Dir == 5 ) VSPGeom().ComponentGroupList(g).DCMyo_DOmega(Time_) = DF_DOmega[g];
                if ( Dir == 6 ) VSPGeom().ComponentGroupList(g).DCMzo_DOmega(Time_) = DF_DOmega[g];
                
             }                
              
          }    
                    
       }          
                            
    }

    delete [] ComponentInThisGroup;
    delete [] DF_DOmega;
      
}

/*##############################################################################
#                                                                              #
#          VSP_SOLVER CalculateEdgeMachPerturbationVelocities                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateMachPerturbationVelocities(void)
{
   
    int Level;
     
    // Update the vortex strengths

    UpdateVortexEdgeStrengths(MGLevel_, ALL_WAKE_GAMMAS);
    
    for ( Level = MGLevel_ ; Level < NumberOfMGLevels_ ; Level++ ) {
        
       RestrictSolutionFromGrid(Level);
       
       UpdateVortexEdgeStrengths(Level+1, ALL_WAKE_GAMMAS);

    }

    // Loops
    
    CalculateLoopMachPerturbationVelocities();
    
    ProlongateMachLoopVelocity();
    
    // Edges
    
    CalculateEdgeMachPerturbationVelocities();
        
    ProlongateMachEdgeVelocity();
   
}
   
/*##############################################################################
#                                                                              #
#            VSP_SOLVER CalculateLoopMachPerturbationVelocities                #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateLoopMachPerturbationVelocities(void)
{

    int i, j, k, v, Level, Loop, Loop1, Loop2, LoopType, MaxLoopTypes, cpu, NumberOfSheets;
    double q[3], xyz[3], Ws, U, V, W, WsMag, EdgeGamma;
    VSP_EDGE *VortexEdge;
    VORTEX_SHEET_ENTRY *VortexSheetList;

    // Zero out perturbabtion
 
    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfLoops() ; i++ ) {

          VSPGeom().Grid(Level).LoopList(i).dU_dMach() = 0.;
          VSPGeom().Grid(Level).LoopList(i).dV_dMach() = 0.;
          VSPGeom().Grid(Level).LoopList(i).dW_dMach() = 0.;

       }
       
    }         

    // Surface vortex induced velocities

    MaxLoopTypes = 0;
    
    U = V = W = 0.;

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

//#pragma omp parallel for private(U,V,W,j,Level,Loop,q,VortexEdge,xyz) schedule(dynamic)          
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionLoops(LoopType) ; i++ ) {

          Level  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Level();

          Loop  = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].Loop();
       
          U = V = W = 0.;

          if ( VSPGeom().Grid(Level).LoopList(Loop).SurfaceID() > 0 ) {

             for ( j = 1 ; j <= FastMatrix_.ForwardInteractionLoopList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
       
               // VortexEdge = InteractionLoopToEdgeList[LoopType][i].SurfaceVortexEdgeInteractionList(j);
      
                VortexEdge = FastMatrix_.ForwardInteractionLoopList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);
   
                VortexEdge->dInducedVelocity_dMach(VSPGeom().Grid(Level).LoopList(Loop).xyz_c(), q);
            
                U += q[0];
                V += q[1];
                W += q[2];
                      
                // If there is ground effects, z plane...
                
                if ( DoGroundEffectsAnalysis() ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
         
                   xyz[2] *= -1.;
                  
                   VortexEdge->InducedVelocity(xyz, q);        
         
                   q[2] *= -1.;
                  
                   U += q[0];
                   V += q[1];
                   W += q[2];
                  
                }     
                          
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[0];
                   xyz[1] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[1];
                   xyz[2] = VSPGeom().Grid(Level).LoopList(Loop).xyz_c()[2];
         
                   xyz[1] *= -1.;
                  
                   VortexEdge->InducedVelocity(xyz, q);        
         
                   q[1] *= -1.;
                  
                   U += q[0];
                   V += q[1];
                   W += q[2];
                   
                   // If there is ground effects, z plane...
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                      xyz[2] *= -1.;
                     
                      VortexEdge->InducedVelocity(xyz, q);        
            
                      q[1] *= -1.;         
                      q[2] *= -1.;
                     
                      U += q[0];
                      V += q[1];
                      W += q[2];
                     
                   }                     
                  
                }                
      
             }
             
          }
          
          VSPGeom().Grid(Level).LoopList(Loop).dU_dMach() += U;
          VSPGeom().Grid(Level).LoopList(Loop).dV_dMach() += V;   
          VSPGeom().Grid(Level).LoopList(Loop).dW_dMach() += W;

       }
       
    }

}

/*##############################################################################
#                                                                              #
#          VSP_SOLVER CalculateEdgeMachPerturbationVelocities                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateEdgeMachPerturbationVelocities(void)
{

    int i, j, k, m, p, v, Level, Edge, Loop, Loop1, Loop2, LoopType, MaxLoopTypes, cpu, NumberOfSheets;
    double q[3], xyz[3], Ws, U, V, W, WsMag, EdgeGamma;
    double Area1, Area2, Wgt1, Wgt2;
    VSP_EDGE *VortexEdge;
    
    // Zero perturbation velocities

    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {

       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {
          
          VSPGeom().Grid(Level).EdgeList(i).dU_dMach() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dV_dMach() = 0.;
          VSPGeom().Grid(Level).EdgeList(i).dW_dMach() = 0.;

       }
       
    }    

    // Surface vortex induced velocities

    MaxLoopTypes = 0;
    
    U = V = W = 0.;

    for ( LoopType = 0 ; LoopType <= MaxLoopTypes ; LoopType++ ) {

#pragma omp parallel for private(U,V,W,j,Edge,Level,q,VortexEdge,xyz) schedule(dynamic)          
       for ( i = 1 ; i <= FastMatrix_.NumberOfForwardInteractionEdges(LoopType) ; i++ ) {
   
          Level = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Level();

          Edge  = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].Edge();

          U = V = W = 0.;

          for ( j = 1 ; j <= FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].NumberOfVortexEdges() ; j++ ) {
    
             VortexEdge = FastMatrix_.ForwardInteractionEdgeList(LoopType)[i].SurfaceVortexEdgeInteractionList(j);

             VortexEdge->dInducedVelocity_dMach(VSPGeom().Grid(Level).EdgeList(Edge).xyz_c(), q);
         
             U += q[0];
             V += q[1];
             W += q[2];
                   
             // If there is ground effects, z plane...
             
             if ( DoGroundEffectsAnalysis() ) {
                
                xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
      
                xyz[2] *= -1.;
               
                VortexEdge->InducedVelocity(xyz, q);        
      
                q[2] *= -1.;
               
                U += q[0];
                V += q[1];
                W += q[2];
               
             }     
                       
             // If there is a symmetry plane, calculate influence of the reflection
             
             if ( DoSymmetryPlaneSolve_ ) {
                
                xyz[0] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[0];
                xyz[1] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[1];
                xyz[2] = VSPGeom().Grid(Level).EdgeList(Edge).xyz_c()[2];
      
                xyz[1] *= -1.;
               
                VortexEdge->InducedVelocity(xyz, q);        
      
                q[1] *= -1.;
               
                U += q[0];
                V += q[1];
                W += q[2];
                
                // If there is ground effects, z plane...
                
                if ( DoGroundEffectsAnalysis() ) {
      
                   xyz[2] *= -1.;
                  
                   VortexEdge->InducedVelocity(xyz, q);        
         
                   q[1] *= -1.;         
                   q[2] *= -1.;
                  
                   U += q[0];
                   V += q[1];
                   W += q[2];
                  
                }                     
               
             }                
   
          }

          VSPGeom().Grid(Level).EdgeList(Edge).dU_dMach() += U;
          VSPGeom().Grid(Level).EdgeList(Edge).dV_dMach() += V;   
          VSPGeom().Grid(Level).EdgeList(Edge).dW_dMach() += W; 

       }
       
    }
      
}

/*##############################################################################
#                                                                              #
#                    VSP_SOLVER ProlongateMachLoopVelocity                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateMachLoopVelocity(void) 
{
 
    int Level, i_c, i_f, j;

    for ( Level = NumberOfMGLevels_ ; Level > 1; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfLoops() ; i_c++ ) {
         
          for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfFineGridLoops() ; j++ ) {
             
             i_f = VSPGeom().Grid(Level).LoopList(i_c).FineGridLoop(j);

             VSPGeom().Grid(Level-1).LoopList(i_f).dU_dMach() += VSPGeom().Grid(Level).LoopList(i_c).dU_dMach();
             VSPGeom().Grid(Level-1).LoopList(i_f).dV_dMach() += VSPGeom().Grid(Level).LoopList(i_c).dV_dMach();
             VSPGeom().Grid(Level-1).LoopList(i_f).dW_dMach() += VSPGeom().Grid(Level).LoopList(i_c).dW_dMach();

          }
          
       }
       
    }          
                  
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER ProlongateEdgeMachVelocity                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateMachEdgeVelocity(void) 
{
 
    int Level, j, k, i_c, i_f, edge_c, edge_f;
    double U, V, W, Fact;

    for ( Level = NumberOfMGLevels_ ; Level > 1; Level-- ) {

       for ( i_c = 1 ; i_c <= VSPGeom().Grid(Level).NumberOfLoops() ; i_c++ ) {

          // Create averaged velocity across loop, based on edge values
          
          U = V = W = 0.;
          
          for ( k = 1 ; k <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges() ; k++ ) {
             
             edge_c = VSPGeom().Grid(Level).LoopList(i_c).Edge(k);
             
             U += VSPGeom().Grid(Level).EdgeList(edge_c).dU_dMach();
             V += VSPGeom().Grid(Level).EdgeList(edge_c).dV_dMach();
             W += VSPGeom().Grid(Level).EdgeList(edge_c).dW_dMach();
     
          }
          
          U /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          V /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
          W /= VSPGeom().Grid(Level).LoopList(i_c).NumberOfEdges();
             
          for ( j = 1 ; j <= VSPGeom().Grid(Level).LoopList(i_c).NumberOfFineGridLoops() ; j++ ) {
             
             i_f = VSPGeom().Grid(Level).LoopList(i_c).FineGridLoop(j);
             
             for ( k = 1 ; k <= VSPGeom().Grid(Level-1).LoopList(i_f).NumberOfEdges() ; k++ ) {
                
                edge_f = VSPGeom().Grid(Level-1).LoopList(i_f).Edge(k);
                
                edge_c = VSPGeom().Grid(Level-1).EdgeList(edge_f).CoarseGridEdge();

                Fact = 0.5;
                
                if ( VSPGeom().Grid(Level-1).EdgeList(edge_f).LoopL() == 0 ||
                     VSPGeom().Grid(Level-1).EdgeList(edge_f).LoopR() == 0 ) Fact = 1.;
                                        
                // Edge does not exist on coarse grid
                
                if ( edge_c == 0 ) {

                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dMach() += Fact*U;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dMach() += Fact*V;
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dMach() += Fact*W;
                   
                }
                
                else {
    
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dU_dMach() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dU_dMach();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dV_dMach() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dV_dMach();
                   VSPGeom().Grid(Level-1).EdgeList(edge_f).dW_dMach() += Fact*VSPGeom().Grid(Level).EdgeList(edge_c).dW_dMach();
                   
                }   
                
             }

          }
          
       }
       
    }          
                  
}

/*##############################################################################
#                                                                              #
#            VSP_SOLVER TestCalculateLoopNormalGradients_wrt_Mesh              #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestCalculateLoopNormalGradients_wrt_Mesh(int Level, int Loop)
{

    int i, Node;
    double dx, dy, dz, Normal[3], dNormal[3], Area, dArea, Error, ErrorA;   
    double *NormalGradients, *AreaGradients;
 
    NormalGradients = new double[9*VSPGeom().Grid(Level).LoopList(Loop).NumberOfNodes() + 1];
    
    AreaGradients = new double[3*VSPGeom().Grid(Level).LoopList(Loop).NumberOfNodes() + 1];
 
    CalculateLoopNormalGradients_wrt_Mesh(Level,Loop,NormalGradients,AreaGradients);
                                       
    // Finite difference test
    
    Normal[0] = VSPGeom().Grid(Level).LoopList(Loop).Nx();
    Normal[1] = VSPGeom().Grid(Level).LoopList(Loop).Ny();
    Normal[2] = VSPGeom().Grid(Level).LoopList(Loop).Nz();
    
    Area = VSPGeom().Grid(Level).LoopList(Loop).Area();

        //     NormalGradients[9*j - 8] += dNx_dx1/Nmag - Normal[0]*(Normal[0]*dNx_dx1 + Normal[1]*dNy_dx1 + Normal[2]*dNz_dx1)/(Nmag*Nmag*Nmag);
        //     NormalGradients[9*j - 7] += dNx_dy1/Nmag - Normal[0]*(Normal[0]*dNx_dy1 + Normal[1]*dNy_dy1 + Normal[2]*dNz_dy1)/(Nmag*Nmag*Nmag);
        //     NormalGradients[9*j - 6] += dNx_dz1/Nmag - Normal[0]*(Normal[0]*dNx_dz1 + Normal[1]*dNy_dz1 + Normal[2]*dNz_dz1)/(Nmag*Nmag*Nmag);
        //                                                                                                       
        //     NormalGradients[9*j - 5] += dNy_dx1/Nmag - Normal[1]*(Normal[0]*dNx_dx1 + Normal[1]*dNy_dx1 + Normal[2]*dNz_dx1)/(Nmag*Nmag*Nmag);
        //     NormalGradients[9*j - 4] += dNy_dy1/Nmag - Normal[1]*(Normal[0]*dNx_dy1 + Normal[1]*dNy_dy1 + Normal[2]*dNz_dy1)/(Nmag*Nmag*Nmag);
        //     NormalGradients[9*j - 3] += dNy_dz1/Nmag - Normal[1]*(Normal[0]*dNx_dz1 + Normal[1]*dNy_dz1 + Normal[2]*dNz_dz1)/(Nmag*Nmag*Nmag);
        //                                                                                                         
        //     NormalGradients[9*j - 2] += dNz_dx1/Nmag - Normal[2]*(Normal[0]*dNx_dx1 + Normal[1]*dNy_dx1 + Normal[2]*dNz_dx1)/(Nmag*Nmag*Nmag);
        //     NormalGradients[9*j - 1] += dNz_dy1/Nmag - Normal[2]*(Normal[0]*dNx_dy1 + Normal[1]*dNy_dy1 + Normal[2]*dNz_dy1)/(Nmag*Nmag*Nmag);
        //     NormalGradients[9*j - 0] += dNz_dz1/Nmag - Normal[2]*(Normal[0]*dNx_dz1 + Normal[1]*dNy_dz1 + Normal[2]*dNz_dz1)/(Nmag*Nmag*Nmag);
                                                               
                                                               
    dx = dy = dz = 1.e-8;

    for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfNodes() ; i++ ) {
       
       Node = VSPGeom().Grid(Level).LoopList(Loop).Node(i);

       // x
          
       VSPGeom().Grid(0).NodeList(Node).x() += dx;
       VSPGeom().Grid(0).NodeList(Node).y();
       VSPGeom().Grid(0).NodeList(Node).z();
       
       VSPGeom().UpdateMeshes();
   
       VSPGeom().Grid(0).NodeList(Node).x() -= dx;
       VSPGeom().Grid(0).NodeList(Node).y();
       VSPGeom().Grid(0).NodeList(Node).z();

       dNormal[0] = ( VSPGeom().Grid(Level).LoopList(Loop).Nx() - Normal[0] )/dx;
       dNormal[1] = ( VSPGeom().Grid(Level).LoopList(Loop).Ny() - Normal[1] )/dx;
       dNormal[2] = ( VSPGeom().Grid(Level).LoopList(Loop).Nz() - Normal[2] )/dx;   
       
       Error = pow(dNormal[0] - NormalGradients[9*i-8],2.)
             + pow(dNormal[1] - NormalGradients[9*i-5],2.)
             + pow(dNormal[2] - NormalGradients[9*i-2],2.);
       
       Error = sqrt(Error);
       
       if ( Error > 0.1 ) printf("wtf ! \n");
             
       printf("dN_dx(%d) --> Exact: %e %e %e .... FD: %e %e %e ---> Error: %f \n",
       i,
       NormalGradients[9*i-8], 
       NormalGradients[9*i-5],
       NormalGradients[9*i-2],
       dNormal[0],
       dNormal[1],
       dNormal[2], 
       Error);

       dArea = ( VSPGeom().Grid(Level).LoopList(Loop).Area() - Area)/dx;

       Error = ABS(dArea-AreaGradients[3*i-2]);
       
       printf("dA_dx(%d) --> Exact: %e.... FD: %e ---> Error: %f \n",
       i,
       AreaGradients[3*i-2], 
       dArea, 
       Error);       
       
       // y
          
       VSPGeom().Grid(0).NodeList(Node).x();
       VSPGeom().Grid(0).NodeList(Node).y() += dy;
       VSPGeom().Grid(0).NodeList(Node).z();
       
       VSPGeom().UpdateMeshes();
   
       VSPGeom().Grid(0).NodeList(Node).x();
       VSPGeom().Grid(0).NodeList(Node).y() -= dy;
       VSPGeom().Grid(0).NodeList(Node).z();
             
       dNormal[0] = ( VSPGeom().Grid(Level).LoopList(Loop).Nx() - Normal[0] )/dy;
       dNormal[1] = ( VSPGeom().Grid(Level).LoopList(Loop).Ny() - Normal[1] )/dy;
       dNormal[2] = ( VSPGeom().Grid(Level).LoopList(Loop).Nz() - Normal[2] )/dy;   
       
       Error = pow(dNormal[0] - NormalGradients[9*i-7],2.)
             + pow(dNormal[1] - NormalGradients[9*i-4],2.)
             + pow(dNormal[2] - NormalGradients[9*i-1],2.);

       Error = sqrt(Error);
             
       if ( Error > 0.1 ) printf("wtf ! \n");
             
       printf("dN_dy(%d) --> Exact: %e %e %e .... FD: %e %e %e ---> Error: %f \n",
       i,
       NormalGradients[9*i-7], 
       NormalGradients[9*i-4],
       NormalGradients[9*i-1],
       dNormal[0],
       dNormal[1],
       dNormal[2], 
       Error);
       
       dArea = ( VSPGeom().Grid(Level).LoopList(Loop).Area() - Area)/dy;

       Error = ABS(dArea-AreaGradients[3*i-1]);

       if ( Error > 0.1 ) printf("wtf ! \n");
       
       printf("dA_dy(%d) --> Exact: %e.... FD: %e ---> Error: %f \n",
       i,
       AreaGradients[3*i-1], 
       dArea, 
       Error);      
                     
       // z
          
       VSPGeom().Grid(0).NodeList(Node).x();
       VSPGeom().Grid(0).NodeList(Node).y();
       VSPGeom().Grid(0).NodeList(Node).z() += dz;
                      
       VSPGeom().UpdateMeshes();
   
       VSPGeom().Grid(0).NodeList(Node).x();
       VSPGeom().Grid(0).NodeList(Node).y();
       VSPGeom().Grid(0).NodeList(Node).z() -= dz;
             
       dNormal[0] = ( VSPGeom().Grid(Level).LoopList(Loop).Nx() - Normal[0] )/dz;
       dNormal[1] = ( VSPGeom().Grid(Level).LoopList(Loop).Ny() - Normal[1] )/dz;
       dNormal[2] = ( VSPGeom().Grid(Level).LoopList(Loop).Nz() - Normal[2] )/dz;   

       Error = pow(dNormal[0] - NormalGradients[9*i-6],2.)
             + pow(dNormal[1] - NormalGradients[9*i-3],2.)
             + pow(dNormal[2] - NormalGradients[9*i-0],2.);

       Error = sqrt(Error);

       if ( Error > 0.1 ) printf("wtf ! \n");
             
       printf("dN_dz(%d) --> Exact: %e %e %e .... FD: %e %e %e ---> Error: %f \n",
       i,
       NormalGradients[9*i-6], 
       NormalGradients[9*i-3],
       NormalGradients[9*i-0],
       dNormal[0],
       dNormal[1],
       dNormal[2], 
       Error);

       dArea = ( VSPGeom().Grid(Level).LoopList(Loop).Area() - Area)/dx;

       Error = ABS(dArea-AreaGradients[3*i-0]);
       
       if ( Error > 0.1 ) printf("wtf ! \n");
       
       printf("dA_dz(%d) --> Exact: %e.... FD: %e ---> Error: %f \n",
       i,
       AreaGradients[3*i-0], 
       dArea, 
       Error);      
                 
    }

    VSPGeom().UpdateMeshes();
 
    delete [] NormalGradients;
    delete [] AreaGradients;
        
}

/*##############################################################################
#                                                                              #
#            VSP_SOLVER CalculateTriNormalGradients_wrt_Mesh                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateTriNormalGradients_wrt_Mesh(int Loop,
                                                      double &dNx_dx1,
                                                      double &dNx_dy1,
                                                      double &dNx_dz1, 
                                                                       
                                                      double &dNy_dx1,
                                                      double &dNy_dy1,
                                                      double &dNy_dz1, 
                                                                     
                                                      double &dNz_dx1,
                                                      double &dNz_dy1,
                                                      double &dNz_dz1,
                                                                       
                                                      double &dNx_dx2,
                                                      double &dNx_dy2,
                                                      double &dNx_dz2, 
                                                                         
                                                      double &dNy_dx2,
                                                      double &dNy_dy2,
                                                      double &dNy_dz2, 
                                                                        
                                                      double &dNz_dx2,
                                                      double &dNz_dy2,
                                                      double &dNz_dz2,     
                                                                          
                                                      double &dNx_dx3,
                                                      double &dNx_dy3,
                                                      double &dNx_dz3, 
                                                                       
                                                      double &dNy_dx3,
                                                      double &dNy_dy3,
                                                      double &dNy_dz3, 
                                                                    
                                                      double &dNz_dx3,
                                                      double &dNz_dy3,
                                                      double &dNz_dz3,

                                                      double &dNx_Normalized_dx1,
                                                      double &dNx_Normalized_dy1,
                                                      double &dNx_Normalized_dz1, 
                                                                         
                                                      double &dNy_Normalized_dx1,
                                                      double &dNy_Normalized_dy1,
                                                      double &dNy_Normalized_dz1, 
                                                                         
                                                      double &dNz_Normalized_dx1,
                                                      double &dNz_Normalized_dy1,
                                                      double &dNz_Normalized_dz1,
                                                                         
                                                      double &dNx_Normalized_dx2,
                                                      double &dNx_Normalized_dy2,
                                                      double &dNx_Normalized_dz2, 
                                                                         
                                                      double &dNy_Normalized_dx2,
                                                      double &dNy_Normalized_dy2,
                                                      double &dNy_Normalized_dz2, 
                                                                         
                                                      double &dNz_Normalized_dx2,
                                                      double &dNz_Normalized_dy2,
                                                      double &dNz_Normalized_dz2,     
                                                                          
                                                      double &dNx_Normalized_dx3,
                                                      double &dNx_Normalized_dy3,
                                                      double &dNx_Normalized_dz3, 
                                                                         
                                                      double &dNy_Normalized_dx3,
                                                      double &dNy_Normalized_dy3,
                                                      double &dNy_Normalized_dz3, 
                                                                         
                                                      double &dNz_Normalized_dx3,
                                                      double &dNz_Normalized_dy3,
                                                      double &dNz_Normalized_dz3,
                                                      
                                                      double &dArea_dx1,
                                                      double &dArea_dy1,
                                                      double &dArea_dz1,            
                                                                              
                                                      double &dArea_dx2,
                                                      double &dArea_dy2,
                                                      double &dArea_dz2,       
                                                                              
                                                      double &dArea_dx3,
                                                      double &dArea_dy3,
                                                      double &dArea_dz3)
    {

    int Node1, Node2, Node3;
    double xyz1[3], xyz2[3], xyz3[3], Vec1[3], Vec2[3], Normal[3], Mag, Area;
    
    double dVec1X_dX1;
    double dVec1X_dY1;
    double dVec1X_dZ1;
                   
    double dVec1Y_dX1;
    double dVec1Y_dY1;
    double dVec1Y_dZ1;
                   
    double dVec1Z_dX1;
    double dVec1Z_dY1;
    double dVec1Z_dZ1;
                 
    double dVec1X_dX2;
    double dVec1X_dY2;
    double dVec1X_dZ2;
                 
    double dVec1Y_dX2;
    double dVec1Y_dY2;
    double dVec1Y_dZ2;
                 
    double dVec1Z_dX2;
    double dVec1Z_dY2;
    double dVec1Z_dZ2;
    
    double dVec2X_dX1;
    double dVec2X_dY1;
    double dVec2X_dZ1;
         
    double dVec2Y_dX1;
    double dVec2Y_dY1;
    double dVec2Y_dZ1;
         
    double dVec2Z_dX1;
    double dVec2Z_dY1;
    double dVec2Z_dZ1;
        
    double dVec2X_dX3;
    double dVec2X_dY3;
    double dVec2X_dZ3;
              
    double dVec2Y_dX3;
    double dVec2Y_dY3;
    double dVec2Y_dZ3;
              
    double dVec2Z_dX3;
    double dVec2Z_dY3;
    double dVec2Z_dZ3;

    double u;
    double v;
    double w;
        
    double dNx_dVec1X;
    double dNy_dVec1X;
    double dNz_dVec1X;
     
    double dNx_dVec1Y;
    double dNy_dVec1Y;
    double dNz_dVec1Y;
        
    double dNx_dVec1Z;
    double dNy_dVec1Z;
    double dNz_dVec1Z;
    
    double dNx_dVec2X;
    double dNy_dVec2X;
    double dNz_dVec2X;
      
    double dNx_dVec2Y;
    double dNy_dVec2Y;
    double dNz_dVec2Y;
         
    double dNx_dVec2Z;
    double dNy_dVec2Z;
    double dNz_dVec2Z;

    double dMag_dVec1X; 
    double dMag_dVec1Y;
    double dMag_dVec1Z;
                              
    double dMag_dVec2X; 
    double dMag_dVec2Y;
    double dMag_dVec2Z;       

    double dArea_dVec1X; 
    double dArea_dVec1Y;
    double dArea_dVec1Z;
                    
    double dArea_dVec2X; 
    double dArea_dVec2Y;
    double dArea_dVec2Z;       
               
    // Tri nodes

    Node1 = VSPGeom().Grid(0).LoopList(Loop).Node1();
    Node2 = VSPGeom().Grid(0).LoopList(Loop).Node2();
    Node3 = VSPGeom().Grid(0).LoopList(Loop).Node3();
    
    // Edge vectors
    
    xyz1[0] = VSPGeom().Grid(0).NodeList(Node1).x();
    xyz1[1] = VSPGeom().Grid(0).NodeList(Node1).y();
    xyz1[2] = VSPGeom().Grid(0).NodeList(Node1).z();
                                           
    xyz2[0] = VSPGeom().Grid(0).NodeList(Node2).x();
    xyz2[1] = VSPGeom().Grid(0).NodeList(Node2).y();
    xyz2[2] = VSPGeom().Grid(0).NodeList(Node2).z();
                                           
    xyz3[0] = VSPGeom().Grid(0).NodeList(Node3).x();
    xyz3[1] = VSPGeom().Grid(0).NodeList(Node3).y();
    xyz3[2] = VSPGeom().Grid(0).NodeList(Node3).z();

    // Edge vector gradients wrt dx, dy, dz...
            
    Vec1[0] = xyz2[0] - xyz1[0];
    Vec1[1] = xyz2[1] - xyz1[1];
    Vec1[2] = xyz2[2] - xyz1[2];
 
    Vec2[0] = xyz3[0] - xyz1[0];
    Vec2[1] = xyz3[1] - xyz1[1];
    Vec2[2] = xyz3[2] - xyz1[2];
   
    // Vec 1
    
    dVec1X_dX1 = -1.;
    dVec1X_dY1 =  0.;
    dVec1X_dZ1 =  0.;

    dVec1Y_dX1 =  0.;
    dVec1Y_dY1 = -1.;
    dVec1Y_dZ1 =  0.;
    
    dVec1Z_dX1 =  0.;
    dVec1Z_dY1 =  0.;
    dVec1Z_dZ1 = -1.;

    dVec1X_dX2 =  1.;
    dVec1X_dY2 =  0.;
    dVec1X_dZ2 =  0.;
            
    dVec1Y_dX2 =  0.;
    dVec1Y_dY2 =  1.;
    dVec1Y_dZ2 =  0.;
             
    dVec1Z_dX2 =  0.;
    dVec1Z_dY2 =  0.;
    dVec1Z_dZ2 =  1.;
            
    // Vec 2
    
    dVec2X_dX1 = -1.;
    dVec2X_dY1 =  0.;
    dVec2X_dZ1 =  0.;
        
    dVec2Y_dX1 =  0.;
    dVec2Y_dY1 = -1.;
    dVec2Y_dZ1 =  0.;
        
    dVec2Z_dX1 =  0.;
    dVec2Z_dY1 =  0.;
    dVec2Z_dZ1 = -1.;
       
    dVec2X_dX3 =  1.;
    dVec2X_dY3 =  0.;
    dVec2X_dZ3 =  0.;
             
    dVec2Y_dX3 =  0.;
    dVec2Y_dY3 =  1.;
    dVec2Y_dZ3 =  0.;
             
    dVec2Z_dX3 =  0.;
    dVec2Z_dY3 =  0.;
    dVec2Z_dZ3 =  1.;
              
    // Normal
    
    vector_cross(Vec1,Vec2,Normal);
    
    u = Normal[0];
    v = Normal[1];
    w = Normal[2];

    //  vector_cross(Vec1, Vec2, Forces_);
    //
    //  Normal[0] =  ( Vec2[2] * Vec1[1] - Vec2[1] * Vec1[2] );
    //  Normal[1] = -( Vec2[2] * Vec1[0] - Vec2[0] * Vec1[2] );
    //  Normal[2] =  ( Vec2[1] * Vec1[0] - Vec2[0] * Vec1[1] );     
       
    // Gradients of the normals wrt vec1
                
    dNx_dVec1X =       0.;
    dNy_dVec1X = -Vec2[2];
    dNz_dVec1X =  Vec2[1];
    
    dNx_dVec1Y =  Vec2[2];
    dNy_dVec1Y =       0.;
    dNz_dVec1Y = -Vec2[0];
       
    dNx_dVec1Z = -Vec2[1];
    dNy_dVec1Z =  Vec2[0];
    dNz_dVec1Z =       0.;
    
    // Gradients of the normals wrt vec2
                
    dNx_dVec2X =       0.;
    dNy_dVec2X =  Vec1[2];
    dNz_dVec2X = -Vec1[1];
     
    dNx_dVec2Y = -Vec1[2];
    dNy_dVec2Y =       0.;
    dNz_dVec2Y =  Vec1[0];
        
    dNx_dVec2Z =  Vec1[1];
    dNy_dVec2Z = -Vec1[0];
    dNz_dVec2Z =       0.;
    
    // Gradients of normal wrt node 1 
    
    // Node 1
    
    dNx_dx1 = dNx_dVec1X * dVec1X_dX1 + dNx_dVec2X * dVec2X_dX1;
    dNx_dy1 = dNx_dVec1Y * dVec1Y_dY1 + dNx_dVec2Y * dVec2Y_dY1;
    dNx_dz1 = dNx_dVec1Z * dVec1Z_dZ1 + dNx_dVec2Z * dVec2Z_dZ1; 
       
    dNy_dx1 = dNy_dVec1X * dVec1X_dX1 + dNy_dVec2X * dVec2X_dX1;
    dNy_dy1 = dNy_dVec1Y * dVec1Y_dY1 + dNy_dVec2Y * dVec2Y_dY1;
    dNy_dz1 = dNy_dVec1Z * dVec1Z_dZ1 + dNy_dVec2Z * dVec2Z_dZ1; 
       
    dNz_dx1 = dNz_dVec1X * dVec1X_dX1 + dNz_dVec2X * dVec2X_dX1;
    dNz_dy1 = dNz_dVec1Y * dVec1Y_dY1 + dNz_dVec2Y * dVec2Y_dY1;
    dNz_dz1 = dNz_dVec1Z * dVec1Z_dZ1 + dNz_dVec2Z * dVec2Z_dZ1; 
    
    // Node 2
    
    dNx_dx2 = dNx_dVec1X * dVec1X_dX2;
    dNx_dy2 = dNx_dVec1Y * dVec1Y_dY2;
    dNx_dz2 = dNx_dVec1Z * dVec1Z_dZ2; 
        
    dNy_dx2 = dNy_dVec1X * dVec1X_dX2;
    dNy_dy2 = dNy_dVec1Y * dVec1Y_dY2;
    dNy_dz2 = dNy_dVec1Z * dVec1Z_dZ2; 
       
    dNz_dx2 = dNz_dVec1X * dVec1X_dX2;
    dNz_dy2 = dNz_dVec1Y * dVec1Y_dY2;
    dNz_dz2 = dNz_dVec1Z * dVec1Z_dZ2;  
    
    // Node 3
    
    dNx_dx3 = dNx_dVec2X * dVec2X_dX3;
    dNx_dy3 = dNx_dVec2Y * dVec2Y_dY3;
    dNx_dz3 = dNx_dVec2Z * dVec2Z_dZ3; 
         
    dNy_dx3 = dNy_dVec2X * dVec2X_dX3;
    dNy_dy3 = dNy_dVec2Y * dVec2Y_dY3;
    dNy_dz3 = dNy_dVec2Z * dVec2Z_dZ3; 
          
    dNz_dx3 = dNz_dVec2X * dVec2X_dX3;
    dNz_dy3 = dNz_dVec2Y * dVec2Y_dY3;
    dNz_dz3 = dNz_dVec2Z * dVec2Z_dZ3;       
    
    // Magnitude
    
    Mag = sqrt(vector_dot(Normal,Normal));    

    dMag_dVec1X = (Normal[0]*dNx_dVec1X + Normal[1]*dNy_dVec1X + Normal[2]*dNz_dVec1X)/Mag; 
    dMag_dVec1Y = (Normal[0]*dNx_dVec1Y + Normal[1]*dNy_dVec1Y + Normal[2]*dNz_dVec1Y)/Mag;
    dMag_dVec1Z = (Normal[0]*dNx_dVec1Z + Normal[1]*dNy_dVec1Z + Normal[2]*dNz_dVec1Z)/Mag;
                                                                                
    dMag_dVec2X = (Normal[0]*dNx_dVec2X + Normal[1]*dNy_dVec2X + Normal[2]*dNz_dVec2X)/Mag; 
    dMag_dVec2Y = (Normal[0]*dNx_dVec2Y + Normal[1]*dNy_dVec2Y + Normal[2]*dNz_dVec2Y)/Mag;
    dMag_dVec2Z = (Normal[0]*dNx_dVec2Z + Normal[1]*dNy_dVec2Z + Normal[2]*dNz_dVec2Z)/Mag;       
    
    Normal[0] /= Mag; 
    Normal[1] /= Mag; 
    Normal[2] /= Mag; 

    // Gradients of normalized normal wrt vectors v1 and v2

    dNx_dVec1X = dNx_dVec1X/Mag - u * dMag_dVec1X / (Mag*Mag);
    dNx_dVec1Y = dNx_dVec1Y/Mag - u * dMag_dVec1Y / (Mag*Mag); 
    dNx_dVec1Z = dNx_dVec1Z/Mag - u * dMag_dVec1Z / (Mag*Mag); 

    dNy_dVec1X = dNy_dVec1X/Mag - v * dMag_dVec1X / (Mag*Mag);
    dNy_dVec1Y = dNy_dVec1Y/Mag - v * dMag_dVec1Y / (Mag*Mag); 
    dNy_dVec1Z = dNy_dVec1Z/Mag - v * dMag_dVec1Z / (Mag*Mag); 

    dNz_dVec1X = dNz_dVec1X/Mag - w * dMag_dVec1X / (Mag*Mag);
    dNz_dVec1Y = dNz_dVec1Y/Mag - w * dMag_dVec1Y / (Mag*Mag); 
    dNz_dVec1Z = dNz_dVec1Z/Mag - w * dMag_dVec1Z / (Mag*Mag); 
                                       
    dNx_dVec2X = dNx_dVec2X/Mag - u * dMag_dVec2X / (Mag*Mag);
    dNx_dVec2Y = dNx_dVec2Y/Mag - u * dMag_dVec2Y / (Mag*Mag); 
    dNx_dVec2Z = dNx_dVec2Z/Mag - u * dMag_dVec2Z / (Mag*Mag); 
                                               
    dNy_dVec2X = dNy_dVec2X/Mag - v * dMag_dVec2X / (Mag*Mag);
    dNy_dVec2Y = dNy_dVec2Y/Mag - v * dMag_dVec2Y / (Mag*Mag); 
    dNy_dVec2Z = dNy_dVec2Z/Mag - v * dMag_dVec2Z / (Mag*Mag); 
                                               
    dNz_dVec2X = dNz_dVec2X/Mag - w * dMag_dVec2X / (Mag*Mag);
    dNz_dVec2Y = dNz_dVec2Y/Mag - w * dMag_dVec2Y / (Mag*Mag); 
    dNz_dVec2Z = dNz_dVec2Z/Mag - w * dMag_dVec2Z / (Mag*Mag); 
    
    // Finally, gradients of the normal vector wrt xyz at nodes 1, 2, and 3...
    
    // Node 1
    
    dNx_Normalized_dx1 = dNx_dVec1X * dVec1X_dX1 + dNx_dVec2X * dVec2X_dX1;
    dNx_Normalized_dy1 = dNx_dVec1Y * dVec1Y_dY1 + dNx_dVec2Y * dVec2Y_dY1;
    dNx_Normalized_dz1 = dNx_dVec1Z * dVec1Z_dZ1 + dNx_dVec2Z * dVec2Z_dZ1; 
       
    dNy_Normalized_dx1 = dNy_dVec1X * dVec1X_dX1 + dNy_dVec2X * dVec2X_dX1;
    dNy_Normalized_dy1 = dNy_dVec1Y * dVec1Y_dY1 + dNy_dVec2Y * dVec2Y_dY1;
    dNy_Normalized_dz1 = dNy_dVec1Z * dVec1Z_dZ1 + dNy_dVec2Z * dVec2Z_dZ1; 
       
    dNz_Normalized_dx1 = dNz_dVec1X * dVec1X_dX1 + dNz_dVec2X * dVec2X_dX1;
    dNz_Normalized_dy1 = dNz_dVec1Y * dVec1Y_dY1 + dNz_dVec2Y * dVec2Y_dY1;
    dNz_Normalized_dz1 = dNz_dVec1Z * dVec1Z_dZ1 + dNz_dVec2Z * dVec2Z_dZ1; 
    
    // Node 2
    
    dNx_Normalized_dx2 = dNx_dVec1X * dVec1X_dX2;
    dNx_Normalized_dy2 = dNx_dVec1Y * dVec1Y_dY2;
    dNx_Normalized_dz2 = dNx_dVec1Z * dVec1Z_dZ2; 
        
    dNy_Normalized_dx2 = dNy_dVec1X * dVec1X_dX2;
    dNy_Normalized_dy2 = dNy_dVec1Y * dVec1Y_dY2;
    dNy_Normalized_dz2 = dNy_dVec1Z * dVec1Z_dZ2; 
       
    dNz_Normalized_dx2 = dNz_dVec1X * dVec1X_dX2;
    dNz_Normalized_dy2 = dNz_dVec1Y * dVec1Y_dY2;
    dNz_Normalized_dz2 = dNz_dVec1Z * dVec1Z_dZ2;  
    
    // Node 3
    
    dNx_Normalized_dx3 = dNx_dVec2X * dVec2X_dX3;
    dNx_Normalized_dy3 = dNx_dVec2Y * dVec2Y_dY3;
    dNx_Normalized_dz3 = dNx_dVec2Z * dVec2Z_dZ3; 
                    
    dNy_Normalized_dx3 = dNy_dVec2X * dVec2X_dX3;
    dNy_Normalized_dy3 = dNy_dVec2Y * dVec2Y_dY3;
    dNy_Normalized_dz3 = dNy_dVec2Z * dVec2Z_dZ3; 
                     
    dNz_Normalized_dx3 = dNz_dVec2X * dVec2X_dX3;
    dNz_Normalized_dy3 = dNz_dVec2Y * dVec2Y_dY3;
    dNz_Normalized_dz3 = dNz_dVec2Z * dVec2Z_dZ3;   
    
    // Area is 1/2 magnitude

    Area = 0.5 * Mag;

    dArea_dVec1X = 0.5*dMag_dVec1X; 
    dArea_dVec1Y = 0.5*dMag_dVec1Y;
    dArea_dVec1Z = 0.5*dMag_dVec1Z;
              
    dArea_dVec2X = 0.5*dMag_dVec2X; 
    dArea_dVec2Y = 0.5*dMag_dVec2Y;
    dArea_dVec2Z = 0.5*dMag_dVec2Z;   
    
    // Node 1
    
    dArea_dx1 = dArea_dVec1X * dVec1X_dX1 + dArea_dVec2X * dVec2X_dX1;
    dArea_dy1 = dArea_dVec1Y * dVec1Y_dY1 + dArea_dVec2Y * dVec2Y_dY1;
    dArea_dz1 = dArea_dVec1Z * dVec1Z_dZ1 + dArea_dVec2Z * dVec2Z_dZ1; 

    // Node 2
    
    dArea_dx2 = dArea_dVec1X * dVec1X_dX2;
    dArea_dy2 = dArea_dVec1Y * dVec1Y_dY2;
    dArea_dz2 = dArea_dVec1Z * dVec1Z_dZ2; 

    // Node 3
    
    dArea_dx3 = dArea_dVec2X * dVec2X_dX3;
    dArea_dy3 = dArea_dVec2Y * dVec2Y_dY3;
    dArea_dz3 = dArea_dVec2Z * dVec2Z_dZ3; 
                                  
}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER TestEdgeCentroidGradients               #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestEdgeCentroidGradients(void)
{
   
   int i;
   double dx, dy, dz;
   double xyz_p[3], q1[3], q2[3], dq[3], Error;
   double dq0_dx1;
   double dq0_dy1;
   double dq0_dz1;
   double dq0_dx2;
   double dq0_dy2;
   double dq0_dz2;
                        
   double dq1_dx1;
   double dq1_dy1;
   double dq1_dz1;
   double dq1_dx2;
   double dq1_dy2;
   double dq1_dz2;
                        
   double dq2_dx1;
   double dq2_dy1;
   double dq2_dz1;
   double dq2_dx2;
   double dq2_dy2;
   double dq2_dz2;
                        
   double dq0_dxp;
   double dq0_dyp;
   double dq0_dzp;
                        
   double dq1_dxp;
   double dq1_dyp;
   double dq1_dzp;
                        
   double dq2_dxp;
   double dq2_dyp;
   double dq2_dzp;      
      
   double dq0_dMach;
   double dq1_dMach;
   double dq2_dMach;   
                                                 
   // The slow way wrt mesh   
   
   dx = dy = dz = 1.e-8;

   xyz_p[0] = VSPGeom().Grid(MGLevel_).LoopList(1).Xc();
   xyz_p[1] = VSPGeom().Grid(MGLevel_).LoopList(1).Yc();
   xyz_p[2] = VSPGeom().Grid(MGLevel_).LoopList(1).Zc();
   
   for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; i++ ) {
      
      VSPGeom().Grid(MGLevel_).EdgeList(i).InducedVelocity(xyz_p,q1);

      VSPGeom().Grid(MGLevel_).EdgeList(i).dInducedVelocity_dMesh_Transpose(xyz_p,
                                                                            dq0_dx1,
                                                                            dq0_dy1,
                                                                            dq0_dz1,
                                                                            dq0_dx2,
                                                                            dq0_dy2,
                                                                            dq0_dz2,
                                                                            
                                                                            dq1_dx1,
                                                                            dq1_dy1,
                                                                            dq1_dz1,
                                                                            dq1_dx2,
                                                                            dq1_dy2,
                                                                            dq1_dz2,
                                                                            
                                                                            dq2_dx1,
                                                                            dq2_dy1,
                                                                            dq2_dz1,
                                                                            dq2_dx2,
                                                                            dq2_dy2,
                                                                            dq2_dz2,
                                                                            
                                                                            dq0_dxp,
                                                                            dq0_dyp,
                                                                            dq0_dzp,
                                                                               
                                                                            dq1_dxp,
                                                                            dq1_dyp,
                                                                            dq1_dzp,
                                                                                 
                                                                            dq2_dxp,
                                                                            dq2_dyp,
                                                                            dq2_dzp,
                                                                            
                                                                            dq0_dMach,
                                                                            dq1_dMach,
                                                                            dq2_dMach);                                                                                      

      // X
      
      xyz_p[0] += dx;
            
      VSPGeom().Grid(MGLevel_).EdgeList(i).InducedVelocity(xyz_p,q2);

      dq[0] = (q2[0] - q1[0])/dx;
      dq[1] = (q2[1] - q1[1])/dx;
      dq[2] = (q2[2] - q1[2])/dx;

      xyz_p[0] -= dx;

      Error = sqrt(pow(dq[0]-dq0_dxp,2.) +  pow(dq[1]-dq1_dxp,2.) +  pow(dq[2]-dq2_dxp,2.));
      
      printf("X exact: %e %e %e ... FD: %e %e %e ---> Error: %f \n",
      dq[0],
      dq[1],
      dq[2],
      dq0_dxp,
      dq1_dxp,
      dq2_dxp,
      Error);
         
      // Y
      
      xyz_p[1] += dy;
                  
      VSPGeom().Grid(MGLevel_).EdgeList(i).InducedVelocity(xyz_p,q2);

      dq[0] = (q2[0] - q1[0])/dy;
      dq[1] = (q2[1] - q1[1])/dy;
      dq[2] = (q2[2] - q1[2])/dy;

      xyz_p[1] -= dy;

      Error = sqrt(pow(dq[0]-dq0_dyp,2.) +  pow(dq[1]-dq1_dyp,2.) +  pow(dq[2]-dq2_dyp,2.));
      
      printf("Y exact: %e %e %e ... FD: %e %e %e ---> Error: %f \n",
      dq[0],
      dq[1],
      dq[2],
      dq0_dyp,
      dq1_dyp,
      dq2_dyp,
      Error);
      
      // Z
      
      xyz_p[2] += dz;
                  
      VSPGeom().Grid(MGLevel_).EdgeList(i).InducedVelocity(xyz_p,q2);

      dq[0] = (q2[0] - q1[0])/dz;
      dq[1] = (q2[1] - q1[1])/dz;
      dq[2] = (q2[2] - q1[2])/dz;

      xyz_p[2] -= dz;

      Error = sqrt(pow(dq[0]-dq0_dzp,2.) +  pow(dq[1]-dq1_dzp,2.) +  pow(dq[2]-dq2_dzp,2.));
      
      printf("Z exact: %e %e %e ... FD: %e %e %e ---> Error: %f \n",
      dq[0],
      dq[1],
      dq[2],
      dq0_dzp,
      dq1_dzp,
      dq2_dzp,
      Error);
                                  
   }

}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER TestForceGradients                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestForceGradients(void)
{
   
    int i, j, k, Edge;
    double ForceIm[3], ForceVm[3];
    double ForceIp[3], ForceVp[3];
    double dForceI[3][3], dForceV[3][3];
    
    double MomentIm[3], MomentVm[3];
    double MomentIp[3], MomentVp[3];
    double dMomentI[3][3], dMomentV[3][3];
        
    double dx, dy, dz, dGamma, dStall, dRatio, GammaSave;
    double GammaErrorI[6], MeshErrorI[6][3], StallErrorI[6], RatioErrorI[6]; 
    double GammaErrorV[6], MeshErrorV[6][3], StallErrorV[6], RatioErrorV[6], Fact;

    // The fast way
 
    CreateAdjointCoarseEdgeList();

    CalculateVelocities(ALL_WAKE_GAMMAS);
    
    CalculateForces();
           
    CalculateForceGradients();

    // The slow way wrt Gamma
 
    Fact = 1.;
    
    if ( DoSymmetryPlaneSolve_ ) Fact = 2.;
    
    if ( 1 ) {
      
       GammaErrorI[0] = GammaErrorI[1] = GammaErrorI[2] = 0.;
       GammaErrorV[0] = GammaErrorV[1] = GammaErrorV[2] = 0.;

       GammaErrorI[3] = GammaErrorI[4] = GammaErrorI[5] = 0.;
       GammaErrorV[3] = GammaErrorV[4] = GammaErrorV[5] = 0.;

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
    
          dGamma = 0.01*Gamma(i);
       
          GammaSave = Gamma(i);
          
          if ( ABS(dGamma) <= 1.e-8 ) dGamma = 1.e-8;

          Gamma(i) = GammaSave + dGamma;
                
          CalculateVelocities(ALL_WAKE_GAMMAS);
          
          CalculateForces();
          
          ForceIp[0] = CFix()*0.5*Sref_*Vref_*Vref_;
          ForceIp[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
          ForceIp[2] = CFiz()*0.5*Sref_*Vref_*Vref_;

          ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          Gamma(i) = GammaSave - dGamma;
                
          CalculateVelocities(ALL_WAKE_GAMMAS);
          
          CalculateForces();
                       
          ForceIm[0] = CFix()*0.5*Sref_*Vref_*Vref_;
          ForceIm[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
          ForceIm[2] = CFiz()*0.5*Sref_*Vref_*Vref_;             
             
          ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                              
          dForceI[0][0] = (ForceIp[0] - ForceIm[0])/(2.*dGamma);
          dForceI[0][1] = (ForceIp[1] - ForceIm[1])/(2.*dGamma);
          dForceI[0][2] = (ForceIp[2] - ForceIm[2])/(2.*dGamma);
                                                  
          dForceV[0][0] = (ForceVp[0] - ForceVm[0])/(2.*dGamma);
          dForceV[0][1] = (ForceVp[1] - ForceVm[1])/(2.*dGamma);
          dForceV[0][2] = (ForceVp[2] - ForceVm[2])/(2.*dGamma);

          dMomentI[0][0] = (MomentIp[0] - MomentIm[0])/(2.*dGamma);
          dMomentI[0][1] = (MomentIp[1] - MomentIm[1])/(2.*dGamma);
          dMomentI[0][2] = (MomentIp[2] - MomentIm[2])/(2.*dGamma);
                         
          dMomentV[0][0] = (MomentVp[0] - MomentVm[0])/(2.*dGamma);
          dMomentV[0][1] = (MomentVp[1] - MomentVm[1])/(2.*dGamma);
          dMomentV[0][2] = (MomentVp[2] - MomentVm[2])/(2.*dGamma);
          
          Gamma(i) = GammaSave;
    
          // Compare the two methods
          
          printf("Loop: %d of %d \n",i, VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
          
          printf("Grid 0 XYZ: %f %f %f \n",
          VSPGeom().Grid(0).LoopList(i).Xc(),
          VSPGeom().Grid(0).LoopList(i).Yc(),
          VSPGeom().Grid(0).LoopList(i).Zc());
    
          printf("Inviscid Forces --> xExact: %e %e %e  ... FD: %e %e %e \n",
          
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFx_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFy_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFz_pGamma(),
    
          dForceI[0][0],
          dForceI[0][1],
          dForceI[0][2]);

          printf("Viscous Forces --> xExact: %e %e %e  ... FD: %e %e %e \n",
          
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFxo_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFyo_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFzo_pGamma(),
    
          dForceV[0][0],
          dForceV[0][1],
          dForceV[0][2]);

          printf("Inviscid Moments --> xExact: %e %e %e  ... FD: %e %e %e \n",
          
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pGamma(),
    
          dMomentI[0][0],
          dMomentI[0][1],
          dMomentI[0][2]);

          printf("Viscous Moments --> xExact: %e %e %e  ... FD: %e %e %e \n",
          
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMxo_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMyo_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMzo_pGamma(),
    
          dMomentV[0][0],
          dMomentV[0][1],
          dMomentV[0][2]);
    
          GammaErrorI[0] += pow(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFx_pGamma(),2.);
          GammaErrorI[1] += pow(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFy_pGamma(),2.);
          GammaErrorI[2] += pow(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFz_pGamma(),2.);

          GammaErrorV[0] += pow(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFxo_pGamma(),2.);
          GammaErrorV[1] += pow(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFyo_pGamma(),2.);
          GammaErrorV[2] += pow(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFzo_pGamma(),2.);

          GammaErrorI[3] += pow(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pGamma(),2.);
          GammaErrorI[4] += pow(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pGamma(),2.);
          GammaErrorI[5] += pow(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pGamma(),2.);
                                                                                           
          GammaErrorV[3] += pow(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMxo_pGamma(),2.);
          GammaErrorV[4] += pow(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMyo_pGamma(),2.);
          GammaErrorV[5] += pow(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMzo_pGamma(),2.);
               
          if ( ABS(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFx_pGamma()) > 0.1 )   printf("Force x wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFy_pGamma()) > 0.1 )   printf("Force y wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFz_pGamma()) > 0.1 )   printf("Force z wtf! ... gamma: %f \n",Gamma(i));
                                                                                                           
          if ( ABS(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFxo_pGamma()) > 0.1 )  printf("Force xo wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFyo_pGamma()) > 0.1 )  printf("Force yo wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFzo_pGamma()) > 0.1 )  printf("Force zo wtf! ... gamma: %f \n",Gamma(i));
                                                                                                     
          if ( ABS(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pGamma()) > 0.01 )  printf("Moment x wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pGamma()) > 0.01 )  printf("Moment y wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pGamma()) > 0.01 )  printf("Moment z wtf! ... gamma: %f \n",Gamma(i));
                                                                                                         
          if ( ABS(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMxo_pGamma()) > 0.01 ) printf("Moment xo wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMyo_pGamma()) > 0.01 ) printf("Moment yo wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMzo_pGamma()) > 0.01 ) printf("Moment zo wtf! ... gamma: %f \n",Gamma(i));
                                      
       }
    
       for ( j = 0 ; j <= 5 ; j++ ) {
          
          GammaErrorI[j] /= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops();
          GammaErrorV[j] /= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops();
          
          GammaErrorI[j] = sqrt(GammaErrorI[j]);
          GammaErrorV[j] = sqrt(GammaErrorV[j]);
          
          printf("Invisicid GammaError[%d]: %f \n",j, GammaErrorI[j]);
          printf("Viscous GammaErrorV[%d]: %f \n",j, GammaErrorV[j]);
          
       }
       
    }
 
    // The slow way wrt mesh   
    
    double ErrorI, ErrorV, ds;
    
    if ( 1 ) {

       dx = dy = dz = ds = 1.e-7;
       
       MeshErrorI[0][0] = MeshErrorI[0][1] = MeshErrorI[0][2] = 0.;
       MeshErrorI[1][0] = MeshErrorI[1][1] = MeshErrorI[1][2] = 0.;
       MeshErrorI[2][0] = MeshErrorI[2][1] = MeshErrorI[2][2] = 0.;

       MeshErrorV[0][0] = MeshErrorV[0][1] = MeshErrorV[0][2] = 0.;
       MeshErrorV[1][0] = MeshErrorV[1][1] = MeshErrorV[1][2] = 0.;
       MeshErrorV[2][0] = MeshErrorV[2][1] = MeshErrorV[2][2] = 0.;

       MeshErrorI[3][0] = MeshErrorI[3][1] = MeshErrorI[3][2] = 0.;
       MeshErrorI[4][0] = MeshErrorI[4][1] = MeshErrorI[4][2] = 0.;
       MeshErrorI[5][0] = MeshErrorI[5][1] = MeshErrorI[5][2] = 0.;

       MeshErrorV[3][0] = MeshErrorV[3][1] = MeshErrorV[3][2] = 0.;
       MeshErrorV[4][0] = MeshErrorV[4][1] = MeshErrorV[4][2] = 0.;
       MeshErrorV[5][0] = MeshErrorV[5][1] = MeshErrorV[5][2] = 0.;
                  
       double Temp;
                  
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
    
          // X

          Temp = VSPGeom().Grid(0).NodeList(i).x();             
          
          VSPGeom().Grid(0).NodeList(i).x() += dx;
          
          VSPGeom().UpdateMeshes();
          
          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIp[0] = CFix()*0.5*Sref_*Vref_*Vref_;
          ForceIp[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
          ForceIp[2] = CFiz()*0.5*Sref_*Vref_*Vref_;

          ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          VSPGeom().Grid(0).NodeList(i).x() = Temp - dx;
          
          VSPGeom().UpdateMeshes();          

          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
        //  CalculateVelocities(ALL_WAKE_GAMMAS);
          
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIm[0] = CFix()*0.5*Sref_*Vref_*Vref_;
          ForceIm[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
          ForceIm[2] = CFiz()*0.5*Sref_*Vref_*Vref_;
              
          ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                    
          dForceI[0][0] = (ForceIp[0] - ForceIm[0])/(2.*dx);
          dForceI[0][1] = (ForceIp[1] - ForceIm[1])/(2.*dx);
          dForceI[0][2] = (ForceIp[2] - ForceIm[2])/(2.*dx);
                                                       
          dForceV[0][0] = (ForceVp[0] - ForceVm[0])/(2.*dx);
          dForceV[0][1] = (ForceVp[1] - ForceVm[1])/(2.*dx);
          dForceV[0][2] = (ForceVp[2] - ForceVm[2])/(2.*dx);

          dMomentI[0][0] = (MomentIp[0] - MomentIm[0])/(2.*dx);
          dMomentI[0][1] = (MomentIp[1] - MomentIm[1])/(2.*dx);
          dMomentI[0][2] = (MomentIp[2] - MomentIm[2])/(2.*dx);
                         
          dMomentV[0][0] = (MomentVp[0] - MomentVm[0])/(2.*dx);
          dMomentV[0][1] = (MomentVp[1] - MomentVm[1])/(2.*dx);
          dMomentV[0][2] = (MomentVp[2] - MomentVm[2])/(2.*dx);
                              
          VSPGeom().Grid(0).NodeList(i).x() = Temp;
          
          VSPGeom().UpdateMeshes();          
          
          // Y

          Temp = VSPGeom().Grid(0).NodeList(i).y();             

          VSPGeom().Grid(0).NodeList(i).y() = Temp + dy;
          
          VSPGeom().UpdateMeshes();
          
          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIp[0] = CFix()*0.5*Sref_*Vref_*Vref_;
          ForceIp[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
          ForceIp[2] = CFiz()*0.5*Sref_*Vref_*Vref_;

          ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          VSPGeom().Grid(0).NodeList(i).y() = Temp - dy;

          VSPGeom().UpdateMeshes();          

          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);     
          
          CalculateEdgeVelocities();  
          
          CalculateForces();
          
          ForceIm[0] = CFix()*0.5*Sref_*Vref_*Vref_;
          ForceIm[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
          ForceIm[2] = CFiz()*0.5*Sref_*Vref_*Vref_;
              
          ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                    
          dForceI[1][0] = (ForceIp[0] - ForceIm[0])/(2.*dy);
          dForceI[1][1] = (ForceIp[1] - ForceIm[1])/(2.*dy);
          dForceI[1][2] = (ForceIp[2] - ForceIm[2])/(2.*dy);
                                                      
          dForceV[1][0] = (ForceVp[0] - ForceVm[0])/(2.*dy);
          dForceV[1][1] = (ForceVp[1] - ForceVm[1])/(2.*dy);
          dForceV[1][2] = (ForceVp[2] - ForceVm[2])/(2.*dy);
          
          dMomentI[1][0] = (MomentIp[0] - MomentIm[0])/(2.*dy);
          dMomentI[1][1] = (MomentIp[1] - MomentIm[1])/(2.*dy);
          dMomentI[1][2] = (MomentIp[2] - MomentIm[2])/(2.*dy);
                     
          dMomentV[1][0] = (MomentVp[0] - MomentVm[0])/(2.*dy);
          dMomentV[1][1] = (MomentVp[1] - MomentVm[1])/(2.*dy);
          dMomentV[1][2] = (MomentVp[2] - MomentVm[2])/(2.*dy);   
                          
          VSPGeom().Grid(0).NodeList(i).y() = Temp ;
           
          VSPGeom().UpdateMeshes();          
             
          // Z
    
          Temp = VSPGeom().Grid(0).NodeList(i).z();    
         
          VSPGeom().Grid(0).NodeList(i).z() = Temp + dz;
          
          VSPGeom().UpdateMeshes();
          
          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);          
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIp[0] = CFix()*0.5*Sref_*Vref_*Vref_;
          ForceIp[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
          ForceIp[2] = CFiz()*0.5*Sref_*Vref_*Vref_;

          ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          VSPGeom().Grid(0).NodeList(i).z() = Temp - dz;

          VSPGeom().UpdateMeshes();          
          
          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);       
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIm[0] = CFix()*0.5*Sref_*Vref_*Vref_;
          ForceIm[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
          ForceIm[2] = CFiz()*0.5*Sref_*Vref_*Vref_;
              
          ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                    
          dForceI[2][0] = (ForceIp[0] - ForceIm[0])/(2.*dz);
          dForceI[2][1] = (ForceIp[1] - ForceIm[1])/(2.*dz);
          dForceI[2][2] = (ForceIp[2] - ForceIm[2])/(2.*dz);
                                                 
          dForceV[2][0] = (ForceVp[0] - ForceVm[0])/(2.*dz);
          dForceV[2][1] = (ForceVp[1] - ForceVm[1])/(2.*dz);
          dForceV[2][2] = (ForceVp[2] - ForceVm[2])/(2.*dz);

          dMomentI[2][0] = (MomentIp[0] - MomentIm[0])/(2.*dz);
          dMomentI[2][1] = (MomentIp[1] - MomentIm[1])/(2.*dz);
          dMomentI[2][2] = (MomentIp[2] - MomentIm[2])/(2.*dz);
                  
          dMomentV[2][0] = (MomentVp[0] - MomentVm[0])/(2.*dz);
          dMomentV[2][1] = (MomentVp[1] - MomentVm[1])/(2.*dz);
          dMomentV[2][2] = (MomentVp[2] - MomentVm[2])/(2.*dz);   
                              
          VSPGeom().Grid(0).NodeList(i).z() = Temp;
          
          VSPGeom().UpdateMeshes();          
          
          // Compare the two methods
          
          printf("Node: %d of %d \n",i, VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes());
          
          if ( VSPGeom().Grid(MGLevel_).NodeList(i).IsTrailingEdgeNode() ) printf("Node is on trailing edge of wing... \n");fflush(NULL);
          
          printf("Grid 0 XYZ: %f %f %f \n",
          VSPGeom().Grid(0).NodeList(i).x(),
          VSPGeom().Grid(0).NodeList(i).y(),
          VSPGeom().Grid(0).NodeList(i).z());
    
          printf("Grid 1 XYZ: %f %f %f \n",
          VSPGeom().Grid(1).NodeList(i).x(),
          VSPGeom().Grid(1).NodeList(i).y(),
          VSPGeom().Grid(1).NodeList(i).z());
          
          printf("Inviscid Forces \n");
          printf(" Exact wrt x: %e %e %e  ... FD: %e %e %e \n Exact wrt y: %e %e %e   ... FD: %e %e %e \n Exact wrt z: %e %e %e  ... FD: %e %e %e \n \n",
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX(),
    
          dForceI[0][0],
          dForceI[0][1],
          dForceI[0][2],
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY(),
    
          dForceI[1][0],
          dForceI[1][1],
          dForceI[1][2],
    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ(),
    
          dForceI[2][0],
          dForceI[2][1],
          dForceI[2][2]);

          printf("Viscous Forces \n");
          printf(" Exact wrt x: %e %e %e  ... FD: %e %e %e \n Exact wrt y: %e %e %e   ... FD: %e %e %e \n Exact wrt z: %e %e %e  ... FD: %e %e %e \n \n",
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX(),
    
          dForceV[0][0],
          dForceV[0][1],
          dForceV[0][2],
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY(),
    
          dForceV[1][0],
          dForceV[1][1],
          dForceV[1][2],
    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ(),
    
          dForceV[2][0],
          dForceV[2][1],
          dForceV[2][2]);
          
          printf("Inviscid Moments \n");
          printf(" Exact wrt x: %e %e %e  ... FD: %e %e %e \n Exact wrt y: %e %e %e   ... FD: %e %e %e \n Exact wrt z: %e %e %e  ... FD: %e %e %e \n \n",
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX(),
                                                     
          dMomentI[0][0],                             
          dMomentI[0][1],                             
          dMomentI[0][2],                             
                                                     
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY(),
                                                    
          dMomentI[1][0],                            
          dMomentI[1][1],                            
          dMomentI[1][2],                            
                                                    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ(),
    
          dMomentI[2][0],
          dMomentI[2][1],
          dMomentI[2][2]);

          printf("Viscous Moments \n");
          printf(" Exact wrt x: %e %e %e  ... FD: %e %e %e \n Exact wrt y: %e %e %e   ... FD: %e %e %e \n Exact wrt z: %e %e %e  ... FD: %e %e %e \n \n",
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX(),
                                                    
          dMomentV[0][0],                            
          dMomentV[0][1],                            
          dMomentV[0][2],                            
                                                    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY(),
                                                    
          dMomentV[1][0],                            
          dMomentV[1][1],                            
          dMomentV[1][2],                            
                                                    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ(),
    
          dMomentV[2][0],
          dMomentV[2][1],
          dMomentV[2][2]);          
    
          MeshErrorI[0][0] += pow(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX(),2.);
          MeshErrorI[0][1] += pow(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pX(),2.);
          MeshErrorI[0][2] += pow(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX(),2.);
                                   
          MeshErrorI[1][0] += pow(dForceI[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY(),2.);
          MeshErrorI[1][1] += pow(dForceI[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pY(),2.);
          MeshErrorI[1][2] += pow(dForceI[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY(),2.);
                                   
          MeshErrorI[2][0] += pow(dForceI[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ(),2.);
          MeshErrorI[2][1] += pow(dForceI[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pZ(),2.);
          MeshErrorI[2][2] += pow(dForceI[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ(),2.);

          MeshErrorI[3][0] += pow(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX(),2.);
          MeshErrorI[3][1] += pow(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX(),2.);
          MeshErrorI[3][2] += pow(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX(),2.);
                                                                                            
          MeshErrorI[4][0] += pow(dMomentI[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY(),2.);
          MeshErrorI[4][1] += pow(dMomentI[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY(),2.);
          MeshErrorI[4][2] += pow(dMomentI[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY(),2.);
                                                                                            
          MeshErrorI[5][0] += pow(dMomentI[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ(),2.);
          MeshErrorI[5][1] += pow(dMomentI[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ(),2.);
          MeshErrorI[5][2] += pow(dMomentI[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ(),2.);
          
          ErrorI = pow(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pX(),2.)
                 + pow(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pX(),2.)
                 + pow(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pX(),2.)
                           
                 + pow(dForceI[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pY(),2.)
                 + pow(dForceI[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pY(),2.)
                 + pow(dForceI[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pY(),2.)
                            
                 + pow(dForceI[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFix_pZ(),2.)
                 + pow(dForceI[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiy_pZ(),2.)
                 + pow(dForceI[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFiz_pZ(),2.)

                 + pow(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX(),2.)
                 + pow(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX(),2.)
                 + pow(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX(),2.)
                                                                            
                 + pow(dMomentI[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY(),2.)
                 + pow(dMomentI[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY(),2.)
                 + pow(dMomentI[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY(),2.)
                                                                            
                 + pow(dMomentI[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ(),2.)
                 + pow(dMomentI[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ(),2.)
                 + pow(dMomentI[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ(),2.);
                 
          if ( sqrt(ErrorI/3.) > 0.1 ) printf("Inviscid -----------------------------------------------------------------------> wtf! \n");fflush(NULL);
          if ( sqrt(ErrorI/3.) > 1000. ) printf("Inviscid -----------------------------------------------------------------------> crap! \n");fflush(NULL);
          
          MeshErrorV[0][0] += pow(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX(),2.);
          MeshErrorV[0][1] += pow(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX(),2.);
          MeshErrorV[0][2] += pow(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX(),2.);
                  
          MeshErrorV[1][0] += pow(dForceV[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY(),2.);
          MeshErrorV[1][1] += pow(dForceV[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY(),2.);
          MeshErrorV[1][2] += pow(dForceV[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY(),2.);
                   
          MeshErrorV[2][0] += pow(dForceV[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ(),2.);
          MeshErrorV[2][1] += pow(dForceV[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ(),2.);
          MeshErrorV[2][2] += pow(dForceV[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ(),2.);

          MeshErrorV[3][0] += pow(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX(),2.);
          MeshErrorV[3][1] += pow(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX(),2.);
          MeshErrorV[3][2] += pow(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX(),2.);
                              
          MeshErrorV[4][0] += pow(dMomentV[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY(),2.);
          MeshErrorV[4][1] += pow(dMomentV[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY(),2.);
          MeshErrorV[4][2] += pow(dMomentV[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY(),2.);
                              
          MeshErrorV[5][0] += pow(dMomentV[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ(),2.);
          MeshErrorV[5][1] += pow(dMomentV[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ(),2.);
          MeshErrorV[5][2] += pow(dMomentV[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ(),2.);
          
          ErrorV = pow(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX(),2.)
                 + pow(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX(),2.)
                 + pow(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX(),2.)
                
                 + pow(dForceV[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY(),2.)
                 + pow(dForceV[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY(),2.)
                 + pow(dForceV[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY(),2.)
                
                 + pow(dForceV[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ(),2.)
                 + pow(dForceV[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ(),2.)
                 + pow(dForceV[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ(),2.)
                 
                 + pow(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX(),2.)
                 + pow(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX(),2.)
                 + pow(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX(),2.)
                     
                 + pow(dMomentV[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY(),2.)
                 + pow(dMomentV[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY(),2.)
                 + pow(dMomentV[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY(),2.)
                     
                 + pow(dMomentV[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ(),2.)
                 + pow(dMomentV[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ(),2.)
                 + pow(dMomentV[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ(),2.);
                
          if ( ErrorV > 0.1 ) printf("Viscous -----------------------------------------------------------------------> wtf! \n");fflush(NULL);
                                            
       }
       
       for ( i = 0 ; i <= 5 ; i++ ) {
          
          for ( j = 0 ; j <= 2 ; j++ ) {
             
             MeshErrorI[i][j] /= VSPGeom().Grid(MGLevel_).NumberOfNodes();
             MeshErrorV[i][j] /= VSPGeom().Grid(MGLevel_).NumberOfNodes();
             
             MeshErrorI[i][j] = sqrt(MeshErrorI[i][j]);
             MeshErrorV[i][j] = sqrt(MeshErrorV[i][j]);
             
             printf("Inviscid MeshErrorI[%d][%d]: %f \n",i,j, MeshErrorI[i][j]);
             printf("Viscous MeshErrorV[%d][%d]: %f \n",i,j, MeshErrorV[i][j]);
             
          }
          
       }

    }

    // The slow way wrt stallfactor
    
    if ( 1 ) {
       
       dStall = 1.e-6;
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
          StallErrorI[0] = StallErrorI[1] = StallErrorI[2] = 0.;
          StallErrorV[0] = StallErrorV[1] = StallErrorV[2] = 0.;
          
          StallErrorI[3] = StallErrorI[4] = StallErrorI[5] = 0.;
          StallErrorV[3] = StallErrorV[4] = StallErrorV[5] = 0.;
                 
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() -= dStall;
             
             InitializeFreeStream();
             
             CalculateEdgeVelocities();
             
             CalculateForces();
             
             ForceIp[0] = CFix()*0.5*Sref_*Vref_*Vref_;
             ForceIp[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
             ForceIp[2] = CFiz()*0.5*Sref_*Vref_*Vref_;
             
             ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
             ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
             ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

             MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
             MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
             MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                            
             MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
             MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
             MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                                 
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() -= 2.*dStall;
             
             InitializeFreeStream();
             
             CalculateEdgeVelocities();
             
             CalculateForces();
             
             ForceIm[0] = CFix()*0.5*Sref_*Vref_*Vref_;
             ForceIm[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
             ForceIm[2] = CFiz()*0.5*Sref_*Vref_*Vref_;
                 
             ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
             ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
             ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;
           
             MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
             MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
             MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                          
             MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
             MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
             MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                         
             dForceI[0][0] = (ForceIp[0] - ForceIm[0])/(2.*dStall);
             dForceI[0][1] = (ForceIp[1] - ForceIm[1])/(2.*dStall);
             dForceI[0][2] = (ForceIp[2] - ForceIm[2])/(2.*dStall);
                                                          
             dForceV[0][0] = (ForceVp[0] - ForceVm[0])/(2.*dStall);
             dForceV[0][1] = (ForceVp[1] - ForceVm[1])/(2.*dStall);
             dForceV[0][2] = (ForceVp[2] - ForceVm[2])/(2.*dStall);

             dMomentI[0][0] = (MomentIp[0] - MomentIm[0])/(2.*dStall);
             dMomentI[0][1] = (MomentIp[1] - MomentIm[1])/(2.*dStall);
             dMomentI[0][2] = (MomentIp[2] - MomentIm[2])/(2.*dStall);
                            
             dMomentV[0][0] = (MomentVp[0] - MomentVm[0])/(2.*dStall);
             dMomentV[0][1] = (MomentVp[1] - MomentVm[1])/(2.*dStall);
             dMomentV[0][2] = (MomentVp[2] - MomentVm[2])/(2.*dStall);
                            
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() += 3.*dStall;
             
             // Compare the two methods
             
             printf("VortexSheet: %d --> Stall equation: %d \n",k, i);
   
             printf("Inviscid Forces Exact: %e %e %e  ... FD: %e %e %e \n",
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFx_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFy_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFz_pStallFactor(),
       
             dForceI[0][0],
             dForceI[0][1],
             dForceI[0][2]);

             printf("Viscous Forces Exact: %e %e %e  ... FD: %e %e %e \n",
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFxo_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFyo_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFzo_pStallFactor(),
       
             dForceV[0][0],
             dForceV[0][1],
             dForceV[0][2]);

             printf("Inviscid Moments Exact: %e %e %e  ... FD: %e %e %e \n",
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor(),
       
             dMomentI[0][0],
             dMomentI[0][1],
             dMomentI[0][2]);

             printf("Viscous Moments Exact: %e %e %e  ... FD: %e %e %e \n",
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMxo_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMyo_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMzo_pStallFactor(),
       
             dMomentV[0][0],
             dMomentV[0][1],
             dMomentV[0][2]);
                                     
             StallErrorI[0] += pow(dForceI[0][0] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFx_pStallFactor(),2.);
             StallErrorI[1] += pow(dForceI[0][1] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFy_pStallFactor(),2.);
             StallErrorI[2] += pow(dForceI[0][2] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFz_pStallFactor(),2.);

             StallErrorV[0] += pow(dForceV[0][0] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFxo_pStallFactor(),2.);
             StallErrorV[1] += pow(dForceV[0][1] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFyo_pStallFactor(),2.);
             StallErrorV[2] += pow(dForceV[0][2] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFzo_pStallFactor(),2.);

             StallErrorI[3] += pow(dMomentI[0][0] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor(),2.);
             StallErrorI[4] += pow(dMomentI[0][1] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor(),2.);
             StallErrorI[5] += pow(dMomentI[0][2] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor(),2.);
                             
             StallErrorV[3] += pow(dMomentV[0][0] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMxo_pStallFactor(),2.);
             StallErrorV[4] += pow(dMomentV[0][1] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMyo_pStallFactor(),2.);
             StallErrorV[5] += pow(dMomentV[0][2] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMzo_pStallFactor(),2.);
                          
          }
         
          for ( j = 0 ; j <= 5 ; j++ ) {
             
             StallErrorI[j] /= VSPGeom().VortexSheet(k).NumberOfTrailingVortices();
             StallErrorV[j] /= VSPGeom().VortexSheet(k).NumberOfTrailingVortices();
             
             StallErrorI[j] = sqrt(StallErrorI[j]);
             StallErrorV[j] = sqrt(StallErrorV[j]);
             
             printf("Inviscid StallErrorI[%d]: %f \n",j, StallErrorI[j]);
             printf("Viscous StallErrorV[%d]: %f \n",j, StallErrorV[j]);
             
          }
   
       }
       
    }

    // The slow way wrt vortex stretching factor
    
    if ( 1 ) {
       
       int Loop;
       
       dRatio = 1.e-3;
       
       RatioErrorI[0] = RatioErrorI[1] = RatioErrorI[2] = 0.;
       RatioErrorV[0] = RatioErrorV[1] = RatioErrorV[2] = 0.;

       RatioErrorI[3] = RatioErrorI[4] = RatioErrorI[5] = 0.;
       RatioErrorV[3] = RatioErrorV[4] = RatioErrorV[5] = 0.;
    
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
     
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
   
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 &&
                  VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
                    
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() += dRatio;
      
                CalculateEdgeVelocities();
   
                CalculateForces();
                
                ForceIp[0] = CFix()*0.5*Sref_*Vref_*Vref_;
                ForceIp[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
                ForceIp[2] = CFiz()*0.5*Sref_*Vref_*Vref_;
      
                ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
                ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
                ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;
                       
                MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
                MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
                MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                             
                MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
                MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
                MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                                       
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() -= 2.*dRatio;
                      
                CalculateEdgeVelocities();
                
                CalculateForces();
                             
                ForceIm[0] = CFix()*0.5*Sref_*Vref_*Vref_;
                ForceIm[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
                ForceIm[2] = CFiz()*0.5*Sref_*Vref_*Vref_;             
                   
                ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
                ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
                ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

                MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
                MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
                MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                             
                MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
                MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
                MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                                          
                dForceI[0][0] = (ForceIp[0] - ForceIm[0])/(2.*dRatio);
                dForceI[0][1] = (ForceIp[1] - ForceIm[1])/(2.*dRatio);
                dForceI[0][2] = (ForceIp[2] - ForceIm[2])/(2.*dRatio);
                                                        
                dForceV[0][0] = (ForceVp[0] - ForceVm[0])/(2.*dRatio);
                dForceV[0][1] = (ForceVp[1] - ForceVm[1])/(2.*dRatio);
                dForceV[0][2] = (ForceVp[2] - ForceVm[2])/(2.*dRatio);

                dMomentI[0][0] = (MomentIp[0] - MomentIm[0])/(2.*dRatio);
                dMomentI[0][1] = (MomentIp[1] - MomentIm[1])/(2.*dRatio);
                dMomentI[0][2] = (MomentIp[2] - MomentIm[2])/(2.*dRatio);
                               
                dMomentV[0][0] = (MomentVp[0] - MomentVm[0])/(2.*dRatio);
                dMomentV[0][1] = (MomentVp[1] - MomentVm[1])/(2.*dRatio);
                dMomentV[0][2] = (MomentVp[2] - MomentVm[2])/(2.*dRatio);
                   
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() += dRatio;
          
                // Compare the two methods
   
                printf("Grid 0 XYZ: %f %f %f \n",
                VSPGeom().Grid(0).LoopList(Loop).Xc(),
                VSPGeom().Grid(0).LoopList(Loop).Yc(),
                VSPGeom().Grid(0).LoopList(Loop).Zc());
          
                printf("Inviscid Forces --> xExact: %e %e %e  ... FD: %e %e %e \n",
                
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFx_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFy_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFz_pRatio(),
          
                dForceI[0][0],
                dForceI[0][1],
                dForceI[0][2]);
      
                printf("Viscous Forces --> xExact: %e %e %e  ... FD: %e %e %e \n",
                
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFxo_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFyo_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFzo_pRatio(),
          
                dForceV[0][0],
                dForceV[0][1],
                dForceV[0][2]);

                printf("Inviscid Moments --> xExact: %e %e %e  ... FD: %e %e %e \n",
                
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMx_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMy_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMz_pRatio(),
          
                dMomentI[0][0],
                dMomentI[0][1],
                dMomentI[0][2]);
      
                printf("Viscous Moments --> xExact: %e %e %e  ... FD: %e %e %e \n",
                
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMxo_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMyo_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMzo_pRatio(),
          
                dMomentV[0][0],
                dMomentV[0][1],
                dMomentV[0][2]);
          
                RatioErrorI[0] += pow(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFx_pRatio(),2.);
                RatioErrorI[1] += pow(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFy_pRatio(),2.);
                RatioErrorI[2] += pow(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFz_pRatio(),2.);
                                                                                           
                RatioErrorV[0] += pow(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFxo_pRatio(),2.);
                RatioErrorV[1] += pow(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFyo_pRatio(),2.);
                RatioErrorV[2] += pow(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFzo_pRatio(),2.);

                RatioErrorI[3] += pow(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMx_pRatio(),2.);
                RatioErrorI[4] += pow(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMy_pRatio(),2.);
                RatioErrorI[5] += pow(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMz_pRatio(),2.);
                                    
                RatioErrorV[3] += pow(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMxo_pRatio(),2.);
                RatioErrorV[4] += pow(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMyo_pRatio(),2.);
                RatioErrorV[5] += pow(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMzo_pRatio(),2.);
                        
                for ( j = 0 ; j <= 5 ; j++ ) {
                   
                   RatioErrorI[j] /= (VSPGeom().Grid(MGLevel_).NumberOfLoops() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
                   RatioErrorV[j] /= (VSPGeom().Grid(MGLevel_).NumberOfLoops() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
                   
                   RatioErrorI[j] = sqrt(RatioErrorI[j]);
                   RatioErrorV[j] = sqrt(RatioErrorV[j]);
                   
                   printf("Invisicid RatioErrorI[%d]: %f \n",j, RatioErrorI[j]);
                   printf("Viscous RatioErrorV[%d]: %f \n",j, RatioErrorV[j]);
                   
                }
                
             }
      
          }
   
       }    
    
    }
    
}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER TestInducedForceGradients                         #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestInducedForceGradients(void)
{
   
    int i, j, k, Edge;
    double ForceIm[3], ForceVm[3];
    double ForceIp[3], ForceVp[3];
    double dForceI[3][3], dForceV[3][3];
    
    double MomentIm[3], MomentVm[3];
    double MomentIp[3], MomentVp[3];
    double dMomentI[3][3], dMomentV[3][3];
        
    double dx, dy, dz, dGamma, dStall, dRatio, GammaSave;
    double GammaErrorI[6], MeshErrorI[6][3], StallErrorI[6], RatioErrorI[6]; 
    double GammaErrorV[6], MeshErrorV[6][3], StallErrorV[6], RatioErrorV[6], Fact;

    // The fast way
 
    CreateAdjointCoarseEdgeList();

    CalculateVelocities(ALL_WAKE_GAMMAS);
    
    CalculateForces();
           
    CalculateForceGradients();

    // The slow way wrt Gamma
 
    Fact = 1.;
    
    if ( DoSymmetryPlaneSolve_ ) Fact = 2.;
    
    if ( 1 ) {
      
       GammaErrorI[0] = GammaErrorI[1] = GammaErrorI[2] = 0.;
       GammaErrorV[0] = GammaErrorV[1] = GammaErrorV[2] = 0.;

       GammaErrorI[3] = GammaErrorI[4] = GammaErrorI[5] = 0.;
       GammaErrorV[3] = GammaErrorV[4] = GammaErrorV[5] = 0.;

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
    
          dGamma = 0.01*Gamma(i);
       
          GammaSave = Gamma(i);
          
          if ( ABS(dGamma) <= 1.e-8 ) dGamma = 1.e-8;

          Gamma(i) = GammaSave + dGamma;
                
          CalculateVelocities(ALL_WAKE_GAMMAS);
          
          CalculateForces();
          
          ForceIp[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
          ForceIp[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
          ForceIp[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;

          ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          Gamma(i) = GammaSave - dGamma;
                
          CalculateVelocities(ALL_WAKE_GAMMAS);
          
          CalculateForces();
                       
          ForceIm[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
          ForceIm[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
          ForceIm[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;             
             
          ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                              
          dForceI[0][0] = (ForceIp[0] - ForceIm[0])/(2.*dGamma);
          dForceI[0][1] = (ForceIp[1] - ForceIm[1])/(2.*dGamma);
          dForceI[0][2] = (ForceIp[2] - ForceIm[2])/(2.*dGamma);
                                                  
          dForceV[0][0] = (ForceVp[0] - ForceVm[0])/(2.*dGamma);
          dForceV[0][1] = (ForceVp[1] - ForceVm[1])/(2.*dGamma);
          dForceV[0][2] = (ForceVp[2] - ForceVm[2])/(2.*dGamma);

          dMomentI[0][0] = (MomentIp[0] - MomentIm[0])/(2.*dGamma);
          dMomentI[0][1] = (MomentIp[1] - MomentIm[1])/(2.*dGamma);
          dMomentI[0][2] = (MomentIp[2] - MomentIm[2])/(2.*dGamma);
                         
          dMomentV[0][0] = (MomentVp[0] - MomentVm[0])/(2.*dGamma);
          dMomentV[0][1] = (MomentVp[1] - MomentVm[1])/(2.*dGamma);
          dMomentV[0][2] = (MomentVp[2] - MomentVm[2])/(2.*dGamma);
          
          Gamma(i) = GammaSave;
    
          // Compare the two methods
          
          printf("Loop: %d of %d \n",i, VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
          
          printf("Grid 0 XYZ: %f %f %f \n",
          VSPGeom().Grid(0).LoopList(i).Xc(),
          VSPGeom().Grid(0).LoopList(i).Yc(),
          VSPGeom().Grid(0).LoopList(i).Zc());
    
          printf("Inviscid Forces --> xExact: %e %e %e  ... FD: %e %e %e \n",
          
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFwx_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFwy_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFwz_pGamma(),
    
          dForceI[0][0],
          dForceI[0][1],
          dForceI[0][2]);

          printf("Viscous Forces --> xExact: %e %e %e  ... FD: %e %e %e \n",
          
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFxo_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFyo_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFzo_pGamma(),
    
          dForceV[0][0],
          dForceV[0][1],
          dForceV[0][2]);

          printf("Inviscid Moments --> xExact: %e %e %e  ... FD: %e %e %e \n",
          
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pGamma(),
    
          dMomentI[0][0],
          dMomentI[0][1],
          dMomentI[0][2]);

          printf("Viscous Moments --> xExact: %e %e %e  ... FD: %e %e %e \n",
          
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMxo_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMyo_pGamma(),
          Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMzo_pGamma(),
    
          dMomentV[0][0],
          dMomentV[0][1],
          dMomentV[0][2]);
    
          GammaErrorI[0] += pow(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFwx_pGamma(),2.);
          GammaErrorI[1] += pow(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFwy_pGamma(),2.);
          GammaErrorI[2] += pow(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFwz_pGamma(),2.);

          GammaErrorV[0] += pow(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFxo_pGamma(),2.);
          GammaErrorV[1] += pow(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFyo_pGamma(),2.);
          GammaErrorV[2] += pow(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFzo_pGamma(),2.);

          GammaErrorI[3] += pow(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pGamma(),2.);
          GammaErrorI[4] += pow(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pGamma(),2.);
          GammaErrorI[5] += pow(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pGamma(),2.);
                                                                                           
          GammaErrorV[3] += pow(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMxo_pGamma(),2.);
          GammaErrorV[4] += pow(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMyo_pGamma(),2.);
          GammaErrorV[5] += pow(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMzo_pGamma(),2.);
               
          if ( ABS(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFx_pGamma()) > 0.1 )   printf("Force x wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFy_pGamma()) > 0.1 )   printf("Force y wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFz_pGamma()) > 0.1 )   printf("Force z wtf! ... gamma: %f \n",Gamma(i));
                                                                                                           
          if ( ABS(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFxo_pGamma()) > 0.1 )  printf("Force xo wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFyo_pGamma()) > 0.1 )  printf("Force yo wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pFzo_pGamma()) > 0.1 )  printf("Force zo wtf! ... gamma: %f \n",Gamma(i));
                                                                                                     
          if ( ABS(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMx_pGamma()) > 0.01 )  printf("Moment x wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMy_pGamma()) > 0.01 )  printf("Moment y wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMz_pGamma()) > 0.01 )  printf("Moment z wtf! ... gamma: %f \n",Gamma(i));
                                                                                                         
          if ( ABS(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMxo_pGamma()) > 0.01 ) printf("Moment xo wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMyo_pGamma()) > 0.01 ) printf("Moment yo wtf! ... gamma: %f \n",Gamma(i));
          if ( ABS(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(i).pMzo_pGamma()) > 0.01 ) printf("Moment zo wtf! ... gamma: %f \n",Gamma(i));
                                      
       }
    
       for ( j = 0 ; j <= 5 ; j++ ) {
          
          GammaErrorI[j] /= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops();
          GammaErrorV[j] /= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops();
          
          GammaErrorI[j] = sqrt(GammaErrorI[j]);
          GammaErrorV[j] = sqrt(GammaErrorV[j]);
          
          printf("Invisicid GammaError[%d]: %f \n",j, GammaErrorI[j]);
          printf("Viscous GammaErrorV[%d]: %f \n",j, GammaErrorV[j]);
          
       }
       
    }
 
    // The slow way wrt mesh   
    
    double ErrorI, ErrorV, ds;
    
    if ( 1 ) {

       dx = dy = dz = ds = 1.e-7;
       
       MeshErrorI[0][0] = MeshErrorI[0][1] = MeshErrorI[0][2] = 0.;
       MeshErrorI[1][0] = MeshErrorI[1][1] = MeshErrorI[1][2] = 0.;
       MeshErrorI[2][0] = MeshErrorI[2][1] = MeshErrorI[2][2] = 0.;

       MeshErrorV[0][0] = MeshErrorV[0][1] = MeshErrorV[0][2] = 0.;
       MeshErrorV[1][0] = MeshErrorV[1][1] = MeshErrorV[1][2] = 0.;
       MeshErrorV[2][0] = MeshErrorV[2][1] = MeshErrorV[2][2] = 0.;

       MeshErrorI[3][0] = MeshErrorI[3][1] = MeshErrorI[3][2] = 0.;
       MeshErrorI[4][0] = MeshErrorI[4][1] = MeshErrorI[4][2] = 0.;
       MeshErrorI[5][0] = MeshErrorI[5][1] = MeshErrorI[5][2] = 0.;

       MeshErrorV[3][0] = MeshErrorV[3][1] = MeshErrorV[3][2] = 0.;
       MeshErrorV[4][0] = MeshErrorV[4][1] = MeshErrorV[4][2] = 0.;
       MeshErrorV[5][0] = MeshErrorV[5][1] = MeshErrorV[5][2] = 0.;
                  
       double Temp;
                  
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
    
          // X

          Temp = VSPGeom().Grid(0).NodeList(i).x();             
          
          VSPGeom().Grid(0).NodeList(i).x() += dx;
          
          VSPGeom().UpdateMeshes();
          
          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIp[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
          ForceIp[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
          ForceIp[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;

          ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          VSPGeom().Grid(0).NodeList(i).x() = Temp - dx;
          
          VSPGeom().UpdateMeshes();          

          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
        //  CalculateVelocities(ALL_WAKE_GAMMAS);
          
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIm[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
          ForceIm[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
          ForceIm[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;
              
          ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                    
          dForceI[0][0] = (ForceIp[0] - ForceIm[0])/(2.*dx);
          dForceI[0][1] = (ForceIp[1] - ForceIm[1])/(2.*dx);
          dForceI[0][2] = (ForceIp[2] - ForceIm[2])/(2.*dx);
                                                       
          dForceV[0][0] = (ForceVp[0] - ForceVm[0])/(2.*dx);
          dForceV[0][1] = (ForceVp[1] - ForceVm[1])/(2.*dx);
          dForceV[0][2] = (ForceVp[2] - ForceVm[2])/(2.*dx);

          dMomentI[0][0] = (MomentIp[0] - MomentIm[0])/(2.*dx);
          dMomentI[0][1] = (MomentIp[1] - MomentIm[1])/(2.*dx);
          dMomentI[0][2] = (MomentIp[2] - MomentIm[2])/(2.*dx);
                         
          dMomentV[0][0] = (MomentVp[0] - MomentVm[0])/(2.*dx);
          dMomentV[0][1] = (MomentVp[1] - MomentVm[1])/(2.*dx);
          dMomentV[0][2] = (MomentVp[2] - MomentVm[2])/(2.*dx);
                              
          VSPGeom().Grid(0).NodeList(i).x() = Temp;
          
          VSPGeom().UpdateMeshes();          
          
          // Y

          Temp = VSPGeom().Grid(0).NodeList(i).y();             

          VSPGeom().Grid(0).NodeList(i).y() = Temp + dy;
          
          VSPGeom().UpdateMeshes();
          
          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIp[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
          ForceIp[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
          ForceIp[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;

          ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          VSPGeom().Grid(0).NodeList(i).y() = Temp - dy;

          VSPGeom().UpdateMeshes();          

          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);     
          
          CalculateEdgeVelocities();  
          
          CalculateForces();
          
          ForceIm[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
          ForceIm[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
          ForceIm[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;
              
          ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                    
          dForceI[1][0] = (ForceIp[0] - ForceIm[0])/(2.*dy);
          dForceI[1][1] = (ForceIp[1] - ForceIm[1])/(2.*dy);
          dForceI[1][2] = (ForceIp[2] - ForceIm[2])/(2.*dy);
                                                      
          dForceV[1][0] = (ForceVp[0] - ForceVm[0])/(2.*dy);
          dForceV[1][1] = (ForceVp[1] - ForceVm[1])/(2.*dy);
          dForceV[1][2] = (ForceVp[2] - ForceVm[2])/(2.*dy);
          
          dMomentI[1][0] = (MomentIp[0] - MomentIm[0])/(2.*dy);
          dMomentI[1][1] = (MomentIp[1] - MomentIm[1])/(2.*dy);
          dMomentI[1][2] = (MomentIp[2] - MomentIm[2])/(2.*dy);
                     
          dMomentV[1][0] = (MomentVp[0] - MomentVm[0])/(2.*dy);
          dMomentV[1][1] = (MomentVp[1] - MomentVm[1])/(2.*dy);
          dMomentV[1][2] = (MomentVp[2] - MomentVm[2])/(2.*dy);   
                          
          VSPGeom().Grid(0).NodeList(i).y() = Temp ;
           
          VSPGeom().UpdateMeshes();          
             
          // Z
    
          Temp = VSPGeom().Grid(0).NodeList(i).z();    
         
          VSPGeom().Grid(0).NodeList(i).z() = Temp + dz;
          
          VSPGeom().UpdateMeshes();
          
          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);          
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIp[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
          ForceIp[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
          ForceIp[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;

          ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                        
          VSPGeom().Grid(0).NodeList(i).z() = Temp - dz;

          VSPGeom().UpdateMeshes();          
          
          if ( TimeAccurate_ ) CalculateBodyVelocitiesForQuasiUnsteadyAnalysis();
          
          InitializeFreeStream();
          
          //CalculateVelocities(ALL_WAKE_GAMMAS);       
          
          CalculateEdgeVelocities();
          
          CalculateForces();
          
          ForceIm[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
          ForceIm[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
          ForceIm[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;
              
          ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
          ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
          ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

          MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                       
          MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
          MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
          MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                    
          dForceI[2][0] = (ForceIp[0] - ForceIm[0])/(2.*dz);
          dForceI[2][1] = (ForceIp[1] - ForceIm[1])/(2.*dz);
          dForceI[2][2] = (ForceIp[2] - ForceIm[2])/(2.*dz);
                                                 
          dForceV[2][0] = (ForceVp[0] - ForceVm[0])/(2.*dz);
          dForceV[2][1] = (ForceVp[1] - ForceVm[1])/(2.*dz);
          dForceV[2][2] = (ForceVp[2] - ForceVm[2])/(2.*dz);

          dMomentI[2][0] = (MomentIp[0] - MomentIm[0])/(2.*dz);
          dMomentI[2][1] = (MomentIp[1] - MomentIm[1])/(2.*dz);
          dMomentI[2][2] = (MomentIp[2] - MomentIm[2])/(2.*dz);
                  
          dMomentV[2][0] = (MomentVp[0] - MomentVm[0])/(2.*dz);
          dMomentV[2][1] = (MomentVp[1] - MomentVm[1])/(2.*dz);
          dMomentV[2][2] = (MomentVp[2] - MomentVm[2])/(2.*dz);   
                              
          VSPGeom().Grid(0).NodeList(i).z() = Temp;
          
          VSPGeom().UpdateMeshes();          
          
          // Compare the two methods
          
          printf("Node: %d of %d \n",i, VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes());
          
          if ( VSPGeom().Grid(MGLevel_).NodeList(i).IsTrailingEdgeNode() ) printf("Node is on trailing edge of wing... \n");fflush(NULL);
          
          printf("Grid 0 XYZ: %f %f %f \n",
          VSPGeom().Grid(0).NodeList(i).x(),
          VSPGeom().Grid(0).NodeList(i).y(),
          VSPGeom().Grid(0).NodeList(i).z());
    
          printf("Grid 1 XYZ: %f %f %f \n",
          VSPGeom().Grid(1).NodeList(i).x(),
          VSPGeom().Grid(1).NodeList(i).y(),
          VSPGeom().Grid(1).NodeList(i).z());
          
          printf("Inviscid Forces \n");
          printf(" Exact wrt x: %e %e %e  ... FD: %e %e %e \n Exact wrt y: %e %e %e   ... FD: %e %e %e \n Exact wrt z: %e %e %e  ... FD: %e %e %e \n \n",
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pX(),
    
          dForceI[0][0],
          dForceI[0][1],
          dForceI[0][2],
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pY(),
    
          dForceI[1][0],
          dForceI[1][1],
          dForceI[1][2],
    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pZ(),
    
          dForceI[2][0],
          dForceI[2][1],
          dForceI[2][2]);

          printf("Viscous Forces \n");
          printf(" Exact wrt x: %e %e %e  ... FD: %e %e %e \n Exact wrt y: %e %e %e   ... FD: %e %e %e \n Exact wrt z: %e %e %e  ... FD: %e %e %e \n \n",
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX(),
    
          dForceV[0][0],
          dForceV[0][1],
          dForceV[0][2],
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY(),
    
          dForceV[1][0],
          dForceV[1][1],
          dForceV[1][2],
    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ(),
    
          dForceV[2][0],
          dForceV[2][1],
          dForceV[2][2]);
          
          printf("Inviscid Moments \n");
          printf(" Exact wrt x: %e %e %e  ... FD: %e %e %e \n Exact wrt y: %e %e %e   ... FD: %e %e %e \n Exact wrt z: %e %e %e  ... FD: %e %e %e \n \n",
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX(),
                                                     
          dMomentI[0][0],                             
          dMomentI[0][1],                             
          dMomentI[0][2],                             
                                                     
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY(),
                                                    
          dMomentI[1][0],                            
          dMomentI[1][1],                            
          dMomentI[1][2],                            
                                                    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ(),
    
          dMomentI[2][0],
          dMomentI[2][1],
          dMomentI[2][2]);

          printf("Viscous Moments \n");
          printf(" Exact wrt x: %e %e %e  ... FD: %e %e %e \n Exact wrt y: %e %e %e   ... FD: %e %e %e \n Exact wrt z: %e %e %e  ... FD: %e %e %e \n \n",
          
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX(),
                                                    
          dMomentV[0][0],                            
          dMomentV[0][1],                            
          dMomentV[0][2],                            
                                                    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY(),
                                                    
          dMomentV[1][0],                            
          dMomentV[1][1],                            
          dMomentV[1][2],                            
                                                    
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ(),
          Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ(),
    
          dMomentV[2][0],
          dMomentV[2][1],
          dMomentV[2][2]);          
    
          MeshErrorI[0][0] += pow(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pX(),2.);
          MeshErrorI[0][1] += pow(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pX(),2.);
          MeshErrorI[0][2] += pow(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pX(),2.);
                                                                                              
          MeshErrorI[1][0] += pow(dForceI[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pY(),2.);
          MeshErrorI[1][1] += pow(dForceI[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pY(),2.);
          MeshErrorI[1][2] += pow(dForceI[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pY(),2.);
                                                                                              
          MeshErrorI[2][0] += pow(dForceI[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pZ(),2.);
          MeshErrorI[2][1] += pow(dForceI[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pZ(),2.);
          MeshErrorI[2][2] += pow(dForceI[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pZ(),2.);

          MeshErrorI[3][0] += pow(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX(),2.);
          MeshErrorI[3][1] += pow(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX(),2.);
          MeshErrorI[3][2] += pow(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX(),2.);
                                                                                            
          MeshErrorI[4][0] += pow(dMomentI[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY(),2.);
          MeshErrorI[4][1] += pow(dMomentI[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY(),2.);
          MeshErrorI[4][2] += pow(dMomentI[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY(),2.);
                                                                                            
          MeshErrorI[5][0] += pow(dMomentI[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ(),2.);
          MeshErrorI[5][1] += pow(dMomentI[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ(),2.);
          MeshErrorI[5][2] += pow(dMomentI[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ(),2.);
          
          ErrorI = pow(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pX(),2.)
                 + pow(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pX(),2.)
                 + pow(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pX(),2.)
                                                                                   
                 + pow(dForceI[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pY(),2.)
                 + pow(dForceI[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pY(),2.)
                 + pow(dForceI[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pY(),2.)
                                                                                   
                 + pow(dForceI[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwx_pZ(),2.)
                 + pow(dForceI[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwy_pZ(),2.)
                 + pow(dForceI[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFwz_pZ(),2.)

                 + pow(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pX(),2.)
                 + pow(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pX(),2.)
                 + pow(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pX(),2.)
                                                                            
                 + pow(dMomentI[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pY(),2.)
                 + pow(dMomentI[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pY(),2.)
                 + pow(dMomentI[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pY(),2.)
                                                                            
                 + pow(dMomentI[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMix_pZ(),2.)
                 + pow(dMomentI[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiy_pZ(),2.)
                 + pow(dMomentI[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMiz_pZ(),2.);
                 
          if ( sqrt(ErrorI/3.) > 0.1 ) printf("Inviscid -----------------------------------------------------------------------> wtf! \n");fflush(NULL);
          if ( sqrt(ErrorI/3.) > 1000. ) printf("Inviscid -----------------------------------------------------------------------> crap! \n");fflush(NULL);
          
          MeshErrorV[0][0] += pow(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX(),2.);
          MeshErrorV[0][1] += pow(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX(),2.);
          MeshErrorV[0][2] += pow(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX(),2.);
                  
          MeshErrorV[1][0] += pow(dForceV[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY(),2.);
          MeshErrorV[1][1] += pow(dForceV[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY(),2.);
          MeshErrorV[1][2] += pow(dForceV[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY(),2.);
                   
          MeshErrorV[2][0] += pow(dForceV[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ(),2.);
          MeshErrorV[2][1] += pow(dForceV[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ(),2.);
          MeshErrorV[2][2] += pow(dForceV[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ(),2.);

          MeshErrorV[3][0] += pow(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX(),2.);
          MeshErrorV[3][1] += pow(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX(),2.);
          MeshErrorV[3][2] += pow(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX(),2.);
                              
          MeshErrorV[4][0] += pow(dMomentV[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY(),2.);
          MeshErrorV[4][1] += pow(dMomentV[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY(),2.);
          MeshErrorV[4][2] += pow(dMomentV[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY(),2.);
                              
          MeshErrorV[5][0] += pow(dMomentV[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ(),2.);
          MeshErrorV[5][1] += pow(dMomentV[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ(),2.);
          MeshErrorV[5][2] += pow(dMomentV[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ(),2.);
          
          ErrorV = pow(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pX(),2.)
                 + pow(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pX(),2.)
                 + pow(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pX(),2.)
                
                 + pow(dForceV[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pY(),2.)
                 + pow(dForceV[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pY(),2.)
                 + pow(dForceV[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pY(),2.)
                
                 + pow(dForceV[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFox_pZ(),2.)
                 + pow(dForceV[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoy_pZ(),2.)
                 + pow(dForceV[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pFoz_pZ(),2.)
                 
                 + pow(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pX(),2.)
                 + pow(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pX(),2.)
                 + pow(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pX(),2.)
                     
                 + pow(dMomentV[1][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pY(),2.)
                 + pow(dMomentV[1][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pY(),2.)
                 + pow(dMomentV[1][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pY(),2.)
                     
                 + pow(dMomentV[2][0] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMox_pZ(),2.)
                 + pow(dMomentV[2][1] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoy_pZ(),2.)
                 + pow(dMomentV[2][2] - Fact*VSPGeom().Grid(MGLevel_).NodeList(i).pMoz_pZ(),2.);
                
          if ( ErrorV > 0.1 ) printf("Viscous -----------------------------------------------------------------------> wtf! \n");fflush(NULL);
                                            
       }
       
       for ( i = 0 ; i <= 5 ; i++ ) {
          
          for ( j = 0 ; j <= 2 ; j++ ) {
             
             MeshErrorI[i][j] /= VSPGeom().Grid(MGLevel_).NumberOfNodes();
             MeshErrorV[i][j] /= VSPGeom().Grid(MGLevel_).NumberOfNodes();
             
             MeshErrorI[i][j] = sqrt(MeshErrorI[i][j]);
             MeshErrorV[i][j] = sqrt(MeshErrorV[i][j]);
             
             printf("Inviscid MeshErrorI[%d][%d]: %f \n",i,j, MeshErrorI[i][j]);
             printf("Viscous MeshErrorV[%d][%d]: %f \n",i,j, MeshErrorV[i][j]);
             
          }
          
       }

    }

    // The slow way wrt stallfactor
    
    if ( 1 ) {
       
       dStall = 1.e-6;
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
          StallErrorI[0] = StallErrorI[1] = StallErrorI[2] = 0.;
          StallErrorV[0] = StallErrorV[1] = StallErrorV[2] = 0.;
          
          StallErrorI[3] = StallErrorI[4] = StallErrorI[5] = 0.;
          StallErrorV[3] = StallErrorV[4] = StallErrorV[5] = 0.;
                 
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() -= dStall;
             
             InitializeFreeStream();
             
             CalculateEdgeVelocities();
             
             CalculateForces();
             
             ForceIp[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
             ForceIp[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
             ForceIp[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;
             
             ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
             ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
             ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

             MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
             MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
             MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                            
             MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
             MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
             MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                                 
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() -= 2.*dStall;
             
             InitializeFreeStream();
             
             CalculateEdgeVelocities();
             
             CalculateForces();
             
             ForceIm[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
             ForceIm[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
             ForceIm[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;
                 
             ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
             ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
             ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;
           
             MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
             MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
             MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                          
             MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
             MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
             MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                         
             dForceI[0][0] = (ForceIp[0] - ForceIm[0])/(2.*dStall);
             dForceI[0][1] = (ForceIp[1] - ForceIm[1])/(2.*dStall);
             dForceI[0][2] = (ForceIp[2] - ForceIm[2])/(2.*dStall);
                                                          
             dForceV[0][0] = (ForceVp[0] - ForceVm[0])/(2.*dStall);
             dForceV[0][1] = (ForceVp[1] - ForceVm[1])/(2.*dStall);
             dForceV[0][2] = (ForceVp[2] - ForceVm[2])/(2.*dStall);

             dMomentI[0][0] = (MomentIp[0] - MomentIm[0])/(2.*dStall);
             dMomentI[0][1] = (MomentIp[1] - MomentIm[1])/(2.*dStall);
             dMomentI[0][2] = (MomentIp[2] - MomentIm[2])/(2.*dStall);
                            
             dMomentV[0][0] = (MomentVp[0] - MomentVm[0])/(2.*dStall);
             dMomentV[0][1] = (MomentVp[1] - MomentVm[1])/(2.*dStall);
             dMomentV[0][2] = (MomentVp[2] - MomentVm[2])/(2.*dStall);
                            
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() += 3.*dStall;
             
             // Compare the two methods
             
             printf("VortexSheet: %d --> Stall equation: %d \n",k, i);
   
             printf("Inviscid Forces Exact: %e %e %e  ... FD: %e %e %e \n",
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwx_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwy_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFwz_pStallFactor(),
       
             dForceI[0][0],
             dForceI[0][1],
             dForceI[0][2]);

             printf("Viscous Forces Exact: %e %e %e  ... FD: %e %e %e \n",
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFxo_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFyo_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pFzo_pStallFactor(),
       
             dForceV[0][0],
             dForceV[0][1],
             dForceV[0][2]);

             printf("Inviscid Moments Exact: %e %e %e  ... FD: %e %e %e \n",
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor(),
       
             dMomentI[0][0],
             dMomentI[0][1],
             dMomentI[0][2]);

             printf("Viscous Moments Exact: %e %e %e  ... FD: %e %e %e \n",
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMxo_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMyo_pStallFactor(),
             VSPGeom().VortexSheet(k).TrailingVortex(i).pMzo_pStallFactor(),
       
             dMomentV[0][0],
             dMomentV[0][1],
             dMomentV[0][2]);
                                     
             StallErrorI[0] += pow(dForceI[0][0] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFwx_pStallFactor(),2.);
             StallErrorI[1] += pow(dForceI[0][1] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFwy_pStallFactor(),2.);
             StallErrorI[2] += pow(dForceI[0][2] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFwz_pStallFactor(),2.);

             StallErrorV[0] += pow(dForceV[0][0] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFxo_pStallFactor(),2.);
             StallErrorV[1] += pow(dForceV[0][1] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFyo_pStallFactor(),2.);
             StallErrorV[2] += pow(dForceV[0][2] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pFzo_pStallFactor(),2.);

             StallErrorI[3] += pow(dMomentI[0][0] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMx_pStallFactor(),2.);
             StallErrorI[4] += pow(dMomentI[0][1] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMy_pStallFactor(),2.);
             StallErrorI[5] += pow(dMomentI[0][2] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMz_pStallFactor(),2.);
                             
             StallErrorV[3] += pow(dMomentV[0][0] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMxo_pStallFactor(),2.);
             StallErrorV[4] += pow(dMomentV[0][1] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMyo_pStallFactor(),2.);
             StallErrorV[5] += pow(dMomentV[0][2] - Fact*VSPGeom().VortexSheet(k).TrailingVortex(i).pMzo_pStallFactor(),2.);
                          
          }
         
          for ( j = 0 ; j <= 5 ; j++ ) {
             
             StallErrorI[j] /= VSPGeom().VortexSheet(k).NumberOfTrailingVortices();
             StallErrorV[j] /= VSPGeom().VortexSheet(k).NumberOfTrailingVortices();
             
             StallErrorI[j] = sqrt(StallErrorI[j]);
             StallErrorV[j] = sqrt(StallErrorV[j]);
             
             printf("Inviscid StallErrorI[%d]: %f \n",j, StallErrorI[j]);
             printf("Viscous StallErrorV[%d]: %f \n",j, StallErrorV[j]);
             
          }
   
       }
       
    }

    // The slow way wrt vortex stretching factor
    
    if ( 1 ) {
       
       int Loop;
       
       dRatio = 1.e-3;
       
       RatioErrorI[0] = RatioErrorI[1] = RatioErrorI[2] = 0.;
       RatioErrorV[0] = RatioErrorV[1] = RatioErrorV[2] = 0.;

       RatioErrorI[3] = RatioErrorI[4] = RatioErrorI[5] = 0.;
       RatioErrorV[3] = RatioErrorV[4] = RatioErrorV[5] = 0.;
    
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
     
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
   
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 &&
                  VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
                    
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() += dRatio;
      
                CalculateEdgeVelocities();
   
                CalculateForces();
                
                ForceIp[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
                ForceIp[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
                ForceIp[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;
      
                ForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
                ForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
                ForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;
                       
                MomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
                MomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
                MomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                             
                MomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
                MomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
                MomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                                       
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() -= 2.*dRatio;
                      
                CalculateEdgeVelocities();
                
                CalculateForces();
                             
                ForceIm[0] = CFiwx()*0.5*Sref_*Vref_*Vref_;
                ForceIm[1] = CFiwy()*0.5*Sref_*Vref_*Vref_;
                ForceIm[2] = CFiwz()*0.5*Sref_*Vref_*Vref_;             
                   
                ForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
                ForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
                ForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;

                MomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
                MomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
                MomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                             
                MomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
                MomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
                MomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;
                                          
                dForceI[0][0] = (ForceIp[0] - ForceIm[0])/(2.*dRatio);
                dForceI[0][1] = (ForceIp[1] - ForceIm[1])/(2.*dRatio);
                dForceI[0][2] = (ForceIp[2] - ForceIm[2])/(2.*dRatio);
                                                        
                dForceV[0][0] = (ForceVp[0] - ForceVm[0])/(2.*dRatio);
                dForceV[0][1] = (ForceVp[1] - ForceVm[1])/(2.*dRatio);
                dForceV[0][2] = (ForceVp[2] - ForceVm[2])/(2.*dRatio);

                dMomentI[0][0] = (MomentIp[0] - MomentIm[0])/(2.*dRatio);
                dMomentI[0][1] = (MomentIp[1] - MomentIm[1])/(2.*dRatio);
                dMomentI[0][2] = (MomentIp[2] - MomentIm[2])/(2.*dRatio);
                               
                dMomentV[0][0] = (MomentVp[0] - MomentVm[0])/(2.*dRatio);
                dMomentV[0][1] = (MomentVp[1] - MomentVm[1])/(2.*dRatio);
                dMomentV[0][2] = (MomentVp[2] - MomentVm[2])/(2.*dRatio);
                   
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() += dRatio;
          
                // Compare the two methods
   
                printf("Grid 0 XYZ: %f %f %f \n",
                VSPGeom().Grid(0).LoopList(Loop).Xc(),
                VSPGeom().Grid(0).LoopList(Loop).Yc(),
                VSPGeom().Grid(0).LoopList(Loop).Zc());
          
                printf("Inviscid Forces --> xExact: %e %e %e  ... FD: %e %e %e \n",
                
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwx_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwy_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwz_pRatio(),
          
                dForceI[0][0],
                dForceI[0][1],
                dForceI[0][2]);
      
                printf("Viscous Forces --> xExact: %e %e %e  ... FD: %e %e %e \n",
                
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFxo_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFyo_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFzo_pRatio(),
          
                dForceV[0][0],
                dForceV[0][1],
                dForceV[0][2]);

                printf("Inviscid Moments --> xExact: %e %e %e  ... FD: %e %e %e \n",
                
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMx_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMy_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMz_pRatio(),
          
                dMomentI[0][0],
                dMomentI[0][1],
                dMomentI[0][2]);
      
                printf("Viscous Moments --> xExact: %e %e %e  ... FD: %e %e %e \n",
                
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMxo_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMyo_pRatio(),
                Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMzo_pRatio(),
          
                dMomentV[0][0],
                dMomentV[0][1],
                dMomentV[0][2]);
          
                RatioErrorI[0] += pow(dForceI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwx_pRatio(),2.);
                RatioErrorI[1] += pow(dForceI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwy_pRatio(),2.);
                RatioErrorI[2] += pow(dForceI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFiwz_pRatio(),2.);
                                                                                           
                RatioErrorV[0] += pow(dForceV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFxo_pRatio(),2.);
                RatioErrorV[1] += pow(dForceV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFyo_pRatio(),2.);
                RatioErrorV[2] += pow(dForceV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pFzo_pRatio(),2.);

                RatioErrorI[3] += pow(dMomentI[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMx_pRatio(),2.);
                RatioErrorI[4] += pow(dMomentI[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMy_pRatio(),2.);
                RatioErrorI[5] += pow(dMomentI[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMz_pRatio(),2.);
                                    
                RatioErrorV[3] += pow(dMomentV[0][0] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMxo_pRatio(),2.);
                RatioErrorV[4] += pow(dMomentV[0][1] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMyo_pRatio(),2.);
                RatioErrorV[5] += pow(dMomentV[0][2] - Fact*VSPGeom().Grid(MGLevel_).LoopList(Loop).pMzo_pRatio(),2.);
                        
                for ( j = 0 ; j <= 5 ; j++ ) {
                   
                   RatioErrorI[j] /= (VSPGeom().Grid(MGLevel_).NumberOfLoops() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
                   RatioErrorV[j] /= (VSPGeom().Grid(MGLevel_).NumberOfLoops() - VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());
                   
                   RatioErrorI[j] = sqrt(RatioErrorI[j]);
                   RatioErrorV[j] = sqrt(RatioErrorV[j]);
                   
                   printf("Invisicid RatioErrorI[%d]: %f \n",j, RatioErrorI[j]);
                   printf("Viscous RatioErrorV[%d]: %f \n",j, RatioErrorV[j]);
                   
                }
                
             }
      
          }
   
       }    
    
    }
    
}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER TestForceGradients                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestTotalUnsteadyForceGradients(void)
{
   
    int i, Dir;
    double dForceI[3][3], dForceV[3][3];
    double dMomentI[3][3], dMomentV[3][3];    
    double ds;
    
    i = 10;
    
    Dir = 1;
    
    ds = 1.e-6;
    
  //  dx = 0.01 * VSPGeom().Grid(0).NodeList(i).x();
  //  dy = 0.01 * VSPGeom().Grid(0).NodeList(i).y();
  //  dz = 0.01 * VSPGeom().Grid(0).NodeList(i).z();
    
    // First time through
    
    if ( UnsteadyFDTest_ == 0 ) {
         
       // Perturb a node so we can do a finite diff test

       if ( Dir == 1 ) VSPGeom().Grid(0).NodeList(i).x() -= ds;
       if ( Dir == 2 ) VSPGeom().Grid(0).NodeList(i).y() -= ds;
       if ( Dir == 3 ) VSPGeom().Grid(0).NodeList(i).z() -= ds;
       
       VSPGeom().UpdateMeshes();
       
       InitializeFreeStream();
     
       UnsteadyFDTest_ = 1;
       
       printf("\n\n\n\n 1st pass... Node perturbed by %e \n\n\n\n",-ds);fflush(NULL);
       
    }
    
    // Second time through
    
    else if ( UnsteadyFDTest_ == 1 ) {
       
        TestTotalUnsteadyForceIm[0] = CFix()*0.5*Sref_*Vref_*Vref_;
        TestTotalUnsteadyForceIm[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
        TestTotalUnsteadyForceIm[2] = CFiz()*0.5*Sref_*Vref_*Vref_;
                              
        TestTotalUnsteadyForceVm[0] = CFox()*0.5*Sref_*Vref_*Vref_;
        TestTotalUnsteadyForceVm[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
        TestTotalUnsteadyForceVm[2] = CFoz()*0.5*Sref_*Vref_*Vref_;    

       TestTotalUnsteadyMomentIm[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
       TestTotalUnsteadyMomentIm[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
       TestTotalUnsteadyMomentIm[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                                     
       TestTotalUnsteadyMomentVm[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
       TestTotalUnsteadyMomentVm[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
       TestTotalUnsteadyMomentVm[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;    
       
       if ( Dir == 1 ) VSPGeom().Grid(0).NodeList(i).x() += 2.*ds;
       if ( Dir == 2 ) VSPGeom().Grid(0).NodeList(i).y() += 2.*ds;
       if ( Dir == 3 ) VSPGeom().Grid(0).NodeList(i).z() += 2.*ds;
       
       VSPGeom().UpdateMeshes();
       
       InitializeFreeStream();
        
       UnsteadyFDTest_ = 2;
       
       printf("\n\n\n\n 2nd pass... Node perturbed by %e \n\n\n\n", ds);fflush(NULL);

    }

    else if ( UnsteadyFDTest_ == 2 ) {
       
        TestTotalUnsteadyForceIp[0] = CFix()*0.5*Sref_*Vref_*Vref_;
        TestTotalUnsteadyForceIp[1] = CFiy()*0.5*Sref_*Vref_*Vref_;
        TestTotalUnsteadyForceIp[2] = CFiz()*0.5*Sref_*Vref_*Vref_;
                            
        TestTotalUnsteadyForceVp[0] = CFox()*0.5*Sref_*Vref_*Vref_;
        TestTotalUnsteadyForceVp[1] = CFoy()*0.5*Sref_*Vref_*Vref_;
        TestTotalUnsteadyForceVp[2] = CFoz()*0.5*Sref_*Vref_*Vref_;    

       TestTotalUnsteadyMomentIp[0] = CMix()*0.5*Sref_*Vref_*Vref_*Bref_;
       TestTotalUnsteadyMomentIp[1] = CMiy()*0.5*Sref_*Vref_*Vref_*Cref_;
       TestTotalUnsteadyMomentIp[2] = CMiz()*0.5*Sref_*Vref_*Vref_*Bref_;
                                
       TestTotalUnsteadyMomentVp[0] = CMox()*0.5*Sref_*Vref_*Vref_*Bref_;
       TestTotalUnsteadyMomentVp[1] = CMoy()*0.5*Sref_*Vref_*Vref_*Cref_;
       TestTotalUnsteadyMomentVp[2] = CMoz()*0.5*Sref_*Vref_*Vref_*Bref_;    
       
        dForceI[0][0] = (TestTotalUnsteadyForceIp[0] - TestTotalUnsteadyForceIm[0])/(2.*ds);
        dForceI[0][1] = (TestTotalUnsteadyForceIp[1] - TestTotalUnsteadyForceIm[1])/(2.*ds);
        dForceI[0][2] = (TestTotalUnsteadyForceIp[2] - TestTotalUnsteadyForceIm[2])/(2.*ds);
                                                                                        
        dForceV[0][0] = (TestTotalUnsteadyForceVp[0] - TestTotalUnsteadyForceVm[0])/(2.*ds);
        dForceV[0][1] = (TestTotalUnsteadyForceVp[1] - TestTotalUnsteadyForceVm[1])/(2.*ds);
        dForceV[0][2] = (TestTotalUnsteadyForceVp[2] - TestTotalUnsteadyForceVm[2])/(2.*ds);

       dMomentI[0][0] = (TestTotalUnsteadyMomentIp[0] - TestTotalUnsteadyMomentIm[0])/(2.*ds);
       dMomentI[0][1] = (TestTotalUnsteadyMomentIp[1] - TestTotalUnsteadyMomentIm[1])/(2.*ds);
       dMomentI[0][2] = (TestTotalUnsteadyMomentIp[2] - TestTotalUnsteadyMomentIm[2])/(2.*ds);
                                                                                          
       dMomentV[0][0] = (TestTotalUnsteadyMomentVp[0] - TestTotalUnsteadyMomentVm[0])/(2.*ds);
       dMomentV[0][1] = (TestTotalUnsteadyMomentVp[1] - TestTotalUnsteadyMomentVm[1])/(2.*ds);
       dMomentV[0][2] = (TestTotalUnsteadyMomentVp[2] - TestTotalUnsteadyMomentVm[2])/(2.*ds);
       
       if ( Dir == 1 ) VSPGeom().Grid(0).NodeList(i).x() -= ds;
       if ( Dir == 2 ) VSPGeom().Grid(0).NodeList(i).y() -= ds;
       if ( Dir == 3 ) VSPGeom().Grid(0).NodeList(i).z() -= ds;
         
       VSPGeom().UpdateMeshes();          
 
       printf("\n\n\nNode: %d \n",i);
       
       printf("Grid 0 XYZ: %13.10e %13.10e %13.10e \n",
       VSPGeom().Grid(0).NodeList(i).x(),
       VSPGeom().Grid(0).NodeList(i).y(),
       VSPGeom().Grid(0).NodeList(i).z());

       printf("Inviscid Forces \n");
       if ( Dir == 1 ) printf(" wrt x: FD: %e %e %e \n\n\n",
       dForceI[0][0],
       dForceI[0][1],
       dForceI[0][2]);
              
       if ( Dir == 2 ) printf(" wrt y: FD: %e %e %e \n\n\n",
       dForceI[0][0],
       dForceI[0][1],
       dForceI[0][2]);       
       
       if ( Dir == 3 ) printf(" wrt z: FD: %e %e %e \n\n\n",
       dForceI[0][0],
       dForceI[0][1],
       dForceI[0][2]);


       printf("Viscous Forces \n");
       if ( Dir == 1 ) printf(" wrt x: FD: %e %e %e \n\n\n",
       dForceV[0][0],
       dForceV[0][1],
       dForceV[0][2]);
              
       if ( Dir == 2 ) printf(" wrt y: FD: %e %e %e \n\n\n",
       dForceV[0][0],
       dForceV[0][1],
       dForceV[0][2]);
              
       if ( Dir == 3 ) printf(" wrt z: FD: %e %e %e \n\n\n",
       dForceV[0][0],
       dForceV[0][1],
       dForceV[0][2]);       

       printf("Inviscid Moments \n");
       if ( Dir == 1 ) printf(" wrt x: FD: %e %e %e \n\n\n",
       dMomentI[0][0],
       dMomentI[0][1],
       dMomentI[0][2]);
              
       if ( Dir == 2 ) printf(" wrt y: FD: %e %e %e \n\n\n",
       dMomentI[0][0],
       dMomentI[0][1],
       dMomentI[0][2]);       
       
       if ( Dir == 3 ) printf(" wrt z: FD: %e %e %e \n\n\n",
       dMomentI[0][0],
       dMomentI[0][1],
       dMomentI[0][2]);


       printf("Viscous Moments \n");
       if ( Dir == 1 ) printf(" wrt x: FD: %e %e %e \n\n\n",
       dMomentV[0][0],
       dMomentV[0][1],
       dMomentV[0][2]);
              
       if ( Dir == 2 ) printf(" wrt y: FD: %e %e %e \n\n\n",
       dMomentV[0][0],
       dMomentV[0][1],
       dMomentV[0][2]);
              
       if ( Dir == 3 ) printf(" wrt z: FD: %e %e %e \n\n\n",
       dMomentV[0][0],
       dMomentV[0][1],
       dMomentV[0][2]);  

       UnsteadyFDTest_ = 3;
    
    }    
    
}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER CreateAdjointMatrix                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateAdjointMatrix(void)
{

    int i, j, Eqn;
    int d_size;
    double Error, L2Error, *VecIn, *VecOut1, *VecOut2, Dot;
    
    MATRIX AdjointMatrix_;
    
    ImplicitWake_ = 1;
    
    CalculateResidual();

    d_size = sizeof(double);
    
    VecIn = new double[NumberOfEquations_ + 1];
    
    VecOut1 = new double[NumberOfEquations_ + 1];

    VecOut2 = new double[NumberOfEquations_ + 1];  
    
    for ( i = 0 ; i <= NumberOfEquations_ ; i++ ) {
       
       VecIn[i] = 0.;
       
       VecOut1[i] = 0.;

       VecOut2[i] = 0.;

    }
      
    // Create the fast multipole adjoint matrix data

    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {

       VecIn[i] = double(i);

    }
       
    printf("Doing adjoint matrix multiply the fast way... \n");fflush(NULL);
    
    Time1_ = myclock();
 
    CreateAdjointCoarseEdgeList();
   
    DoAdjointMatrixMultiply(VecIn, VecOut1);

    Time2_ = myclock() - Time1_;
    
    printf("Fast adjoint matrix multiply took: %f seconds \n",Time2_);

    printf("Creating the adjoint matrix the slow way... \n");fflush(NULL);

    for ( i = 0 ; i <= NumberOfEquations_ ; i++ ) {

       VecIn[i] = 0.;

    }
    
    // Allocate space for the matrix
    
    AdjointMatrix_.size(NumberOfEquations_, NumberOfEquations_);
    
    // Create the matrix

    printf("Starting... \n");fflush(NULL);

    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {

       VecIn[i-1] = 0.;
       VecIn[i  ] = 1.;
       
       Time1_ = myclock();
       
       DoForwardMatrixMultiply(VecIn, Residual_);

       Time2_ = myclock() - Time1_;
       
       printf("Finished column %d of %d and matrix multiply took %f seconds \r",i,NumberOfEquations_,Time2_); fflush(NULL);
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
     
          AdjointMatrix_(i,j) = Residual_[j];

       }

    }

    printf("\n\n\n");
    
    fflush(NULL);
    
    // Do matrix-vector product

    for ( i = 0 ; i <= NumberOfEquations_ ; i++ ) {

       VecIn[i] = double(i);
       
   //    if ( i > VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ) VecIn[i] = 0.;
  //     if ( i > VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + VSPGeom().NumberOfWakeResidualEquations() ) VecIn[i] = 0.;

    }

    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
    
      Dot = 0.;

      for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {

         Dot += AdjointMatrix_(i,j) * VecIn[j];
                  
      }
      
      VecOut2[i] = Dot;
    
    }

    // Compare
    
    L2Error = 0.;

    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
    
       Error = VecOut1[i] - VecOut2[i];

       L2Error += Error*Error;
       
    }
    
    L2Error /= NumberOfEquations_;
    
    L2Error = sqrt(L2Error);
           
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
    
       Error = VecOut1[i] - VecOut2[i];
    
       if ( ABS(Error) > 0.01 ) {
          
          printf("Vorticity Loop: %d @ %f %f %f -->  VecOut1,2: %f %f --> Error: %e <------------- ****** \n",
          i,
          VSPGeom().Grid(MGLevel_).LoopList(i).Xc(),
          VSPGeom().Grid(MGLevel_).LoopList(i).Yc(),
          VSPGeom().Grid(MGLevel_).LoopList(i).Zc(),          
          VecOut1[i],
          VecOut2[i],
          Error);
          
       }
       
       else {
          
          printf("Vorticity Loop: %d @ %f %f %f -->  VecOut1,2: %f %f --> Error: %e \n",
          i,
          VSPGeom().Grid(MGLevel_).LoopList(i).Xc(),
          VSPGeom().Grid(MGLevel_).LoopList(i).Yc(),
          VSPGeom().Grid(MGLevel_).LoopList(i).Zc(),          
          VecOut1[i],
          VecOut2[i],
          Error);
       }          

    }
    

    for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() + 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
           
       j = i - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();

       // X
       
       Eqn = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j - 2;
       
       Error = VecOut1[Eqn] - VecOut2[Eqn];
    
       if ( ABS(Error) > 0.01 ) {
          
          printf("Wake X: %d ... Eqn: %d ... @ %f %f %f --> VecOut1,2: %f %f --> Error: %e <------------- ****** \n",
          i,
          Eqn,
          VSPGeom().Grid(MGLevel_).NodeList(i).x(),
          VSPGeom().Grid(MGLevel_).NodeList(i).y(),
          VSPGeom().Grid(MGLevel_).NodeList(i).z(),
          VecOut1[Eqn],
          VecOut2[Eqn],
          Error);
          
       }
       
       else {
          
          printf("Wake X: %d ... Eqn: %d ... @ %f %f %f --> VecOut1,2: %f %f --> Error: %e \n",
          i,
          Eqn,
          VSPGeom().Grid(MGLevel_).NodeList(i).x(),
          VSPGeom().Grid(MGLevel_).NodeList(i).y(),
          VSPGeom().Grid(MGLevel_).NodeList(i).z(),
          VecOut1[Eqn],
          VecOut2[Eqn],
          Error);
          
       }          

       // Y
       
       Eqn = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j - 1;
       
       Error = VecOut1[Eqn] - VecOut2[Eqn];
    
       if ( ABS(Error) > 0.01 ) {
          
          printf("Wake Y: %d ... Eqn: %d ... @ %f %f %f --> VecOut1,2: %f %f --> Error: %e <------------- ****** \n",
          i,
          Eqn,
          VSPGeom().Grid(MGLevel_).NodeList(i).x(),
          VSPGeom().Grid(MGLevel_).NodeList(i).y(),
          VSPGeom().Grid(MGLevel_).NodeList(i).z(),
          VecOut1[Eqn],
          VecOut2[Eqn],
          Error);
          
       }
       
       else {
          
          printf("Wake Y: %d ... Eqn: %d ... @ %f %f %f --> VecOut1,2: %f %f --> Error: %e \n",
          i,
          Eqn,
          VSPGeom().Grid(MGLevel_).NodeList(i).x(),
          VSPGeom().Grid(MGLevel_).NodeList(i).y(),
          VSPGeom().Grid(MGLevel_).NodeList(i).z(),
          VecOut1[Eqn],
          VecOut2[Eqn],
          Error);
          
       }         

       // Z
       
       Eqn = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*j - 0;
       
       Error = VecOut1[Eqn] - VecOut2[Eqn];

       if ( ABS(Error) > 0.01 ) {
          
          printf("Wake z: %d ... Eqn: %d ... @ %f %f %f --> VecOut1,2: %f %f --> Error: %e <------------- ****** \n",
          i,
          Eqn,
          VSPGeom().Grid(MGLevel_).NodeList(i).x(),
          VSPGeom().Grid(MGLevel_).NodeList(i).y(),
          VSPGeom().Grid(MGLevel_).NodeList(i).z(),
          VecOut1[Eqn],
          VecOut2[Eqn],
          Error);
          
       }
       
       else {
          
          printf("Wake z: %d ... Eqn: %d ... @ %f %f %f --> VecOut1,2: %f %f --> Error: %e \n",
          i,
          Eqn,
          VSPGeom().Grid(MGLevel_).NodeList(i).x(),
          VSPGeom().Grid(MGLevel_).NodeList(i).y(),
          VSPGeom().Grid(MGLevel_).NodeList(i).z(),
          VecOut1[Eqn],
          VecOut2[Eqn],
          Error);
          
       }     
                            
    }
    
    for ( i = 1 ; i <= VSPGeom().NumberOfStallResidualEquations() ; i++ ) {
           
       // X
       
       Eqn = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + VSPGeom().NumberOfWakeResidualEquations() + i;
       
       Error = VecOut1[Eqn] - VecOut2[Eqn];
    
       if ( ABS(Error) > 0.01 ) {
          
          printf("Stall equation: %d --> VecOut1,2: %f %f --> Error: %e <------------- ****** \n",
          i,
          VecOut1[Eqn],
          VecOut2[Eqn],
          Error);
          
       }
       
       else {
          
          printf("Stall equation: %d --> VecOut1,2: %f %f --> Error: %e \n",
          i,
          VecOut1[Eqn],
          VecOut2[Eqn],
          Error);
          
       } 
       
    }
       
    if ( TimeAccurate_ ) {
       
       for ( i = 1 ; i <= VSPGeom().NumberOfVortexStretchingRatioEquations() ; i++ ) {
              
          // X
          
          Eqn = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + VSPGeom().NumberOfWakeResidualEquations() + VSPGeom().NumberOfStallResidualEquations() + i;
          
          Error = VecOut1[Eqn] - VecOut2[Eqn];
       
          if ( ABS(Error) > 0.01 ) {
             
             printf("Vortex stretching equation: %d --> VecOut1,2: %f %f --> Error: %e <------------- ****** \n",
             i,
             VecOut1[Eqn],
             VecOut2[Eqn],
             Error);
             
          }
          
          else {
             
             printf("Vortex stretching equation: %d --> VecOut1,2: %f %f --> Error: %e \n",
             i,
             VecOut1[Eqn],
             VecOut2[Eqn],
             Error);
             
          } 
          
       }
       
    }
               
    printf("L2 Error: %f \n",L2Error);fflush(NULL);
    
    fflush(NULL);
     
}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER CreateAdjointMatrix                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateAdjointMatrixFull(void)
{

    int i, j, k;
    double Error, *VecIn, *VecOut;
    
    MATRIX AdjointMatrix1,  AdjointMatrix2;
    
    ImplicitWake_ = 1;
    
    CalculateResidual();

    VecIn = new double[NumberOfEquations_ + 1];
    
    VecOut = new double[NumberOfEquations_ + 1];
    
    for ( i = 0 ; i <= NumberOfEquations_ ; i++ ) {

       VecIn[i] = VecOut[i] = 0.;

    }
       
    printf("Doing adjoint matrix multiply using adjoint matrix multiply \n");fflush(NULL);
    
    AdjointMatrix1.size(NumberOfEquations_, NumberOfEquations_);
    
    Time1_ = myclock();
 
    CreateAdjointCoarseEdgeList();
    
    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
       
       printf("Finished column %d of %d and matrix multiply took %f seconds \r",i,NumberOfEquations_,Time2_); fflush(NULL);
    
       VecIn[i-1] = 0.;
       VecIn[i  ] = 1.;
       
       DoAdjointMatrixMultiply(VecIn, VecOut);
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
       
          AdjointMatrix1(j,i) = VecOut[j];
          
       }
       
    }

    Time2_ = myclock() - Time1_;

    printf("Doing adjoint matrix multiply using forward matrix multiply \n");fflush(NULL);

    for ( i = 0 ; i <= NumberOfEquations_ ; i++ ) {

       VecIn[i] = 0.;

    }
    
    // Allocate space for the matrix
    
    AdjointMatrix2.size(NumberOfEquations_, NumberOfEquations_);
    
    // Create the matrix

    printf("Starting... \n");fflush(NULL);

    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {

       VecIn[i-1] = 0.;
       VecIn[i  ] = 1.;
       
       Time1_ = myclock();
       
       DoForwardMatrixMultiply(VecIn, Residual_);

       Time2_ = myclock() - Time1_;
       
       printf("Finished column %d of %d and matrix multiply took %f seconds \r",i,NumberOfEquations_,Time2_); fflush(NULL);
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
     
          AdjointMatrix2(i,j) = Residual_[j];

       }

    }

    printf("\n\n\n");
    
    fflush(NULL);
    
    int LoopEqns = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops();
    int WakeEqns = LoopEqns + VSPGeom().NumberOfWakeResidualEquations();
    int StllEqns = WakeEqns + VSPGeom().NumberOfStallResidualEquations();
    
    int StchEqns = 0;
    
    if ( TimeAccurate_ ) {
       
       StchEqns = StllEqns + VSPGeom().NumberOfVortexStretchingRatioEquations();   
       
    }
    
    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
    
      for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
         
         Error = ABS(AdjointMatrix1(i,j)-AdjointMatrix2(i,j));
         
         if ( i <= LoopEqns ) printf("Vortex Loop Equation: ");
            
         if ( i > LoopEqns && i <= WakeEqns ) {
            
            k = (i-LoopEqns)/3;
            
           // i  k  
           // 
           // 1  0
           // 2  0
           // 3  1
           // 
           // 4  1
           // 5  1
           // 6  2
           // 
           // 7  2
           // 8  2
           // 9  3
            
            if ( 3*k + 1 == i - LoopEqns ) printf("X Wake Equation: ");
            if ( 3*k + 2 == i - LoopEqns ) printf("Y Wake Equation: ");
            if ( 3*k + 0 == i - LoopEqns ) printf("Z Wake Equation: ");
            
         }
            
         if ( i > WakeEqns && i <= StllEqns ) printf("Stall Equation: ");

         if ( i > StllEqns && i <= StchEqns ) printf("Vortex Stretch Equation: ");

         printf("At(%d,%d)--> Forward: %e ... Reverse: %e ",
         i,
         j,
         AdjointMatrix2(i,j) ,
         AdjointMatrix1(i,j));
   
         if ( j <= LoopEqns ) printf(" ... Vortex Loop Coef: ");
             
       //  if ( j > LoopEqns && i <= WakeEqns ) printf(" ... Wake Coef: ");
             
         if ( j > LoopEqns && j <= WakeEqns ) {
            
            k = (j-LoopEqns)/3;
            
            if ( 3*k + 1 == j - LoopEqns ) printf("X Wake Coef: ");
            if ( 3*k + 2 == j - LoopEqns ) printf("Y Wake Coef: ");
            if ( 3*k + 0 == j - LoopEqns ) printf("Z Wake Coef: ");
            
         }
                      
         if ( j > WakeEqns && i <= StllEqns ) printf(" ... Stall Coef: ");
            
         if ( j > StllEqns && i <= StchEqns ) printf(" ... Vortex Stretch Coef: ");            

         if ( Error > 0.01 ) { 
            
            printf("  <-------------- wtf! \n");
            
         }
         
         else {
            
            printf("\n");
            
         }
                  
      }
      
    }

    fflush(NULL);
     
}

/*##############################################################################
#                                                                              #
#                    VSP_SOLVER TestPartialResdiual_pMesh                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestPartialResdiual_pMesh(void)
{

    int i, j;
    int d_size;
    double Eps;
    double Error, L2Error, *Res0, dR_dMesh, Dot;
    double dF_dx_exact, dF_dy_exact, dF_dz_exact;
    double dF_dx_fd, dF_dy_fd, dF_dz_fd;
    double ErrorX, ErrorY, ErrorZ;

    Res0 = new double[NumberOfEquations_ + 1];

    // Calculate fast Psi_T x pR_Mesh
    
    CalculatePsiT_PartialResidualPartialMesh();
    
    // Grab the current residual
    
    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
       
       Res0[i] = -Residual_[i];
  
    }

    // Calculate perturbations

    Eps = 1.e-7;
 
    // Perturb the wake mesh
    
    ErrorX = ErrorY = ErrorZ = 0.;
    
   for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {
  //   for ( i = 1 ; i <= 50 ; i++ ) {

       printf("Node: %d \n",i);
       
       // X
       
          VSPGeom().Grid(0).NodeList(i).x() += Eps;
          
          VSPGeom().UpdateMeshes();
          
          InitializeFreeStream();
          
          // Caculate perturbed residual
                    
          CalculateResidual();       
          
          Dot = 0.;
          
          for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
//          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; j++ ) {
             
             dR_dMesh = ( -Residual_[j] - Res0[j] )/Eps;
             
             Dot += CurrentPsi_[j] * dR_dMesh;
             
          }     

          dF_dx_exact = pF_pMesh_[3*i-2] - PsiT_pR_pMesh_[3*i-2];
    
          dF_dx_fd    = pF_pMesh_[3*i-2] - Dot;
                 
          printf("X .. Exact: %f ... FD: %f with: pF_pMesh_[3*i-2] %f \n",dF_dx_exact, dF_dx_fd, pF_pMesh_[3*i-2]);
          
          if ( ABS(dF_dx_exact - dF_dx_fd) > 0.1 ) printf("<----------------------- wtf! \n");
          
          ErrorX += pow(dF_dx_exact - dF_dx_fd,2.);
          
          VSPGeom().Grid(0).NodeList(i).x() -= Eps;
       
       // Y
       
          VSPGeom().Grid(0).NodeList(i).y() += Eps;
          
          VSPGeom().UpdateMeshes();

          InitializeFreeStream();
          
          // Caculate perturbed residual
          
          CalculateResidual();       
          
          Dot = 0.;
          
          for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
//          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; j++ ) {
             
             dR_dMesh = ( -Residual_[j] - Res0[j] )/Eps;
             
             Dot += CurrentPsi_[j] * dR_dMesh;
             
          }     
          
          dF_dy_exact = pF_pMesh_[3*i-1] - PsiT_pR_pMesh_[3*i-1];
                                     
          dF_dy_fd    = pF_pMesh_[3*i-1] - Dot;
                 
          printf("Y .. Exact: %f ... FD: %f with: pF_pMesh_[3*i-1] %f \n",dF_dy_exact, dF_dy_fd, pF_pMesh_[3*i-1]);          

          if ( ABS(dF_dy_exact - dF_dy_fd) > 0.1 ) printf("<----------------------- wtf! \n");
          
          ErrorY += pow(dF_dy_exact - dF_dy_fd,2.);

          VSPGeom().Grid(0).NodeList(i).y() -= Eps;       
          
       // Z
       
          VSPGeom().Grid(0).NodeList(i).z() += Eps;
          
          VSPGeom().UpdateMeshes();

          InitializeFreeStream();
          
          // Caculate perturbed residual
          
          CalculateResidual();       
          
          Dot = 0.;
          
          for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
//          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; j++ ) {
             
             dR_dMesh = ( -Residual_[j] - Res0[j] )/Eps;
             
             Dot += CurrentPsi_[j] * dR_dMesh;
             
          }     
          
          dF_dz_exact = pF_pMesh_[3*i-0] - PsiT_pR_pMesh_[3*i-0];
                                
          dF_dz_fd    = pF_pMesh_[3*i-0] - Dot;
                 
// djk maybe pF_pMesh_?
                 
          printf("Z .. Exact: %f ... FD: %f with: pF_pMesh_[3*i-0] %f \n",dF_dz_exact, dF_dz_fd, pF_pMesh_[3*i-0]);          
         
          if ( ABS(dF_dz_exact - dF_dz_fd) > 0.1 ) printf("<----------------------- wtf! \n");
         
          ErrorZ += pow(dF_dz_exact - dF_dz_fd,2.);
          
          VSPGeom().Grid(0).NodeList(i).z() -= Eps;       
                             
       printf("\n\n");

    }
    
    ErrorX = sqrt(ErrorX/VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes());
    ErrorY = sqrt(ErrorY/VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes());
    ErrorZ = sqrt(ErrorZ/VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes());
    
    printf("ErrorX: %f \n",ErrorX);
    printf("ErrorY: %f \n",ErrorY);
    printf("ErrorZ: %f \n",ErrorZ);
    
    fflush(NULL);

    VSPGeom().UpdateMeshes();
     
}

/*##############################################################################
#                                                                              #
#               VSP_SOLVER TestPartialResdiual_pMesh_Full                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestPartialResdiual_pMesh_Full(void)
{

    int i, j, k;
    int d_size;
    double Eps;
    double Error, L2Error, *Res0, dR_dMesh, Dot;
    double dF_dx_exact, dF_dy_exact, dF_dz_exact;
    double dF_dx_fd, dF_dy_fd, dF_dz_fd;
    double **FastMatrix, **FDMatrix, *TempPsi;

    Res0 = new double[NumberOfEquations_ + 1];
    
    FastMatrix = new double*[NumberOfEquations_ + 1];
    
      FDMatrix = new double*[NumberOfEquations_ + 1];
    
       TempPsi = new double[NumberOfEquations_ + 1]; 

    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
       
       FastMatrix[i] = new double[3*NumberOfEquations_ + 1];

         FDMatrix[i] = new double[3*NumberOfEquations_ + 1];

         TempPsi[i] = CurrentPsi_[i];
         
          TempPsi[i] =  1.;
    }
    
    // Calculate fast Psi_T x pR_Mesh matrix
    
    zero_double_array(CurrentPsi_, NumberOfEquations_);

    printf("\n\n");        
    printf("Fast Matrix calculations... \n");

if ( 1 ) {    
   
    int Start = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + VSPGeom().NumberOfWakeResidualEquations();
   
   for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
//     for ( i = Start + 1  ; i <= NumberOfEquations_ ; i++ ) {

       printf("Working on Equation: %d out of %d \r",i,NumberOfEquations_);fflush(NULL);
    
       CurrentPsi_[i - 1] = 0.;                             
       CurrentPsi_[i    ] = 1.;
       
       CalculatePsiT_PartialResidualPartialMesh();
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; j++ ) {
          
          FastMatrix[i][3*j-2] = PsiT_pR_pMesh_[3*j-2];
          FastMatrix[i][3*j-1] = PsiT_pR_pMesh_[3*j-1];
          FastMatrix[i][3*j  ] = PsiT_pR_pMesh_[3*j  ];
          
       }
       
    }

    VSPGeom().UpdateMeshes();
    
    InitializeFreeStream();
    
    CalculateResidual();       
    
    // Grab the current residual
    
    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
       
       Res0[i] = -Residual_[i];
  
    }

    // Calculate perturbations

    Eps = 1.e-6;
 
    // Perturb the surface mesh

    printf("\n\n");    
    printf("FD calculations... \n");
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; i++ ) {

       printf("Working on Node: %d out of %d \r",i,VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes());fflush(NULL);
       
       // X
       
          VSPGeom().Grid(0).NodeList(i).x() += Eps;
          
          VSPGeom().UpdateMeshes();
          
          // Caculate perturbed residual
          
          CalculateResidual();       
          
          Dot = 0.;
          
          for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
             
             dR_dMesh = ( -Residual_[j] - Res0[j] )/Eps;
             
             FDMatrix[j][3*i-2] = dR_dMesh;
             
          }     

          VSPGeom().Grid(0).NodeList(i).x() -= Eps;
       
       // Y
       
          VSPGeom().Grid(0).NodeList(i).y() += Eps;
          
          VSPGeom().UpdateMeshes();
          
          // Caculate perturbed residual
          
          CalculateResidual();       
          
          Dot = 0.;
          
          for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
             
             dR_dMesh = ( -Residual_[j] - Res0[j] )/Eps;
             
             FDMatrix[j][3*i-1] = dR_dMesh;
             
          }     

          VSPGeom().Grid(0).NodeList(i).y() -= Eps;       
          
       // Z
       
          VSPGeom().Grid(0).NodeList(i).z() += Eps;
          
          VSPGeom().UpdateMeshes();
          
          // Caculate perturbed residual
          
          CalculateResidual();       
          
          Dot = 0.;
          
          for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
             
             dR_dMesh = ( -Residual_[j] - Res0[j] )/Eps;
             
             FDMatrix[j][3*i  ] = dR_dMesh;
             
          }     

          VSPGeom().Grid(0).NodeList(i).z() -= Eps;       

    }

    VSPGeom().UpdateMeshes();
    
}

    // Compare the two...
    
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() ; j++ ) {
    
       if ( 1 ) {
          
          for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
                
             printf("pR_pMesh(%d,%d) --> @ Loop XYZ: %f %f %f ----> Exact: %f %f %f ... FD: %f %f %f \n",
             i,
             j,
             VSPGeom().Grid(MGLevel_).LoopList(i).Xc(),
             VSPGeom().Grid(MGLevel_).LoopList(i).Yc(),
             VSPGeom().Grid(MGLevel_).LoopList(i).Zc(),
             FastMatrix[i][3*j-2]*TempPsi[i],
             FastMatrix[i][3*j-1]*TempPsi[i],
             FastMatrix[i][3*j  ]*TempPsi[i],
               FDMatrix[i][3*j-2]*TempPsi[i],
               FDMatrix[i][3*j-1]*TempPsi[i],
               FDMatrix[i][3*j  ]*TempPsi[i]);
         
          }
          
          Error = sqrt( pow(FastMatrix[i][3*j-2]*TempPsi[i] - FDMatrix[i][3*j-2]*TempPsi[i],2.)
                      + pow(FastMatrix[i][3*j-1]*TempPsi[i] - FDMatrix[i][3*j-1]*TempPsi[i],2.)
                      + pow(FastMatrix[i][3*j-0]*TempPsi[i] - FDMatrix[i][3*j-0]*TempPsi[i],2.) );
                      
          if ( Error > 0.01 ) printf("........................................................................... wtf! \n");
          
          
       }
       
       if ( 1 ) {
       
          for ( k = VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() + 1 ;  k <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; k++ ) {
                    
             // X
                       
             i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(k - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 2;
             
             printf("pR_pMesh(%d,%d) --> @ Xeqn for Node XYZ: %f %f %f ----> Exact: %f %f %f ... FD: %f %f %f \n",
             i,
             j,
             VSPGeom().Grid(MGLevel_).NodeList(k).x(),
             VSPGeom().Grid(MGLevel_).NodeList(k).y(),
             VSPGeom().Grid(MGLevel_).NodeList(k).z(),
             FastMatrix[i][3*j-2]*TempPsi[i],
             FastMatrix[i][3*j-1]*TempPsi[i],
             FastMatrix[i][3*j  ]*TempPsi[i],
               FDMatrix[i][3*j-2]*TempPsi[i],
               FDMatrix[i][3*j-1]*TempPsi[i],
               FDMatrix[i][3*j  ]*TempPsi[i]);

             Error = sqrt( pow(FastMatrix[i][3*j-2]*TempPsi[i] - FDMatrix[i][3*j-2]*TempPsi[i],2.)
                         + pow(FastMatrix[i][3*j-1]*TempPsi[i] - FDMatrix[i][3*j-1]*TempPsi[i],2.)
                         + pow(FastMatrix[i][3*j-0]*TempPsi[i] - FDMatrix[i][3*j-0]*TempPsi[i],2.) );
                         
             if ( Error > 0.01 ) printf("........................................................................... wtf! \n");
                              
             // Y
                       
             i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(k - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 1;
             
             printf("pR_pMesh(%d,%d) --> @ Yeqn for Node XYZ: %f %f %f ----> Exact: %f %f %f ... FD: %f %f %f \n",
             i,
             j,
             VSPGeom().Grid(MGLevel_).NodeList(k).x(),
             VSPGeom().Grid(MGLevel_).NodeList(k).y(),
             VSPGeom().Grid(MGLevel_).NodeList(k).z(),
             FastMatrix[i][3*j-2]*TempPsi[i],
             FastMatrix[i][3*j-1]*TempPsi[i],
             FastMatrix[i][3*j  ]*TempPsi[i],
               FDMatrix[i][3*j-2]*TempPsi[i],
               FDMatrix[i][3*j-1]*TempPsi[i],
               FDMatrix[i][3*j  ]*TempPsi[i]);             

             Error = sqrt( pow(FastMatrix[i][3*j-2]*TempPsi[i] - FDMatrix[i][3*j-2]*TempPsi[i],2.)
                         + pow(FastMatrix[i][3*j-1]*TempPsi[i] - FDMatrix[i][3*j-1]*TempPsi[i],2.)
                         + pow(FastMatrix[i][3*j-0]*TempPsi[i] - FDMatrix[i][3*j-0]*TempPsi[i],2.) );
                         
             if ( Error > 0.01 ) printf("........................................................................... wtf! \n");
   
             // Z
                       
             i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(k - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 0;
             
             printf("pR_pMesh(%d,%d) --> @ Zeqn for Node XYZ: %f %f %f ----> Exact: %f %f %f ... FD: %f %f %f \n",
             i,
             j,
             VSPGeom().Grid(MGLevel_).NodeList(k).x(),
             VSPGeom().Grid(MGLevel_).NodeList(k).y(),
             VSPGeom().Grid(MGLevel_).NodeList(k).z(),
             FastMatrix[i][3*j-2]*TempPsi[i],
             FastMatrix[i][3*j-1]*TempPsi[i],
             FastMatrix[i][3*j  ]*TempPsi[i],
               FDMatrix[i][3*j-2]*TempPsi[i],
               FDMatrix[i][3*j-1]*TempPsi[i],
               FDMatrix[i][3*j  ]*TempPsi[i]);     

             Error = sqrt( pow(FastMatrix[i][3*j-2]*TempPsi[i] - FDMatrix[i][3*j-2]*TempPsi[i],2.)
                         + pow(FastMatrix[i][3*j-1]*TempPsi[i] - FDMatrix[i][3*j-1]*TempPsi[i],2.)
                         + pow(FastMatrix[i][3*j-0]*TempPsi[i] - FDMatrix[i][3*j-0]*TempPsi[i],2.) );
                         
             if ( Error > 0.01 ) printf("........................................................................... wtf! \n");

                           
          }
          
       }
       
       if ( 1 ) {

          for ( k = 1 ; k <= VSPGeom().NumberOfStallResidualEquations() ; k++ ) {
             
             i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + VSPGeom().NumberOfWakeResidualEquations() + k;
             
             printf("pR_pMesh(%d,%d) --> @ Stall eqn for Node XYZ: %f %f %f ----> Exact: %f %f %f ... FD: %f %f %f \n",
             i,
             j,
             VSPGeom().Grid(MGLevel_).NodeList(j).x(),
             VSPGeom().Grid(MGLevel_).NodeList(j).y(),
             VSPGeom().Grid(MGLevel_).NodeList(j).z(),
             FastMatrix[i][3*j-2]*TempPsi[i],
             FastMatrix[i][3*j-1]*TempPsi[i],
             FastMatrix[i][3*j  ]*TempPsi[i],
               FDMatrix[i][3*j-2]*TempPsi[i],
               FDMatrix[i][3*j-1]*TempPsi[i],
               FDMatrix[i][3*j  ]*TempPsi[i]);

             Error = sqrt( pow(FastMatrix[i][3*j-2]*TempPsi[i] - FDMatrix[i][3*j-2]*TempPsi[i],2.)
                         + pow(FastMatrix[i][3*j-1]*TempPsi[i] - FDMatrix[i][3*j-1]*TempPsi[i],2.)
                         + pow(FastMatrix[i][3*j-0]*TempPsi[i] - FDMatrix[i][3*j-0]*TempPsi[i],2.) );
                         
             if ( Error > 0.01 ) printf("........................................................................... wtf! \n");
               
          }
              
       }
       
    }
    
}

/*##############################################################################
#                                                                              #
#                    VSP_SOLVER TestPartialResdiual_pVinf                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestPartialResdiual_pVinf(void)
{

    int i, EqnX, EqnY, EqnZ;
    double pResidual_pVinf[3][3], pResidual_pVinf_FD[3][3], *Res0, Eps;
    
    Res0 = new double[NumberOfEquations_ + 1];

    // Grab the current residual
    
    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
       
       Res0[i] = -Residual_[i];
       
       Residual_[i] = 0;
  
    }

    // Calculate perturbations

    Eps = 1.e-7;
 
    // Perturb the wake mesh
    
    for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() + 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
       
       if ( VSPGeom().Grid(MGLevel_).EdgeList(i).IsWakeEdge() ) {

          EqnX = VSPGeom().Grid(MGLevel_).EdgeList(i).WakeEdgeData().WakeResidualEquationNumberForX();
          EqnY = VSPGeom().Grid(MGLevel_).EdgeList(i).WakeEdgeData().WakeResidualEquationNumberForY();
          EqnZ = VSPGeom().Grid(MGLevel_).EdgeList(i).WakeEdgeData().WakeResidualEquationNumberForZ();
          
          // Exact
          
          VSPGeom().Grid(MGLevel_).EdgeList(i).Wake_pResidual_pVinf(pResidual_pVinf);
          
          // Finite diff
          
          VSPGeom().Grid(MGLevel_).EdgeList(i).Velocity()[0] += Eps;
          
          VSPGeom().Grid(MGLevel_).EdgeList(i).CalculateWakeResidual(Residual_);
          
          pResidual_pVinf_FD[0][0] = ( -Residual_[EqnX] - Res0[EqnX] )/Eps;
          pResidual_pVinf_FD[1][0] = ( -Residual_[EqnY] - Res0[EqnY] )/Eps;
          pResidual_pVinf_FD[2][0] = ( -Residual_[EqnZ] - Res0[EqnZ] )/Eps;
          
          VSPGeom().Grid(MGLevel_).EdgeList(i).Velocity()[0] -= Eps;
          
          printf("Edge: %d pResidual_pVinf[0][0] --> Exact: %f ... FD: %f \n",
          i,
             pResidual_pVinf[0][0],
          pResidual_pVinf_FD[0][0]);

          printf("Edge: %d pResidual_pVinf[1][0] --> Exact: %f ... FD: %f \n",
          i,
             pResidual_pVinf[1][0],
          pResidual_pVinf_FD[1][0]);
          
          printf("Edge: %d pResidual_pVinf[2][0] --> Exact: %f ... FD: %f \n",
          i,
             pResidual_pVinf[2][0],
          pResidual_pVinf_FD[2][0]);
          
          printf("\n\n");
                              
       }


    }

}

/*##############################################################################
#                                                                              #
#                        VSP_SOLVER TestJacobianMatrix                         #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestJacobianMatrix(void)
{

    int i, j, k, p, q, r, Loop;
    int d_size;
    double Eps, Error;
    double *Res0, *ResM, *Vec, *Delta, **J1, **J2;
    
    J1 = new double*[NumberOfEquations_ + 1];
    J2 = new double*[NumberOfEquations_ + 1];
    
    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
       
       J1[i] = new double[NumberOfEquations_ + 1]; 
       J2[i] = new double[NumberOfEquations_ + 1]; 
       
    }

    Res0  = new double[NumberOfEquations_ + 1];
    ResM  = new double[NumberOfEquations_ + 1];
    
    Delta = new double[NumberOfEquations_ + 1];
    Vec   = new double[NumberOfEquations_ + 1];

    // Finite difference Jacobian

    CalculateResidual();
    
    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
       
       Res0[i] = -Residual_[i];

    }
    
    Eps = 1.e-7;

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
       
       printf("Working on loop %d out of %d \n",i,VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops());fflush(NULL);
       
       Gamma(i) += Eps;
       
       CalculateResidual();
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
          
          J1[j][i] = (-Residual_[j] - Res0[j])/Eps;
          
       }
       
       Gamma(i) -= Eps;
       
    }
    
    Eps = 1.e-7;

    for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() + 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       printf("Working on node %d out of %d \n",i,VSPGeom().Grid(MGLevel_).NumberOfNodes());fflush(NULL);
       
       // X
       
       VSPGeom().Grid(0).NodeList(i).x() += Eps;
       
       VSPGeom().UpdateSurfacesMeshes();
       
       CalculateResidual();
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
          
          k = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(i-VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 2;
          
          J1[j][k] = (-Residual_[j] - Res0[j])/Eps;
          
       }
       
       VSPGeom().Grid(0).NodeList(i).x() -= Eps;

       // Y

       VSPGeom().Grid(0).NodeList(i).y() += Eps;
       
       VSPGeom().UpdateSurfacesMeshes();
       
       CalculateResidual();
       
      // for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
      //    
      //    ResM[j] = -Residual_[j];
      //
      // }
      //
      // VSPGeom().Grid(0).NodeList(i).y() += 2.*Eps;
      // 
      // VSPGeom().UpdateSurfacesMeshes();
      // 
      // CalculateResidual();
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
          
          k = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(i-VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 1;
          
          J1[j][k] = (-Residual_[j] - Res0[j])/(Eps);

       }
       
       VSPGeom().Grid(0).NodeList(i).y() -= Eps;
                 
       // Z
       
       VSPGeom().Grid(0).NodeList(i).z() += Eps;
       
       VSPGeom().UpdateSurfacesMeshes();
       
       CalculateResidual();
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
          
          k = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(i-VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 0;
          
          J1[j][k] = (-Residual_[j] - Res0[j])/Eps;
          
       }
       
       VSPGeom().Grid(0).NodeList(i).z() -= Eps;    
              
    }
    
    VSPGeom().UpdateMeshes();

    if ( DoSymmetryPlaneSolve_ ) {
       
       for ( j = VSPGeom().Grid(0).NumberOfSurfaceNodes() + 1 ; j <= VSPGeom().Grid(0).NumberOfNodes() ; j++ ) {
          
          if ( VSPGeom().Grid(0).NodeList(j).IsSymmetryPlaneNode() ) {
   
             k = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(j-VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 1;
   
             for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
   
                 J1[i][k] = 0.;
                
             }
   
          }
          
       }
       
    }
       
       
       
//    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
//       
//       // BC at wing trailing edge .. XYZ_wake = XYZ_TE
//       
//       for ( q = 1 ; q <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; q++ ) {
//
//          p = VSPGeom().VortexSheet(k).TrailingVortex(q).GlobalNode(1) - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes();
//          
//          for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
//             
//             r = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*p - 2;
//             
//        //     J1[j][r] = 999.;
//        //  
//        //     r = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*p - 1;
//        //     
//        //     J1[j][r] = 999.;
//        //     
//        //     r = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*p - 0;
//        //     
//        //     J1[j][r] = 999.;
//             
//          }
//          
//       }
//        
//    }
    
    if ( StallModelIsOn_ ) {
                                       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          printf("Working vortex sheet: %d stall factors \n",k);fflush(NULL);
          
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() += Eps;
             
             CalculateResidual();

             p = VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber();
             
             for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
                              
               J1[j][p] = (-Residual_[j] - Res0[j])/Eps;
               
             }         
    
             VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() -= Eps;
             
          }
          
       }
       
    }
    
    else {

       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
   
             p = VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber();
   
             for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
               
               J1[j][p] = 0.;
               
               if ( j == p ) {
                  
                  J1[j][p] = 1.;
 
               }
               
             }         
    
          }
          
       }
              
    }

    // Vortex stretching ratio equations
    
    if ( TimeAccurate_ ) {
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          printf("Working vortex sheet: %d out of %d stretching ratio \n",k,VSPGeom().NumberOfVortexSheets());fflush(NULL);
       
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
             
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
              
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() += Eps;
                
                CalculateResidual();
                
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() -= Eps;
                
                p = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
                
                for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
                                 
                  J1[j][p] = (-Residual_[j] - Res0[j])/Eps;
                  
                }                      
                
             }
             
             else {
                
                p = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
                
                for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
                                 
                   J1[j][p] = 0.;
                
                   if ( j == p ) {
                      
                      J1[j][p] = 1.;
                   
                   }
                  
                }                      
                                
             }
             
          }
          
       }          
       
    }
        
    // Exact Jacobian
    
    zero_double_array(Delta,NumberOfEquations_);

    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {

       printf("Working exact jacobian for equation: %d out of %d \n",i,NumberOfEquations_);fflush(NULL);
       
       Delta[i-1] = 0.;
       Delta[i  ] = 1.;
       
       DoForwardMatrixMultiply(Delta, Vec);       
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
          
          J2[j][i] = Vec[j];
          
       }
              
    }
    
    // Compare surface equations
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
          
          Error = ABS(J1[i][j] - J2[i][j]);
          
          if ( Error > 0.01 ) {
             
             printf("Surface Loop Eqn ---> %d,%d --> J1,2: %f % f <--------wtf \n",i,j,J1[i][j],J2[i][j]);
             
          }
          
          else {
          
             printf("Surface Loop Eqn ---> %d,%d --> J1,2: %f % f \n",i,j,J1[i][j],J2[i][j]);
             
          }
                    
       }

    }

    // Compare wake equations

    for ( p = VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes() + 1 ; p <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; p++ ) {
              
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
          
          printf("wake node: %d \n",p - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes());
          
          // X
       
          i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(p - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 2;
          
          Error = ABS(J1[i][j] - J2[i][j]);
          
          if ( Error > 0.01 ) {
             
             printf("Wake X Node --> %d,%d --> J1,2: %f % f <--------wtf \n",i,j,J1[i][j],J2[i][j]);
             
          }
          
          else {
          
             printf("Wake X Node --> %d,%d --> J1,2: %f % f \n",i,j,J1[i][j],J2[i][j]);
             
          }

          // Y

          i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(p - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 1;
          
          Error = ABS(J1[i][j] - J2[i][j]);
          
          if ( Error > 0.01 ) {
             
             printf("Wake Y Node --> %d,%d --> J1,2: %f % f <--------wtf \n",i,j,J1[i][j],J2[i][j]);
             
          }
          
          else {
          
             printf("Wake Y Node --> %d,%d --> J1,2: %f % f \n",i,j,J1[i][j],J2[i][j]);
             
          }
          
          // Z
         
          i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 3*(p - VSPGeom().Grid(MGLevel_).NumberOfSurfaceNodes()) - 0;
          
          Error = ABS(J1[i][j] - J2[i][j]);
          
          if ( Error > 0.01 ) {
             
             printf("Wake Z Node --> %d,%d --> J1,2: %f % f <--------wtf \n",i,j,J1[i][j],J2[i][j]);
             
          }
          
          else {
          
             printf("Wake Z Node --> %d,%d --> J1,2: %f % f \n",i,j,J1[i][j],J2[i][j]);
             
          }
                                        
       }

    }

    // Compare stall equations

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {

          p = VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber();

          for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
            
             Error = ABS(J1[p][j] - J2[p][j]);
             
             if ( Error > 0.01 ) {
                
                printf("Stall equation --> %d,%d --> J1,2: %f % f <--------wtf \n",i,j,J1[p][j],J2[p][j]);
                
             }
             
             else {
             
                printf("Stall equation --> %d,%d --> J1,2: %f % f \n",i,j,J1[p][j],J2[p][j]);
                
             }
               
          }         
 
       }
    }

    // Compare vortex stretching ratio equations
    
    if ( TimeAccurate_ ) {
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          printf("Working vortex sheet: %d out of %d stretching ratio \n",k,VSPGeom().NumberOfVortexSheets());fflush(NULL);
       
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
             
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
              
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() += Eps;
                
                CalculateResidual();
                
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() -= Eps;
                
                p = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
                
                for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
                  
                   Error = ABS(J1[p][j] - J2[p][j]);
                   
                   if ( Error > 0.01 ) {
                      
                      printf("Vortex stretching equation --> %d,%d --> J1,2: %f % f <--------wtf \n",i,j,J1[p][j],J2[p][j]);
                      
                   }
                   
                   else {
                   
                      printf("Vortex stretching equation --> %d,%d --> J1,2: %f % f \n",i,j,J1[p][j],J2[p][j]);
                      
                   }
                     
                }                    
                
             }
             
             else {
                
                p = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber();
                
                Error = ABS(J1[p][j] - J2[p][j]);
                
                if ( Error > 0.01 ) {
                   
                   printf("Vortex stretching equation --> %d,%d --> J1,2: %f % f <--------wtf \n",i,j,J1[p][j],J2[p][j]);
                   
                }
                
                else {
                
                   printf("Vortex stretching equation --> %d,%d --> J1,2: %f % f \n",i,j,J1[p][j],J2[p][j]);
                   
                }                
                                
             }
             
          }
          
       }          
       
    }
                
}

/*##############################################################################
#                                                                              #
#                        VSP_SOLVER TestMatrixPreconditioner                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::TestMatrixPreconditioner(void)
{

    int i, j, k, p, q, r, Neq, ii, jj;
    int d_size;
    double Eps, Error;
    double *Vec, *Delta, **J2;
    
    J2 = new double*[NumberOfEquations_ + 1];
    
    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
       
       J2[i] = new double[NumberOfEquations_ + 1]; 
       
    }

    Delta = new double[NumberOfEquations_ + 1];
    Vec   = new double[NumberOfEquations_ + 1];
 
    // Exact Jacobian
    
    zero_double_array(Delta,NumberOfEquations_);

    for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {

       printf("Working exact jacobian for equation: %d out of %d \n",i,NumberOfEquations_);fflush(NULL);
       
       Delta[i-1] = 0.;
       Delta[i  ] = 1.;
       
       DoForwardMatrixMultiply(Delta, Vec);       
       
       for ( j = 1 ; j <= NumberOfEquations_ ; j++ ) {
          
          J2[j][i] = Vec[j];
          
       }
              
    }
    
    
    for ( k = 1 ; k <= NumberOfVortexLoopMatrixPreconditioners_ ; k++ ) {
      
       Neq = VortexLoopMatrixPreconditionerList_[k].NumberOfVortexLoops();

       printf("Matrix precon: %d \n",k);fflush(NULL);
       
       for ( i = 1 ; i <= Neq ; i++ ) {

          ii = VortexLoopMatrixPreconditionerList_[k].VortexLoopList(i);
          
          for ( j = 1 ; j <= Neq ; j++ ) {
             
             jj = VortexLoopMatrixPreconditionerList_[k].VortexLoopList(j);
            
             Error = ABS(VortexLoopMatrixPreconditionerList_[k].A()(i,j) - J2[ii][jj]);
             
             if ( Error > 0.0001 ) {
                
                printf("%d, %d --> exact: %f ... matprecon: %f  <--------wtf \n",i,j,J2[ii][jj],VortexLoopMatrixPreconditionerList_[k].A()(i,j));
                
             }
             
             else {
             
                printf("%d, %d --> exact: %f ... matprecon: %f \n",i,j,J2[ii][jj],VortexLoopMatrixPreconditionerList_[k].A()(i,j));
                
             }
                 
             
          }
          
       }      
       
    }        

            
}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER CalculateResidual                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateResidual(void)
{

    int i, j, k, p, q, Edge, Sign, Loop, KelvinEquationOffSet, im, ip;
    double Dot, Gamma, Chord, Velocity, Cl_Ratio;
    double Fstall, pFstall_pX, StallFactor, DeltaStallFactor;
    double Ratio;
    
    // Zero out residuals
    
    L2Residual_ = MaxResidual_ = 0.;
    
    // Calculate the loop and edge velocities
     
    CalculateVelocities(ALL_WAKE_GAMMAS);

    zero_double_array(Residual_, NumberOfEquations_);

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
    
       Residual_[i] = -vector_dot(VSPGeom().Grid(MGLevel_).LoopList(i).Normal(), VSPGeom().Grid(MGLevel_).LoopList(i).Velocity());

    }

    // Implicit wake equations
    
    if ( ImplicitWake_ && CurrentWakeIteration_ >= ImplicitWakeStartIteration_ ) {

       // Wake residuals
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
  
          VSPGeom().VortexSheet(k).CalculateWakeResidual(Residual_);
          
       }

       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
          // BC at wing trailing edge .. XYZ_wake = XYZ_TE
          
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             p = VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Node();
             
             q = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(1);

             Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberX(1)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).x() - VSPGeom().Grid(MGLevel_).NodeList(p).x());
             Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberY(1)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).y() - VSPGeom().Grid(MGLevel_).NodeList(p).y());
             Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberZ(1)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).z() - VSPGeom().Grid(MGLevel_).NodeList(p).z());

          }
          
          // Last wake segment
          
          if ( !TimeAccurate_ ) {
             
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
                j = VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes();
             
                q = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j);
             
                Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberX(j)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).x() - VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j));
                Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberY(j)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).y() - VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j));
                Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberZ(j)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).z() - VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j));
                
             }
                       
             // Concave regions
             
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
   
                 im = i - 1;
                 ip = i + 1;
                 
                 if ( i == 1 ) im = i;
                 if ( i == VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ) ip = i;
                      
                 if ( VSPGeom().VortexSheet(k).TrailingVortex(im).IsFrozenTrailingEdge() ) {
                               
                   for ( j = 1 ; j <= VSPGeom().VortexSheet(k).TrailingVortex(i).NumberOfNodes() ; j++ ) {
                   
                      q = VSPGeom().VortexSheet(k).TrailingVortex(i).GlobalNode(j);
   
                      Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberX(j)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).x() - VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeX(j));
                      Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberY(j)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).y() - VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeY(j));
                      Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).WakeResidualEquationNumberZ(j)] = -(VSPGeom().Grid(MGLevel_).NodeList(q).z() - VSPGeom().VortexSheet(k).TrailingVortex(i).WakeNodeZ(j));
                      
                   }
                  
                }
                
             }
             
          }
                 
       }

       // Stall equations
                                  
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
             
             Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
             
             Gamma = Sign * VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma();
             
             Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
             
             Velocity = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[0], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[1], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[2], 2.) );
          
             Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()] = 0.;

             if ( StallModelIsOn_ && Velocity > 0. ) {
                
                Cl_Ratio = Gamma / ( 0.5 * Chord * Velocity * Clmax_2d_ );

                StallFactor = VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor();
                  
                StallFunction(ABS(Cl_Ratio),Fstall,pFstall_pX);
                                
                Residual_[VSPGeom().VortexSheet(k).TrailingVortex(i).KuttaStallEquationNumber()] = -(StallFactor - Fstall);

             }
             
          }
          
       }
       
       // Vortex stretching ratio equations
       
       if ( TimeAccurate_ ) {
          
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
                
                if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 && VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
                 
                   Ratio = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio();
                   
                   Residual_[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()] = -(Ratio * VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1) - VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(0));
  
                }
                
                else {
                   
                   Residual_[VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatioEquationNumber()] = 0.;
                   
                }
                
             }
             
          }          
          
       }
        
    }
    
    // Explicit wake
    
    else {

       // Wake residuals
       
       if ( DoAdjointSolve_ ) {
          
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
          
             VSPGeom().VortexSheet(k).CalculateWakeResidual(Residual_);
             
          }

       }
       
       for ( i = VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() + 1 ; i <= NumberOfEquations_ ; i++ ) {
          
          Residual_[i] = 0.;
          
       }

       // Stall equations
                 
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
             
             Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
             
             Gamma = -Sign * VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma();
             
             Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
             
             Velocity = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[0], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[1], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[2], 2.) );
                          
             if ( StallModelIsOn_ && Velocity > 0. ) {
                
                Cl_Ratio = Gamma / ( 0.5 * Chord * Velocity * Clmax_2d_ );
               
                StallFunction(ABS(Cl_Ratio),StallFactor,pFstall_pX);

                DeltaStallFactor = StallFactor - VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor();
                
                VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor() += 0.25*DeltaStallFactor;
                
                L2Residual_ += DeltaStallFactor*DeltaStallFactor;
                
                MaxResidual_ = MAX(MaxResidual_,ABS(DeltaStallFactor));
            
             }                             
             
          }
          
       }
       
       // Calculate stall factors for each trailing vortex loop
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             j = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaEdge();
           
             VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor() = VSPGeom().VortexSheet(k).TrailingVortex(j).StallFactor();

          }
       
       }          
                
    }

    if ( NumberOfKelvinConstraints_ > 0 ) {

       // Kelvin regularization
    
       for ( k = 0 ; k <= NumberOfKelvinConstraints_ ; k++ ) {
          
          KelvinGroupSum_[k] = 0.;
         
       }
       
       // Surface vorticity
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
   
          KelvinGroupSum_[LoopInKelvinConstraintGroup_[i]] += KelvinLambda_ * Vref_ * VSPGeom().Grid(MGLevel_).LoopList(i).Gamma();
          
       }

       // Trailing vorticity
       
       //for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       //
       //   for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
       //      
       //      Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
       //      
       //      Sign = SGN(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
       //      
       //      Gamma = Sign * VSPGeom().Grid(MGLevel_).EdgeList(Edge).Gamma();
       //      
       //      Loop = VSPGeom().Grid(MGLevel_).EdgeList(Edge).LoopL();
       //      
       //      KelvinGroupSum_[LoopInKelvinConstraintGroup_[Loop]] += KelvinLambda_ * Vref_ * Gamma;
       //
       //   }
       //   
       //}

       // Add regularization term into (-) residual
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
   
          Residual_[i] -= KelvinGroupSum_[LoopInKelvinConstraintGroup_[i]];

       }
       
    }
    
    // Loop over residual vector and calculate max/l2 residuals for the implicit case
    
    if ( ImplicitWake_ && CurrentWakeIteration_ >= ImplicitWakeStartIteration_ ) {

       L2Residual_ = MaxResidual_ = 0.;
 
       for ( i = 1 ; i <= NumberOfEquations_ ; i++ ) {
     
          MaxResidual_ = MAX(MaxResidual_, ABS(Residual_[i]));
          
          L2Residual_ += Residual_[i]*Residual_[i];
         
       }

    }
    
    // For the explicit case we only loop over ... the surface loops. The wake
    // residuals are calculate later...
    
    else {
       
       // Residuals for the surface panels
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
       
          MaxResidual_ = MAX(MaxResidual_, ABS(Residual_[i]));
       
          L2Residual_ += Residual_[i]*Residual_[i];
       
       }
       
    }           

}

/*##############################################################################
#                                                                              #
#                             StallFunction                                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::StallFunction(double X, double &F, double &pF_pX)
{
   
    double Xc, Edge0, Edge1, pXc_pX, pF_pXc;
    
    Edge0 = 0.95;
    Edge1 = 2.;
    
    Xc = (X - Edge0)/(Edge1 - Edge0);
    
    pXc_pX = 1./(Edge1 - Edge0);
    
    if ( Xc < 0. ) Xc = 0.;
    if ( Xc > 1. ) Xc = 1.;
    
    F = 1. - ( Xc * Xc * (3. - 2.*Xc) );
    
    pF_pXc = -6.*Xc + 6.*Xc*Xc;
    
    pF_pX = pF_pXc * pXc_pX;

}

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER GMRES_Solver                              #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::GMRES_Solver(int Neq,                       // Number of Equations, 0 <= i < Neq
                              int IterMax,                   // Max number of outer iterations
                              int NumRestart,                // Max number of inner (restart) iterations
                              int Verbose,                   // Output flag, verbose = 0, or 1
                              double *x,             // Initial guess and solution vector
                              double *RightHandSide, // Right hand side of Ax = b
                              double ErrorMax,       // Maximum error tolerance
                              double ErrorReduction, // Residual reduction factor
                              double &ResFinal,      // Final log10 of residual reduction
                              int    &IterFinal)             // Final iteration count
{

    int i, j, k, Iter, Done, TotalIterations;

    double av, *c, Epsilon, *g, **h, Dot, Mu, *r;
    double rho, rho_zero, rho_tol, rho_ratio, *s, **v, *y, NowTime;
    
    Epsilon = 1.0e-03;
    
    TotalIterations = 0;

    // Allocate memory
    
    c = new double[NumRestart + 1];
    g = new double[NumRestart + 1];
    s = new double[NumRestart + 1];
    y = new double[NumRestart + 1];

    h = new double*[NumRestart + 1];

    for ( i = 0 ; i <= NumRestart ; i++ ) {

       h[i] = new double[NumRestart + 1];

    }

    v = new double*[NumRestart + 1];

    for ( i = 0 ; i <= NumRestart ; i++ ) {

       v[i] = new double[Neq + 1];

    }

    r = new double[Neq + 1];

    // Check for case were we come in converged already

    DoPreconditionedMatrixMultiply(x,r);
    
    for ( i = 0; i < Neq; i++ ) {

      r[i] = RightHandSide[i] - r[i];
     
    }

    rho = sqrt(VectorDot(Neq,r,r));

    Iter = 0;

    rho_tol = 0.;

    if ( rho <= rho_tol && rho <= ErrorMax ) return;
          
    // Outer iterative loop

    rho = 1.e9;

    rho_zero = rho;

    Done = 0;

    while ( Iter < IterMax && ( ( rho > rho_tol || rho > ErrorMax ) && !Done ) ) {

      // Matrix Multiplication

      DoPreconditionedMatrixMultiply(x,r);

      for ( i = 0; i < Neq; i++ ) {

        r[i] = RightHandSide[i] - r[i];
 
      }

      rho = sqrt(VectorDot(Neq,r,r));

      if ( Iter == 0 ) rho_zero = rho;

      if ( Iter == 0 ) rho_tol = rho * ErrorReduction;

      rho_ratio = rho / rho_zero;
    
      if ( AdjointMatrixSolve_ ) {
     
         printf("GMRES Iter: %5d ... Red: %10.5f / %-10.5f ...  Max: %10.5f / %-10.5f \r", 0,float(log10(rho_ratio)),float(log10(ErrorReduction)), float(log10(rho)), float(log10(ErrorMax))); fflush(NULL);

      }
               
      else {
         
         if ( Verbose && Iter == 0 && !TimeAccurate_ ) printf("Wake Iter: %5d / %-5d ... GMRES Iter: %5d ... Red: %10.5f / %-10.5f ...  Max: %10.5f / %-10.5f ... KTRes: %-10.5f \r",CurrentWakeIteration_, WakeIterations_, 0,float(log10(rho_ratio)),float(log10(ErrorReduction)), float(log10(rho)), float(log10(ErrorMax)), KTResidual_[1]); fflush(NULL);
         if ( Verbose && Iter == 0 &&  TimeAccurate_ ) printf("TStep: %-5d / %-5d ... Time: %10.5f ... GMRES Iter: %5d ... Red: %10.5f / %-10.5f ...  Max: %-10.5f / %10.5f ... KTRes: %-10.5f \r",Time_,NumberOfTimeSteps_,CurrentTime_, 0,log10(rho_ratio),log10(ErrorReduction), log10(rho), log10(ErrorMax), KTResidual_[1]); fflush(NULL);
          
      }
      
      for ( i = 0; i < Neq; i++ ) {
      
         v[0][i] = r[i] / rho;
      
      }
    
      g[0] = rho;

      for ( i = 1; i < NumRestart + 1; i++ ) {

        g[i] = 0.0;

      }
    
      for ( i = 0; i < NumRestart + 1; i++ ) {

         for ( j = 0; j < NumRestart; j++ ) {

            h[i][j] = 0.0;
        
         }

      }

      k = 0;

      while ( k < NumRestart && ( ( k == 0 || rho > rho_tol || rho > ErrorMax ) && !Done )  ) {

         // Matrix multiply
     
         DoPreconditionedMatrixMultiply(v[k], v[k+1]);

         av = sqrt(VectorDot(Neq,v[k+1],v[k+1]));

         for ( j = 0; j < k+1; j++ ) {

            h[j][k] = VectorDot( Neq, v[k+1], v[j] );

            for ( i = 0; i < Neq; i++ ) {
 
               v[k+1][i] = v[k+1][i] - h[j][k] * v[j][i];
 
            }

         }

   
         h[k+1][k] = sqrt ( VectorDot( Neq, v[k+1], v[k+1] ) );
    
         if ( ( av + Epsilon * h[k+1][k] ) == av ) {
           
            for ( j = 0; j < k+1; j++ )  {
 
               Dot = VectorDot( Neq, v[k+1], v[j] );
  
               h[j][k] = h[j][k] + Dot;

               for ( i = 0; i < Neq; i++ ) {
  
                  v[k+1][i] = v[k+1][i] - Dot * v[j][i];

               }
 
            }

            h[k+1][k] = sqrt ( VectorDot( Neq, v[k+1], v[k+1] ) );

         }
     
         if ( h[k+1][k] != 0.0 ) {

            for ( i = 0; i < Neq; i++ )  {
 
               v[k+1][i] = v[k+1][i] / h[k+1][k];
 
            }

         }
     
         if ( 0 < k ) {

            for ( i = 0; i < k + 2; i++ ) {
 
               y[i] = h[i][k];
 
            }
 
            for ( j = 0; j < k; j++ ) {
 
               ApplyGivensRotation( c[j], s[j], j, y );
 
            }
 
            for ( i = 0; i < k + 2; i++ ) {
 
               h[i][k] = y[i];
 
            }

         }
     
         Mu = sqrt ( h[k][k] * h[k][k] + h[k+1][k] * h[k+1][k] );

         c[k] = h[k][k] / Mu;

         s[k] = -h[k+1][k] / Mu;

         h[k][k] = c[k] * h[k][k] - s[k] * h[k+1][k];

         h[k+1][k] = 0.0;

         ApplyGivensRotation( c[k], s[k], k, g );
     
  //       rho = fabs ( g[k+1] );
         rho = ABS ( g[k+1] );

         rho_ratio = rho / rho_zero;

//         if ( Verbose && !TimeAccurate_) printf("Red: %10.5f / %-10.5f ...  Max: %10.5f / %-10.5f  \n",log10(rho_ratio),log10(ErrorReduction), log10(rho), log10(ErrorMax)); fflush(NULL);

         TotalIterations = TotalIterations + 1;
         
         NowTime = myclock();
    
         if ( AdjointMatrixSolve_ ) {
            
            printf("GMRES Iter: %5d ... Red: %10.5f / %-10.5f ...  Max: %10.5f / %-10.5f  \r",TotalIterations,float(log10(rho_ratio)),float(log10(ErrorReduction)), float(log10(rho)), float(log10(ErrorMax))); fflush(NULL);

         }
         
         else {
    
            if ( Verbose && !TimeAccurate_) printf("Wake Iter: %5d / %-5d ... GMRES Iter: %5d ... Red: %10.5f / %-10.5f ...  Max: %10.5f / %-10.5f \r",CurrentWakeIteration_,WakeIterations_,TotalIterations,float(log10(rho_ratio)),float(log10(ErrorReduction)), float(log10(rho)), float(log10(ErrorMax))); fflush(NULL);
            if ( Verbose &&  TimeAccurate_) printf("TStep: %5d / %-5d ... Time: %10.5f ... GMRES Iter: %5d ... Red: %10.5f / %-10.5f ...  Max: %10.5f / %-10.5f ... STime: %10.5f ... TotTime: %10.5f \r",Time_,NumberOfTimeSteps_,CurrentTime_,TotalIterations,log10(rho_ratio),log10(ErrorReduction), log10(rho), log10(ErrorMax), NowTime - StartSolveTime_, NowTime - StartTime_ ); fflush(NULL);

         }
         
         if ( rho <= ErrorMax && rho <= rho_tol ) Done = 1;

         k++;

      }
    
      k--;
    
      y[k] = g[k] / h[k][k];

      for ( i = k - 1; 0 <= i; i-- ) {

         y[i] = g[i];
 
         for ( j = i+1; j < k + 1; j++ ) {
 
            y[i] = y[i] - h[i][j] * y[j];
 
         }
 
         y[i] = y[i] / h[i][i];

      }

      for ( i = 0; i < Neq; i++ ) {

         for ( j = 0; j < k + 1; j++ ) {
 
            x[i] = x[i] + v[j][i] * y[j];
 
         }

       }

       Iter++;
    
    }

    IterFinal = TotalIterations;

    ResFinal = log10(rho/rho_zero);

    // Free up memory

    delete [] c;
    delete [] g;
    delete [] r;
    delete [] s;
    delete [] y;

    for ( i = 0 ; i <= NumRestart ; i++ ) {

       delete [] h[i];

    }

    delete [] h;

    for ( i = 0 ; i <= NumRestart ; i++ ) {

       delete [] v[i];

    }

    delete [] v;

    //if ( Verbose && !TimeAccurate_) sprintf(ConvergenceLine_,"Wake Iter: %5d / %-5d ... GMRES Iter: %5d ... Red: %10.5f / %-10.5f ...  Max: %10.5f / %-10.5f",CurrentWakeIteration_,WakeIterations_,TotalIterations,log10(rho/rho_zero),log10(ErrorReduction), log10(rho), log10(ErrorMax)); fflush(NULL);
    //if ( Verbose &&  TimeAccurate_) sprintf(ConvergenceLine_,"TStep: %5d / %-5d ... Time: %10.5f ... GMRES Iter: %5d ... Red: %10.5f / %-10.5f ...  Max: %10.5f / %-10.5f ... STime: %10.5f ... TotTime: %10.5f",Time_,NumberOfTimeSteps_,CurrentTime_,TotalIterations,log10(rho/rho_zero),log10(ErrorReduction), log10(rho), log10(ErrorMax), NowTime - StartSolveTime_, NowTime - StartTime_ ); fflush(NULL);

    return;

}

/*##############################################################################
#                                                                              #
#                              VSP_SOLVER VectorDot                            #
#                                                                              #
##############################################################################*/

double VSP_SOLVER::VectorDot(int Neq, double *r, double *s) 
{

    int i;
    double dot;

    dot = 0.;

#pragma omp parallel for reduction(+:dot)
    for ( i = 0 ; i < Neq ; i++ ) {

       dot += r[i] * s[i];
    
    }

    return dot;

}

/*##############################################################################
#                                                                              #
#                        VSP_SOLVER  ApplyGivensRotation                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ApplyGivensRotation(double c, double s, int k, double *g)
{

  double g1, g2;

  g1 = c * g[k] - s * g[k+1];
  g2 = s * g[k] + c * g[k+1];

  g[k]   = g1;
  g[k+1] = g2;

  return;

}

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER CalculateForces                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateForces(void)
{

    int i, j, k, p;

    // Calculate Unsteady forces
 
    if ( TimeAccurate_ ) CalculateUnsteadyForces();
   
    // Calculate forces by applying JK theorem to each edge
   
    CalculateKuttaJukowskiForces();
    
    // Calculate Delta-Cps, or surface pressures
    
    CalculateSurfacePressures();
   
    // Integrate forces and moments
   
    IntegrateForcesAndMoments();
       
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER CalculateKuttaJukowskiForces                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateKuttaJukowskiForces(void)
{

    int j;

    // Loop over vortex edges and calculate forces via K-J theorem

#pragma omp parallel for
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; j++ ) {

       VSPGeom().Grid(MGLevel_).EdgeList(j).CalculateForces();
               
    }
    
    // Loop over edges and calculate down wash induced forces

#pragma omp parallel for
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; j++ ) {

       VSPGeom().Grid(MGLevel_).EdgeList(j).CalculateTrefftzForces();
               
    }

    // Adjust for supersonic panel or mixed mode solves
    
    if ( VSPGeom().ModelType() == PANEL_MODEL && Mach_ > 1. ) {
#pragma omp parallel for
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
   
          if ( VSPGeom().SurfaceIsThick(VSPGeom().Grid(MGLevel_).EdgeList(j).SurfaceID()) ) {
             
             VSPGeom().Grid(MGLevel_).EdgeList(j).Fx() *= 0.5;
             VSPGeom().Grid(MGLevel_).EdgeList(j).Fy() *= 0.5;
             VSPGeom().Grid(MGLevel_).EdgeList(j).Fz() *= 0.5;
             
          }
      
       }
       
    }
                     
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER CalculateUnsteadyForces                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateUnsteadyForces(void)
{

    int i, j, Edge;
    double DeltaPressure, DGammaDt;

    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
     
       VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fx() = 0.;
       VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fy() = 0.;
       VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fz() = 0.;
 
    }
   
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
    
     //  DGammaDt = ( 3.*Gamma(i) - 4.*GammaNM1(i) + GammaNM2(i) ) / (2.*DeltaTime_);
     //
     //  if ( Time_ <= 2 ) DGammaDt = ( Gamma(i) - GammaNM1(i) )/DeltaTime_;
       
       DGammaDt = ( Gamma(i) - GammaNM1(i) )/DeltaTime_;

       DeltaPressure = -DGammaDt;

       VSPGeom().Grid(MGLevel_).LoopList(i).dCp_Unsteady() = DeltaPressure;
  
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j++ ) {
          
          Edge = VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);

          VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fx() -= DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(i).Area() * VSPGeom().Grid(MGLevel_).LoopList(i).Nx() / VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges();
          VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fy() -= DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(i).Area() * VSPGeom().Grid(MGLevel_).LoopList(i).Ny() / VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges();
          VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fz() -= DeltaPressure * VSPGeom().Grid(MGLevel_).LoopList(i).Area() * VSPGeom().Grid(MGLevel_).LoopList(i).Nz() / VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges();

       }
       
    }
                       
}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER CalculateDeltaCPs                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateDeltaCPs(void)
{

    int i, j, Loop1, Loop2;
    double Fx, Fy, Fz, Wgt1, Wgt2, NormalForce;

    // Loop over vortex edges and calculate forces via K-J theorem
 
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
   
       VSPGeom().Grid(MGLevel_).LoopList(i).Fx() = 0.;
       VSPGeom().Grid(MGLevel_).LoopList(i).Fy() = 0.;
       VSPGeom().Grid(MGLevel_).LoopList(i).Fz() = 0.;

    }
     
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; j++ ) {

       if ( !VSPGeom().Grid(MGLevel_).EdgeList(j).IsTrailingEdge() ) {
             
          Loop1 = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopL();
          Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(j).LoopR();
   
          // Edge forces
   
          Fx = VSPGeom().Grid(MGLevel_).EdgeList(j).Fx() + VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fx();
          Fy = VSPGeom().Grid(MGLevel_).EdgeList(j).Fy() + VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fy();
          Fz = VSPGeom().Grid(MGLevel_).EdgeList(j).Fz() + VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fz();
             
          // Loop level forces
   
          if ( Loop1 != 0 && Loop2 != 0 ) {

             Wgt1 = VSPGeom().Grid(MGLevel_).LoopList(Loop1).Area()/(VSPGeom().Grid(MGLevel_).LoopList(Loop1).Area() + VSPGeom().Grid(MGLevel_).LoopList(Loop2).Area());    
   
             Wgt2 = 1. - Wgt1;
                     
             VSPGeom().Grid(MGLevel_).LoopList(Loop1).Fx() += Wgt1*Fx;
             VSPGeom().Grid(MGLevel_).LoopList(Loop1).Fy() += Wgt1*Fy;
             VSPGeom().Grid(MGLevel_).LoopList(Loop1).Fz() += Wgt1*Fz;
   
             VSPGeom().Grid(MGLevel_).LoopList(Loop2).Fx() += Wgt2*Fx;
             VSPGeom().Grid(MGLevel_).LoopList(Loop2).Fy() += Wgt2*Fy;
             VSPGeom().Grid(MGLevel_).LoopList(Loop2).Fz() += Wgt2*Fz;
          
          }
          
       }

    }
    
    // Calculate normal force on each vortex loop

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
   
       // Steady component
       
       NormalForce = -VSPGeom().Grid(MGLevel_).LoopList(i).Fx() * VSPGeom().Grid(MGLevel_).LoopList(i).Nx()
                   + -VSPGeom().Grid(MGLevel_).LoopList(i).Fy() * VSPGeom().Grid(MGLevel_).LoopList(i).Ny()
                   + -VSPGeom().Grid(MGLevel_).LoopList(i).Fz() * VSPGeom().Grid(MGLevel_).LoopList(i).Nz();
                                   
       VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = NormalForce / VSPGeom().Grid(MGLevel_).LoopList(i).Area();      
    
       VSPGeom().Grid(MGLevel_).LoopList(i).dCp() /= 0.5*Vref_*Vref_;

       // Unsteady component
       
       VSPGeom().Grid(MGLevel_).LoopList(i).dCp_Unsteady() /= 0.5*Vref_*Vref_;

       // Total Cp
              
       VSPGeom().Grid(MGLevel_).LoopList(i).dCp() += VSPGeom().Grid(MGLevel_).LoopList(i).dCp_Unsteady();

    }

}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CalculateSurfacePressures                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateSurfacePressures(void)
{

    int i, j, Loop1, Loop2, Edge, Node, Hits, *OnBoundary, BoundaryLoop;
    double Dot, KTFact, Normal[3], Area1, Area2, wgt1, wgt2;
    double Cp, CpCrit, LocalMach, KTMach;
    double *NodalCp, *NodalArea, Area, NewCp, Relax;      
    double gamma, gm1, gm2, gm3, q2, qmax, rho, pinf;
    double MaxCp;
    
    // Calculate surface gradients if there are thick surfaces
    
    if ( VSPGeom().NumberOfThickSurfaces() > 0 ) CalculateVorticityGradient();

    // Compssible relations..
    
    gamma = 1.4;
    
    gm1 = gamma - 1.;
    
    gm2 = 0.5*gm1*Mach_*Mach_;
    
    gm3 = 1./gm1;

    qmax = 0.98*sqrt( 1./gm2 + 1. );
            
    // Add in vorticity gradient and zero out any residual normal component
        
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       if ( VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceID() > 0 ) {

          VSPGeom().Grid(MGLevel_).LoopList(i).U() -= 0.5*VorticityGradient_[i].dv_dx();
          VSPGeom().Grid(MGLevel_).LoopList(i).V() -= 0.5*VorticityGradient_[i].dv_dy();
          VSPGeom().Grid(MGLevel_).LoopList(i).W() -= 0.5*VorticityGradient_[i].dv_dz();
          
          Normal[0] = VSPGeom().Grid(MGLevel_).LoopList(i).Nx();
          Normal[1] = VSPGeom().Grid(MGLevel_).LoopList(i).Ny();
          Normal[2] = VSPGeom().Grid(MGLevel_).LoopList(i).Nz();
            
          Dot = vector_dot(Normal, VSPGeom().Grid(MGLevel_).LoopList(i).Velocity());
          
          // Subtract out normal velocity, unless we are on an engine face
          
          if ( !SurfaceIsOnEngineFace_[VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceID()] ) {
             
             VSPGeom().Grid(MGLevel_).LoopList(i).U() -= Dot * Normal[0];
             VSPGeom().Grid(MGLevel_).LoopList(i).V() -= Dot * Normal[1];
             VSPGeom().Grid(MGLevel_).LoopList(i).W() -= Dot * Normal[2];
             
          }
          
       }

    }       
  
    // Calculate thin surface Delta Cps

    if ( VSPGeom().NumberOfThinSurfaces() > 0 ) CalculateDeltaCPs();

    // Calculate Cp for panel loops .. this will over write the above calculations on panel loops

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
              
       if ( VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceType() == THICK_SURFACE ) {
    
          VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = ( pow(VSPGeom().Grid(MGLevel_).LoopList(i).U(),2.)
                                + pow(VSPGeom().Grid(MGLevel_).LoopList(i).V(),2.)
                                + pow(VSPGeom().Grid(MGLevel_).LoopList(i).W(),2.) ) / SQR(Vref_);
    
          if ( VSPGeom().Grid(MGLevel_).LoopList(i).VortexSheet() == 0 && VSPGeom().Grid(MGLevel_).LoopList(i).dCp() > QMax_*QMax_*SQR(Vref_) ) VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = QMax_*QMax_*SQR(Vref_);
    
          if ( Mach_ < 1. ) {
    
             VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = 1. - VSPGeom().Grid(MGLevel_).LoopList(i).dCp(); 
    
          }
          
          else {
    
             q2 = VSPGeom().Grid(MGLevel_).LoopList(i).dCp();
    
             q2 = MIN(q2,qmax);
             
             rho = pow(1. - gm2*(q2 - 1.), gm3);
          
             pinf = 1./(gamma*Mach_*Mach_);
             
             VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = 2.*( pow(rho, gamma) - 1.)*pinf;
    
          }
          
          // Limit Cp
          
          Cp = VSPGeom().Grid(MGLevel_).LoopList(i).dCp();
          
          LocalMach = Mach_;
          
          if ( Machref_ > 0. && Vref_ > 0. ) {
             
             LocalMach = Machref_*VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(4)/Vref_;
           
          }
          
          if ( Mach_ < 1. ) {
             
             LocalMach = MIN(LocalMach, 0.80);
             
             CpCrit = -2.*(1.-LocalMach*LocalMach)/(LocalMach*LocalMach*(1.4+1.));
             
             CpCrit *= 2.5;
             
             if ( VSPGeom().Grid(MGLevel_).LoopList(i).VortexSheet() == 0 ) VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = MAX(Cp,CpCrit);     
             
          }
          
          else {
             
             VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = MIN(VSPGeom().Grid(MGLevel_).LoopList(i).dCp(), CpMax_);
             
          }
          
       }
                            
    }
    
    // Clean up solution near intersections
 
    OnBoundary = new int[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
           
    zero_int_array(OnBoundary, VSPGeom().Grid(MGLevel_).NumberOfNodes());
           
    NodalCp    = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];       
    NodalArea  = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
     
    zero_double_array(NodalCp, VSPGeom().Grid(MGLevel_).NumberOfNodes());
    zero_double_array(NodalArea, VSPGeom().Grid(MGLevel_).NumberOfNodes());
 
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       if ( VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceType() == THICK_SURFACE ) {
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfNodes() ; j++ ) {
             
             Node = VSPGeom().Grid(MGLevel_).LoopList(i).Node(j);
          
             NodalCp[Node] += VSPGeom().Grid(MGLevel_).LoopList(i).Area() * VSPGeom().Grid(MGLevel_).LoopList(i).dCp();
             
             NodalArea[Node] += VSPGeom().Grid(MGLevel_).LoopList(i).Area();
             
          }
          
       }
       
    }
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       NodalCp[i] /= NodalArea[i];
       
    }
                  
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
 
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j++ ) {
      
          Edge =  VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);
          
          Loop1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop1();
          Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Loop2();
       
          if ( VSPGeom().Grid(MGLevel_).LoopList(Loop1).SurfaceID() != VSPGeom().Grid(MGLevel_).LoopList(Loop2).SurfaceID() ) {
             
             OnBoundary[VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node1()] = 1;
             OnBoundary[VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node2()] = 1;
                           
          }
             
       }
       
    }
 
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       if ( VSPGeom().Grid(MGLevel_).NodeList(i).IsBoundaryEdgeNode() ) {
       
          OnBoundary[i] = 1;
       
       }
    
    }
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
 
       if ( VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceType() == THICK_SURFACE ) {
          
          BoundaryLoop = 0;
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfNodes() ; j++ ) {
          
             if ( OnBoundary[VSPGeom().Grid(MGLevel_).LoopList(i).Node(j)] ) BoundaryLoop = 1;
                
          }
                
          if ( BoundaryLoop ) {
     
             NewCp = Area = 0.;
             
             Hits = 0;
             
             for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfNodes() ; j++ ) {
          
                Node = VSPGeom().Grid(MGLevel_).LoopList(i).Node(j);
             
                if ( !OnBoundary[Node] ) {
                   
                   NewCp += NodalArea[Node] * NodalCp[Node];
                   
                   Area += NodalArea[Node];
                   
                   Hits++;
                   
                }
                
             }
        
             if ( Hits > 0 ) {
              
                VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = NewCp / Area;
                
             }
          
          } 
          
       }
 
    }
   
    delete [] NodalArea;
 
    delete [] OnBoundary;
    
    delete [] NodalCp;

    // Karman-Tsien correction
    
    KTResidual_[1] = 0.;
    
    Relax = 0.75;

    if ( KarmanTsienCorrection_ && Mach_ > 0. && Mach_ < 1. ) {
        
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
    
          // Cp
   
          Cp = VSPGeom().Grid(MGLevel_).LoopList(i).dCp();
   
          LocalMach = Mach_;
          
          if ( Mach_ > 0. && Vinf_ > 0. ) {
             
             LocalMach = Mach_*VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(4)/Vinf_;
             
          }
          
          LocalMach = MIN(LocalMach, MAX(Mach_,0.95));
      
          CpCrit = -2.*(1.-LocalMach*LocalMach)/(LocalMach*LocalMach*(1.4+1.));

          // Karman-Tsien correction
       
          KTMach = VSPGeom().Grid(MGLevel_).LoopList(i).KTFact()*LocalMach;
          
          KTFact = sqrt( (1.-LocalMach*LocalMach)/(1.-KTMach*KTMach) );
          
          Cp /= VSPGeom().Grid(MGLevel_).LoopList(i).KTFact();
    
          KTFact = 1. - 0.25*LocalMach*LocalMach*MAX(Cp,CpCrit);
          
          // Laitone KTFact = 1. - 0.5*(LocalMach*LocalMach*( 1. + 0.2*LocalMach*LocalMach )/sqrt(1.-LocalMach*LocalMach))*MAX(Cp,CpCrit);
                
          if ( KTFact > 0. ) {
          
             if ( KTFact*KTFact + Mach_*Mach_ - 1. > 0. ) {
                
                KTMach = sqrt( (KTFact*KTFact + LocalMach*LocalMach - 1.)/(KTFact*KTFact) );
             
                KTMach = MIN(0.95,KTMach);
      
                KTFact = KTMach/LocalMach;
                
             }
             
             else {
                
                KTMach = 0.;
                
                KTFact = KTMach/LocalMach;
                
             }
             
          }
          
          else {
             
             KTFact = 1.;
             
          }
    
          KTResidual_[1] += pow(KTFact-VSPGeom().Grid(MGLevel_).LoopList(i).KTFact(),2.);

          VSPGeom().Grid(MGLevel_).LoopList(i).KTFact() = (1.-Relax)*VSPGeom().Grid(MGLevel_).LoopList(i).KTFact() + Relax*KTFact;
          
       }
       
       // Calculate convergence of KT correction and apply to edges

       KTResidual_[1] /= VSPGeom().Grid(MGLevel_).NumberOfLoops();
  
       KTResidual_[1] = sqrt(KTResidual_[1]);
       
       if ( CurrentWakeIteration_ == 1 ) KTResidual_[0] = KTResidual_[1];
       
       KTResidual_[1] /= KTResidual_[0];
       
       KTResidual_[1] = log10(KTResidual_[1]);
       
       //printf("%s ... KTRes: %10.5f \n",ConvergenceLine_,KTResidual_[1]);

       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
          
          if ( !VSPGeom().Grid(MGLevel_).EdgeList(j).IsTrailingEdge() ) {

             Loop1 = VSPGeom().Grid(MGLevel_).EdgeList(j).Loop1();
             Loop2 = VSPGeom().Grid(MGLevel_).EdgeList(j).Loop2();
             
             Area1 = VSPGeom().Grid(MGLevel_).LoopList(Loop1).Area();
             Area2 = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Area();
             
             wgt2 = Area2 / ( Area1 + Area2 );
             wgt1 = 1. - wgt2;
             
             VSPGeom().Grid(MGLevel_).EdgeList(j).KTFact() = wgt1 * VSPGeom().Grid(MGLevel_).LoopList(Loop1).KTFact() + wgt2 * VSPGeom().Grid(MGLevel_).LoopList(Loop2).KTFact();
             
          }
          
       }

       RestrictKTFactorFromGrid(MGLevel_);

    }
  
    // Add in delta Cp due to rotors, and unsteady correction

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       if ( VSPGeom().Grid(MGLevel_).LoopList(i).SurfaceType() == THICK_SURFACE ) {
    
          // Rotor Delta Cp
       
          VSPGeom().Grid(MGLevel_).LoopList(i).dCp() += VSPGeom().Grid(MGLevel_).LoopList(i).LocalFreeStreamVelocity(3);
          
          // Unsteady Cp
    
          VSPGeom().Grid(MGLevel_).LoopList(i).dCp_Unsteady() /= (0.5*Vref_*Vref_);
          
          // Total Cp
          
          VSPGeom().Grid(MGLevel_).LoopList(i).dCp() += VSPGeom().Grid(MGLevel_).LoopList(i).dCp_Unsteady();
          
       }

    }
    
    // Enforce base pressures
  
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       if ( LoopIsOnBaseRegion_[i] ) VSPGeom().Grid(MGLevel_).LoopList(i).dCp() = CpBase_;

    }
                  
}

/*##############################################################################
#                                                                              #
#                      VSP_SOLVER CalculateNodalPressures                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateNodalPressures(void)
{
   
    int i, j, Node;
    double *NodalArea;
           
    NodalCp_   = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];       
    NodalArea  = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
     
    zero_double_array(NodalCp_, VSPGeom().Grid(MGLevel_).NumberOfNodes());
    zero_double_array(NodalArea, VSPGeom().Grid(MGLevel_).NumberOfNodes());

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfNodes() ; j++ ) {
          
          Node = VSPGeom().Grid(MGLevel_).LoopList(i).Node(j);
       
          NodalCp_[Node] += VSPGeom().Grid(MGLevel_).LoopList(i).Area() * VSPGeom().Grid(MGLevel_).LoopList(i).dCp();
          
          NodalArea[Node] += VSPGeom().Grid(MGLevel_).LoopList(i).Area();
          
       }
       
    }
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       NodalCp_[i] /= NodalArea[i];
  
    }   
   
    delete [] NodalArea;
      
}

/*##############################################################################
#                                                                              #
#              VSP_SOLVER CreateVorticityGradientDataStructure                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateVorticityGradientDataStructure(void)
{

    int i, j, k, Loop, Loop1, Loop2, Loop3, StartLoop, Level;
    int *NeighborLoop, *NextLoop;
    int NumberOfLoops, NewNumberOfLoops, NumberOfEquations;
    int *NumberOfLoopsForNode, **NodeToLoopList, *NodeIsOnThinBoundary, Node;

    printf("Starting... Creating vorticity gradient data structure .. \n"); fflush(NULL);

    // Mark nodes on any thin boundaries

    NodeIsOnThinBoundary = new int[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    zero_int_array(NodeIsOnThinBoundary, VSPGeom().Grid(MGLevel_).NumberOfNodes());
           
    if ( VSPGeom().NumberOfThinSurfaces() > 0 ) {
       
       for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; Loop++ ) {
          
          if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).SurfaceType() == THIN_SURFACE ) {
             
             for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() ; j++ ) {
             
                NodeIsOnThinBoundary[VSPGeom().Grid(MGLevel_).LoopList(Loop).Node(j)] = 1;
                
             }
             
          }
          
       }
       
    }
         
    // Create a node to loop tri list
        
    NumberOfLoopsForNode = new int[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    NodeToLoopList = new int*[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    zero_int_array(NumberOfLoopsForNode, VSPGeom().Grid(MGLevel_).NumberOfNodes());
    
    for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; Loop++ ) {
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() ; j++ ) {
     
          Node = VSPGeom().Grid(MGLevel_).LoopList(Loop).Node(j);

          NumberOfLoopsForNode[Node]++;
   
       }
       
    }
    
    // Size the node to loop list, this is over sized as we toss out some cases below
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       NodeToLoopList[i] = new int[NumberOfLoopsForNode[i] + 1];
       
    }
    
    zero_int_array(NumberOfLoopsForNode, VSPGeom().Grid(MGLevel_).NumberOfNodes());
    
    for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; Loop++ ) {
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfNodes() ; j++ ) {
          
          Node = VSPGeom().Grid(MGLevel_).LoopList(Loop).Node(j);

          if ( !(VSPGeom().Grid(MGLevel_).NodeList(Node).IsBoundaryEdgeNode()) ) {
       
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).SurfaceType() == THIN_SURFACE || !NodeIsOnThinBoundary[Node] ) {
            
                NumberOfLoopsForNode[Node]++;
             
                NodeToLoopList[Node][NumberOfLoopsForNode[Node]] = Loop;
                
             }
             
          }
                    
       }
       
    }    
    
    delete [] NodeIsOnThinBoundary;

    VorticityGradient_ = new GRADIENT[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];
    
    NeighborLoop = new int[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];

    zero_int_array(NeighborLoop, VSPGeom().Grid(MGLevel_).NumberOfLoops());

    NextLoop = new int[VSPGeom().Grid(MGLevel_).NumberOfLoops() + 1];
    
    zero_int_array(NextLoop, VSPGeom().Grid(MGLevel_).NumberOfLoops());

    for ( Loop1 = 1 ; Loop1 <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; Loop1++ ) {
       
       NumberOfLoops = 0;
       
       NeighborLoop[Loop1] = Loop1;
       
       NextLoop[++NumberOfLoops] = Loop1;
        
       NewNumberOfLoops = NumberOfLoops;

       // Buffer out 3 levels ish
       
       StartLoop = 1;
        
       for ( Level = 1 ; Level <= 3 ; Level++ ) {

          for ( k = StartLoop ; k <= NumberOfLoops ; k++ ) {
   
             Loop2 = NextLoop[k];
             
             // Add in neighboring loops
             
             for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).LoopList(Loop2).NumberOfNodes() ; i++ ) {
                
                Node = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Node(i);
                
                for ( j = 1 ; j <= NumberOfLoopsForNode[Node] ; j++ ) {
                   
                   Loop3 = NodeToLoopList[Node][j];
                   
                   if ( NeighborLoop[Loop3] != Loop1 ) {
                      
                      NeighborLoop[Loop3] = Loop1;
                      
                      NextLoop[++NewNumberOfLoops] = Loop3;
                      
                   }
                   
                }
                
             }
             
          }
          
          StartLoop += NumberOfLoops;
          
          NumberOfLoops = NewNumberOfLoops;
          
       }
       
       NumberOfLoops--; // Don't count center loop in list
 
       NumberOfEquations = NumberOfLoops + 1;
       
       if ( NumberOfLoops < 3 ) NumberOfLoops = 0;
       
       VorticityGradient_[Loop1].SizeList(NumberOfLoops, NumberOfEquations, 3);
      
       for ( k = 2 ; k <= NumberOfLoops ; k++ ) {
          
          VorticityGradient_[Loop1].LoopList(k) = Loop2 = NextLoop[k];
          
       }

       CalculateLeastSquaresCoefficients(Loop1); 

    }  

    delete [] NeighborLoop;

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
       
       if ( NumberOfLoopsForNode[i] > 0 ) delete [] NodeToLoopList[i];
       
    }    
    
    delete [] NodeToLoopList;
    delete [] NumberOfLoopsForNode;

    printf("Finished... Creating vorticity gradient data structure .. \n"); fflush(NULL);

}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER CalculateLeastSquaresCoefficients                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateLeastSquaresCoefficients(int Loop1)
{
   
    int k, Loop2, NumberOfEquations;
    double  Wgt, dx, dy, dz, Area1, Area2;
    
    if ( VorticityGradient_[Loop1].NumberOfLoops() > 0 ) {
       
       MATRIX *A;
       
       NumberOfEquations = VorticityGradient_[Loop1].NumberOfEquations();
       
       A = new MATRIX;
        
       // Linear fit
   
       A->size(NumberOfEquations,3);
   
       for ( k = 1 ; k <= VorticityGradient_[Loop1].NumberOfLoops() ; k++ ) {
             
          Loop2 = VorticityGradient_[Loop1].LoopList(k);
   
          dx = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Xc() - VSPGeom().Grid(MGLevel_).LoopList(Loop1).Xc();
          dy = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Yc() - VSPGeom().Grid(MGLevel_).LoopList(Loop1).Yc();
          dz = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Zc() - VSPGeom().Grid(MGLevel_).LoopList(Loop1).Zc();
            
          Area1 = VSPGeom().Grid(MGLevel_).LoopList(Loop1).Area();
          
          Area2 = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Area();
          
          // Weight is proportional to dot product of normals... 
   
          Wgt = MAX(vector_dot(VSPGeom().Grid(MGLevel_).LoopList(Loop1).Normal(), VSPGeom().Grid(MGLevel_).LoopList(Loop2).Normal()),0.000001);
   
          // Weight is proportional to tri area
          
          Wgt *= MIN(pow(Area2/Area1,2.),1.);
          
          // Weight is inversely proportional to distance
          
          Wgt *= 1./sqrt(dx*dx + dy*dy + dz*dz);      
          
          // Supersonic upwind
          
          if ( Mach_ > 1. && dx > 0. ) Wgt *= 1.e-4;
   
          (*A)(k,1) = dx*Wgt;
          (*A)(k,2) = dy*Wgt;
          (*A)(k,3) = dz*Wgt;
   
       }
   
       (*A)(NumberOfEquations,1) = VSPGeom().Grid(MGLevel_).LoopList(Loop1).Nx();
       (*A)(NumberOfEquations,2) = VSPGeom().Grid(MGLevel_).LoopList(Loop1).Ny();
       (*A)(NumberOfEquations,3) = VSPGeom().Grid(MGLevel_).LoopList(Loop1).Nz();
   
       VorticityGradient_[Loop1].At() = (*A).transpose();
   
       VorticityGradient_[Loop1].AA() = VorticityGradient_[Loop1].At() * (*A);
       
       VorticityGradient_[Loop1].LU();
       
       delete A; 
       
    }
  
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CalculateVorticityGradient                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateVorticityGradient(void)
{

    int i, j, k, Loop, Loop1, Loop2, Edge, Node1, Node2, *FixedNode;
    int Iter, Done, NodeHits;
    double Wgt, Area1, Area2, dx, dy, dz;
    double Fact, *dV, *Denom, *Res, *Dif, *Sum, ResMax, ResMax0, Delta, Eps, Wgt1, Wgt2, dVAvg;
    
    for ( Loop1 = 1 ; Loop1 <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; Loop1++ ) {
       
       VorticityGradient_[Loop1].dv_dx() = 0.;
       VorticityGradient_[Loop1].dv_dy() = 0.;
       VorticityGradient_[Loop1].dv_dz() = 0.;
       
       if ( VorticityGradient_[Loop1].NumberOfLoops() > 0 ) {
       
          for ( k = 1 ; k <= VorticityGradient_[Loop1].NumberOfLoops() ; k++ ) {
             
             Loop2 = VorticityGradient_[Loop1].LoopList(k);
   
             Area1 = VSPGeom().Grid(MGLevel_).LoopList(Loop1).Area();
             
             Area2 = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Area();
             
             dx = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Xc() - VSPGeom().Grid(MGLevel_).LoopList(Loop1).Xc();
             dy = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Yc() - VSPGeom().Grid(MGLevel_).LoopList(Loop1).Yc();
             dz = VSPGeom().Grid(MGLevel_).LoopList(Loop2).Zc() - VSPGeom().Grid(MGLevel_).LoopList(Loop1).Zc();          
   
             Wgt = MAX(vector_dot(VSPGeom().Grid(MGLevel_).LoopList(Loop1).Normal(), VSPGeom().Grid(MGLevel_).LoopList(Loop2).Normal()),0.000001);
   
             Wgt *= MIN(pow(Area2/Area1,2.),1.);
   
             Wgt *= 1./sqrt(dx*dx + dy*dy + dz*dz);    
      
             if ( Mach_ > 1. && dx > 0. ) Wgt *= 1.e-4;
                       
             VorticityGradient_[Loop1].b(k) = ( VSPGeom().Grid(MGLevel_).LoopList(Loop2).Gamma() - VSPGeom().Grid(MGLevel_).LoopList(Loop1).Gamma() ) * Wgt;    
   
          }
          
          VorticityGradient_[Loop1].b(VorticityGradient_[Loop1].NumberOfEquations()) = 0.;
       
          VorticityGradient_[Loop1].Solve();

       }
    
    }   

    // Smooth gradient

    dV = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    Denom = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    FixedNode = new int[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    Res = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    Dif = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];
    
    Sum = new double[VSPGeom().Grid(MGLevel_).NumberOfNodes() + 1];

    for ( i = 1 ; i <= 3 ; i++ ) {

       zero_double_array(dV, VSPGeom().Grid(MGLevel_).NumberOfNodes());

       zero_double_array(Denom, VSPGeom().Grid(MGLevel_).NumberOfNodes());

       for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; Loop++ ) {
    
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; j++ ) {
             
             Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(j);
             
             Node1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node1();
             Node2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node2();
             
             if ( i == 1 ) {
                
                dV[Node1] += VorticityGradient_[Loop].dv_dx() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
                dV[Node2] += VorticityGradient_[Loop].dv_dx() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
                
             }
             
             else if ( i == 2 ) {
                
                dV[Node1] += VorticityGradient_[Loop].dv_dy() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
                dV[Node2] += VorticityGradient_[Loop].dv_dy() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
                
             }
             
             else {

                dV[Node1] += VorticityGradient_[Loop].dv_dz() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
                dV[Node2] += VorticityGradient_[Loop].dv_dz() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
                
             }                                   
             
             Denom[Node1] += VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
             Denom[Node2] += VSPGeom().Grid(MGLevel_).LoopList(Loop).Area();
             
          }
          
       }
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; j++ ) {
          
          dV[j] /= Denom[j];
          
       }

       // Enforce kutta condition on trailing edge

       zero_int_array(FixedNode, VSPGeom().Grid(MGLevel_).NumberOfNodes());

       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfKuttaNodes() ; j++ ) {

           dV[VSPGeom().Grid(MGLevel_).KuttaNode(j)] = 0.;
           
           FixedNode[VSPGeom().Grid(MGLevel_).KuttaNode(j)] = 1;
      
       }

       zero_double_array(Sum, VSPGeom().Grid(MGLevel_).NumberOfNodes());

       // Count edge hits per node
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
       
          // Edge to node pointers
       
          Node1 = VSPGeom().Grid(MGLevel_).EdgeList(j).Node1();
          Node2 = VSPGeom().Grid(MGLevel_).EdgeList(j).Node2();

          Sum[Node1] += 1.;
          Sum[Node2] += 1.;
         
       }

       // Loop over and smooth all residuals
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; j++ ) {
       
          Res[j] = dV[j];
       
          Dif[j] = 0.;
       
       }

       // Do a few iterations of smoothing
       
       Iter = 1;
       
       Done = 0;
       
       ResMax0 = 0.;
     
       while ( !Done && Iter <= 250 ) {
           
          ResMax = 0.;
       
          // Loop over the edges and scatter fluxes
       
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
           
              // Edge to node pointers
           
              Node1 = VSPGeom().Grid(MGLevel_).EdgeList(j).Node1();
              Node2 = VSPGeom().Grid(MGLevel_).EdgeList(j).Node2();

              Delta = Res[Node1] - Res[Node2];
       
              Dif[Node1] -= Delta;
              Dif[Node2] += Delta;
       
          }
       
          Eps = 0.5;
          
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; j++ ) {
       
             if ( !FixedNode[j] ) {
       
                Fact = Eps*Sum[j];
                
                Delta = ( dV[j] + Fact*Res[j] + Eps*Dif[j] )/( 1. + Fact ) - Res[j];
                
                ResMax += Delta*Delta;
       
                Res[j] += Delta;
       
             }
       
             Dif[j] = 0.;
       
          }
          
          ResMax = sqrt(ResMax/VSPGeom().Grid(MGLevel_).NumberOfNodes());
          
          if ( Iter == 1 ) ResMax0 = ResMax;
          
          if ( ResMax0 != 0. ) {
             
             //printf("Iter: %d ... Vorticity Resmax: %f \n",Iter,log10(ResMax/ResMax0));
             
             if ( log10(ResMax/ResMax0) <= -2. ) Done = 1;
             
          }  
          
          Iter++;     
                 
       }

       // Update nodal values with smoothed result
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; j++ ) {
      
          dV[j] = Res[j];
      
       }           
      
       // Finally, update loop values
      
       for ( Loop = 1 ; Loop <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; Loop++ ) {
          
          NodeHits = 0;
          
          dVAvg = 0.;
      
          for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(Loop).NumberOfEdges() ; j++ ) {
       
             Edge = VSPGeom().Grid(MGLevel_).LoopList(Loop).Edge(j);
             
             Node1 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node1();
             Node2 = VSPGeom().Grid(MGLevel_).EdgeList(Edge).Node2();
             
             Wgt1 = Wgt2 = 0.;

             if ( Sum[Node1] > 0. ) { Wgt1 = 1.; NodeHits++; }
             if ( Sum[Node2] > 0. ) { Wgt2 = 1.; NodeHits++; }

             dVAvg += Wgt1*dV[Node1] + Wgt2*dV[Node2];
             
          }

          if ( i == 1 && NodeHits > 0 ) VorticityGradient_[Loop].dv_dx() = dVAvg / NodeHits;
          if ( i == 2 && NodeHits > 0 ) VorticityGradient_[Loop].dv_dy() = dVAvg / NodeHits;
          if ( i == 3 && NodeHits > 0 ) VorticityGradient_[Loop].dv_dz() = dVAvg / NodeHits;
          
       }

    }
                
    delete [] dV;
    delete [] Denom;
    delete [] FixedNode;
    delete [] Res;
    delete [] Dif;
    delete [] Sum;

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER IntegrateForcesAndMoments                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::IntegrateForcesAndMoments(void)
{

    int i, j, k, c, g, Node1, Node2, Edge, LE_Edge, TE_Edge, *ComponentInThisGroup;
    double Fx, Fy, Fz, Fxo, Fyo, Fzo, Wgt1, Wgt2, StallFactor, Velocity, Sign;
    double CA, SA, CB, SB;
    double ComponentCg[3];
    double Chord, Span, Cl, Gamma, RVec[3], SVec[3], RVeco[3], Mag, Re, Cf, pCf_pCl2;
    double DeltaDrag, DeltaFxo, DeltaFyo, DeltaFzo, ReFact;

    CA = cos(AngleOfAttack_);
    SA = sin(AngleOfAttack_);

    CB = cos(AngleOfBeta_);
    SB = sin(AngleOfBeta_);

    // Zero out component group forces and moments
 
    for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {

       // Invisicid component
       
       VSPGeom().ComponentGroupList(c).CFix() = 0.;
       VSPGeom().ComponentGroupList(c).CFiy() = 0.;
       VSPGeom().ComponentGroupList(c).CFiz() = 0.;
              
       VSPGeom().ComponentGroupList(c).CMix() = 0.;
       VSPGeom().ComponentGroupList(c).CMiy() = 0.;
       VSPGeom().ComponentGroupList(c).CMiz() = 0.;

       VSPGeom().ComponentGroupList(c).CLi()  = 0.;
       VSPGeom().ComponentGroupList(c).CDi()  = 0.;
       VSPGeom().ComponentGroupList(c).CSi()  = 0.;

       VSPGeom().ComponentGroupList(c).CTi()  = 0.;
       VSPGeom().ComponentGroupList(c).CQi()  = 0.;
       VSPGeom().ComponentGroupList(c).CPi()  = 0.;    
       
       // Viscous component
       
       VSPGeom().ComponentGroupList(c).CFox() = 0.;
       VSPGeom().ComponentGroupList(c).CFoy() = 0.;
       VSPGeom().ComponentGroupList(c).CFoz() = 0.;
                                        
       VSPGeom().ComponentGroupList(c).CMox() = 0.;
       VSPGeom().ComponentGroupList(c).CMoy() = 0.;
       VSPGeom().ComponentGroupList(c).CMoz() = 0.;

       VSPGeom().ComponentGroupList(c).CLo()  = 0.;
       VSPGeom().ComponentGroupList(c).CDo()  = 0.;
       VSPGeom().ComponentGroupList(c).CSo()  = 0.;
       
       VSPGeom().ComponentGroupList(c).CTo()  = 0.;
       VSPGeom().ComponentGroupList(c).CQo()  = 0.;
       VSPGeom().ComponentGroupList(c).CPo()  = 0.;     
       
       if ( TimeAccurate_ ) {
          
          // Invisicid component
          
          VSPGeom().ComponentGroupList(c).CFix(Time_) = 0.;
          VSPGeom().ComponentGroupList(c).CFiy(Time_) = 0.;
          VSPGeom().ComponentGroupList(c).CFiz(Time_) = 0.;
                 
          VSPGeom().ComponentGroupList(c).CMix(Time_) = 0.;
          VSPGeom().ComponentGroupList(c).CMiy(Time_) = 0.;
          VSPGeom().ComponentGroupList(c).CMiz(Time_) = 0.;
          
          VSPGeom().ComponentGroupList(c).CLi(Time_)  = 0.;
          VSPGeom().ComponentGroupList(c).CDi(Time_)  = 0.;
          VSPGeom().ComponentGroupList(c).CSi(Time_)  = 0.;
                                             
          VSPGeom().ComponentGroupList(c).CTi(Time_)  = 0.;
          VSPGeom().ComponentGroupList(c).CQi(Time_)  = 0.;
          VSPGeom().ComponentGroupList(c).CPi(Time_)  = 0.;    
          
          // Viscous component
          
          VSPGeom().ComponentGroupList(c).CFox(Time_) = 0.;
          VSPGeom().ComponentGroupList(c).CFoy(Time_) = 0.;
          VSPGeom().ComponentGroupList(c).CFoz(Time_) = 0.;
                                             
          VSPGeom().ComponentGroupList(c).CMox(Time_) = 0.;
          VSPGeom().ComponentGroupList(c).CMoy(Time_) = 0.;
          VSPGeom().ComponentGroupList(c).CMoz(Time_) = 0.;
          
          VSPGeom().ComponentGroupList(c).CLo(Time_)  = 0.;
          VSPGeom().ComponentGroupList(c).CDo(Time_)  = 0.;
          VSPGeom().ComponentGroupList(c).CSo(Time_)  = 0.;
                                            
          VSPGeom().ComponentGroupList(c).CTo(Time_)  = 0.;
          VSPGeom().ComponentGroupList(c).CQo(Time_)  = 0.;
          VSPGeom().ComponentGroupList(c).CPo(Time_)  = 0.;    
          
       }  
   
    }
 
    ComponentInThisGroup = new int[VSPGeom().NumberOfComponents() + 1];
    
    zero_int_array(ComponentInThisGroup, VSPGeom().NumberOfComponents());     
           
    for ( c = 1 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {  
       
       for ( i = 1 ; i <= VSPGeom().ComponentGroupList(c).NumberOfComponents() ; i++ ) {
          
          ComponentInThisGroup[VSPGeom().ComponentGroupList(c).ComponentList(i)] = c;
          
       }
       
    }

    // Loop over vortex edges and integrate the forces / moments

    CFix_ = CFiy_ = CFiz_ = 0.;
    
    CMix_ = CMiy_ = CMiz_ = 0.;
    
    CFox_ = CFoy_ = CFoz_ = 0.;
    
    CMox_ = CMoy_ = CMoz_ = 0.;

    CFwx_ = CFwy_ = CFwz_ = 0.;
    
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceEdges() ; j++ ) {

       // KJ forces
       
       if ( !VSPGeom().Grid(MGLevel_).EdgeList(j).IsTrailingEdge() ) {

          // Sum up forces and moments from each edge

          if ( !TimeAccurate_ ) {
             
             Fx = VSPGeom().Grid(MGLevel_).EdgeList(j).Fx();
             Fy = VSPGeom().Grid(MGLevel_).EdgeList(j).Fy();
             Fz = VSPGeom().Grid(MGLevel_).EdgeList(j).Fz();
             
          }
          
          else {

             Fx = VSPGeom().Grid(MGLevel_).EdgeList(j).Fx() + VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fx();
             Fy = VSPGeom().Grid(MGLevel_).EdgeList(j).Fy() + VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fy();
             Fz = VSPGeom().Grid(MGLevel_).EdgeList(j).Fz() + VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fz();
                          
          }
 
          CFix_ += Fx;
          CFiy_ += Fy;
          CFiz_ += Fz;
   
          CMix_ += Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Yc() - XYZcg_[1] ) - Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Zc() - XYZcg_[2] );   // Roll
          CMiy_ += Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Zc() - XYZcg_[2] ) - Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Xc() - XYZcg_[0] );   // Pitch
          CMiz_ += Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Xc() - XYZcg_[0] ) - Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Yc() - XYZcg_[1] );   // Yaw

          // Keep track of component group forces and moments
          
          for ( g = 0 ; g <= 1 ; g++ ) {
             
             if ( g == 0 ) c = 0;
             if ( g == 1 ) c = ComponentInThisGroup[VSPGeom().Grid(MGLevel_).EdgeList(j).ComponentID()];
    
             VSPGeom().ComponentGroupList(c).CFix() += Fx;
             VSPGeom().ComponentGroupList(c).CFiy() += Fy;
             VSPGeom().ComponentGroupList(c).CFiz() += Fz;
             
             ComponentCg[0] = VSPGeom().ComponentGroupList(c).OVec(0);
             ComponentCg[1] = VSPGeom().ComponentGroupList(c).OVec(1);
             ComponentCg[2] = VSPGeom().ComponentGroupList(c).OVec(2);
          
             VSPGeom().ComponentGroupList(c).CMix() += Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Yc() - ComponentCg[1] ) - Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Zc() - ComponentCg[2] );   // Roll
             VSPGeom().ComponentGroupList(c).CMiy() += Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Zc() - ComponentCg[2] ) - Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Xc() - ComponentCg[0] );   // Pitch
             VSPGeom().ComponentGroupList(c).CMiz() += Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Xc() - ComponentCg[0] ) - Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Yc() - ComponentCg[1] );   // Yaw

             if ( TimeAccurate_ ) {
             
                VSPGeom().ComponentGroupList(c).CFix(Time_) += Fx;
                VSPGeom().ComponentGroupList(c).CFiy(Time_) += Fy;
                VSPGeom().ComponentGroupList(c).CFiz(Time_) += Fz;
                
                ComponentCg[0] = VSPGeom().ComponentGroupList(c).OVec(0);
                ComponentCg[1] = VSPGeom().ComponentGroupList(c).OVec(1);
                ComponentCg[2] = VSPGeom().ComponentGroupList(c).OVec(2);
             
                VSPGeom().ComponentGroupList(c).CMix(Time_) += Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Yc() - ComponentCg[1] ) - Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Zc() - ComponentCg[2] );   // Roll
                VSPGeom().ComponentGroupList(c).CMiy(Time_) += Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Zc() - ComponentCg[2] ) - Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Xc() - ComponentCg[0] );   // Pitch
                VSPGeom().ComponentGroupList(c).CMiz(Time_) += Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Xc() - ComponentCg[0] ) - Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(j).Yc() - ComponentCg[1] );   // Yaw
             
             }
             
          }
                    
       }
       
       // Wake induced forces
       
       if ( VSPGeom().Grid(MGLevel_).EdgeList(j).IsTrailingEdge() ) {

          // Sum up forces from each trailing edge ... edge ;-) 

          Fx = VSPGeom().Grid(MGLevel_).EdgeList(j).Trefftz_Fx();
          Fy = VSPGeom().Grid(MGLevel_).EdgeList(j).Trefftz_Fy();
          Fz = VSPGeom().Grid(MGLevel_).EdgeList(j).Trefftz_Fz();
          
          CFwx_ += Fx;
          CFwy_ += Fy;
          CFwz_ += Fz;
          
          // Keep track of component group forces

          for ( g = 0 ; g <= 1 ; g++ ) {
             
             if ( g == 0 ) c = 0;
             if ( g == 1 ) c = ComponentInThisGroup[VSPGeom().Grid(MGLevel_).EdgeList(j).ComponentID()];
     
             VSPGeom().ComponentGroupList(c).CFiwx() += Fx;
             VSPGeom().ComponentGroupList(c).CFiwy() += Fy;
             VSPGeom().ComponentGroupList(c).CFiwz() += Fz;

          }
     
       }                          
  
    }

    // Stall forces

    if ( StallModelIsOn_ ) {
       
       MinStallFactor_ = 1.;
  
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
             
             Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());

             Velocity = sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[0], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[1], 2.)
                            + pow(VSPGeom().Grid(MGLevel_).EdgeList(Edge).LocalFreeStreamVelocity()[2], 2.) );

             if ( Velocity > 0. ) {
            
                StallFactor = 1. - VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor();
                  
                // Save minimum stall factor value
                
                MinStallFactor_ = MIN(MinStallFactor_,VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor());
               
                if ( !TimeAccurate_ ) {
                   
                   Fx = StallFactor*VSPGeom().Grid(MGLevel_).EdgeList(Edge).Fx();
                   Fy = StallFactor*VSPGeom().Grid(MGLevel_).EdgeList(Edge).Fy();
                   Fz = StallFactor*VSPGeom().Grid(MGLevel_).EdgeList(Edge).Fz();
                   
                }
                
                else {
                
                   Fx = StallFactor*VSPGeom().Grid(MGLevel_).EdgeList(Edge).Fx() + VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fx();
                   Fy = StallFactor*VSPGeom().Grid(MGLevel_).EdgeList(Edge).Fy() + VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fy();
                   Fz = StallFactor*VSPGeom().Grid(MGLevel_).EdgeList(Edge).Fz() + VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fz();
                                
                }
                
                CFix_ += Fx;
                CFiy_ += Fy;
                CFiz_ += Fz;          

                CMix_ += Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - XYZcg_[1] ) - Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - XYZcg_[2] );   // Roll
                CMiy_ += Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - XYZcg_[2] ) - Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - XYZcg_[0] );   // Pitch
                CMiz_ += Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - XYZcg_[0] ) - Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - XYZcg_[1] );   // Yaw
          
                // Keep track of component group forces and moments
                
                for ( g = 0 ; g <= 1 ; g++ ) {
                   
                   if ( g == 0 ) c = 0;
                   if ( g == 1 ) c = ComponentInThisGroup[VSPGeom().Grid(MGLevel_).EdgeList(Edge).ComponentID()];
            
                   VSPGeom().ComponentGroupList(c).CFix() += Fx;
                   VSPGeom().ComponentGroupList(c).CFiy() += Fy;
                   VSPGeom().ComponentGroupList(c).CFiz() += Fz;
                   
                   ComponentCg[0] = VSPGeom().ComponentGroupList(c).OVec(0);
                   ComponentCg[1] = VSPGeom().ComponentGroupList(c).OVec(1);
                   ComponentCg[2] = VSPGeom().ComponentGroupList(c).OVec(2);
                
                   VSPGeom().ComponentGroupList(c).CMix() += Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - ComponentCg[1] ) - Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - ComponentCg[2] );   // Roll
                   VSPGeom().ComponentGroupList(c).CMiy() += Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - ComponentCg[2] ) - Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - ComponentCg[0] );   // Pitch
                   VSPGeom().ComponentGroupList(c).CMiz() += Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - ComponentCg[0] ) - Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - ComponentCg[1] );   // Yaw
          
                   if ( TimeAccurate_ ) {
                   
                      VSPGeom().ComponentGroupList(c).CFix(Time_) += Fx;
                      VSPGeom().ComponentGroupList(c).CFiy(Time_) += Fy;
                      VSPGeom().ComponentGroupList(c).CFiz(Time_) += Fz;
                      
                      ComponentCg[0] = VSPGeom().ComponentGroupList(c).OVec(0);
                      ComponentCg[1] = VSPGeom().ComponentGroupList(c).OVec(1);
                      ComponentCg[2] = VSPGeom().ComponentGroupList(c).OVec(2);
                   
                      VSPGeom().ComponentGroupList(c).CMix(Time_) += Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - ComponentCg[1] ) - Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - ComponentCg[2] );   // Roll
                      VSPGeom().ComponentGroupList(c).CMiy(Time_) += Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Zc() - ComponentCg[2] ) - Fz * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - ComponentCg[0] );   // Pitch
                      VSPGeom().ComponentGroupList(c).CMiz(Time_) += Fy * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Xc() - ComponentCg[0] ) - Fx * ( VSPGeom().Grid(MGLevel_).EdgeList(Edge).Yc() - ComponentCg[1] );   // Yaw
                   
                   }
                   
                }
                                
                // Set trailing edge stall factor for adjoint use later
                
                VSPGeom().Grid(MGLevel_).EdgeList(Edge).TrailingEdgeStallFactor() = StallFactor;

             }
             
          }
          
       }
        
    }

    // Viscous forces for lifting surfaces

    CFox_ = CFoy_ = CFoz_ = 0.;
    
    CMox_ = CMoy_ = CMoz_ = 0.;

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          LE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).LE_Edge());

          TE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
          
          Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
          
          Span = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Length() + VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Length() );

          Velocity = 0.5*( sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[0], 2.)
                               + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[1], 2.)
                               + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[2], 2.) )
                         + sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[0], 2.)
                               + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[1], 2.)
                               + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[2], 2.) ) );
                               
          SVec[0] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Xc();                               
          SVec[1] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Yc();                               
          SVec[2] = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc() - VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Zc(); 
          
          Mag = sqrt(vector_dot(SVec,SVec));
          
          SVec[0] /= Mag;                              
          SVec[1] /= Mag;                              
          SVec[2] /= Mag;                              

          StallFactor = 1. - VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor();

          Gamma = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Gamma();
          
          Cl = ABS(Gamma/(0.5*Velocity*Chord));
          
          Re = MAX(2.,ReCref_ * Velocity * Chord / Cref_);

          pCf_pCl2 = 0.00625 + 0.01*ABS(Clo_2d_);
        
          // Local skin friction
          
          Cf = 2. * 1.5 * 1.037 / pow(log10(Re),2.58) + pCf_pCl2*pow(Cl-Clo_2d_, 2.);

          // Kludge for stall
          
          Cf *= 1. + 100.*StallFactor;
         
          // Viscous Forces
           
          Fxo = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[0];
          Fyo = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[1];
          Fzo = 0.5 * Cf * Velocity * Velocity * Chord * Span * SVec[2];

          CFox_ += Fxo;
          CFoy_ += Fyo;
          CFoz_ += Fzo;
         
          // Viscous Moments ... we assume forces act about centroid of airfoil section
          
          RVeco[0] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Xc() );                               
          RVeco[1] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Yc() );                               
          RVeco[2] = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc() + VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Zc() );           

          CMox_ += Fzo * ( RVeco[1] - XYZcg_[1] ) - Fyo * ( RVeco[2] - XYZcg_[2] );   // Roll
          CMoy_ += Fxo * ( RVeco[2] - XYZcg_[2] ) - Fzo * ( RVeco[0] - XYZcg_[0] );   // Pitch
          CMoz_ += Fyo * ( RVeco[0] - XYZcg_[0] ) - Fxo * ( RVeco[1] - XYZcg_[1] );   // Yaw
          
          // Keep track of viscous loading data

          VSPGeom().VortexSheet(k).TrailingVortex(i).CFox() = Fxo / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).CFoy() = Fyo / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).CFoz() = Fzo / ( 0.5 * Vref_ * Vref_ * Span * Chord);

          VSPGeom().VortexSheet(k).TrailingVortex(i).CMox() = ( Fzo * ( RVeco[1] - XYZcg_[1] ) - Fyo * ( RVeco[2] - XYZcg_[2] ) ) / ( 0.5 * Vref_ * Vref_ * Span * Chord * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).CMoy() = ( Fxo * ( RVeco[2] - XYZcg_[2] ) - Fzo * ( RVeco[0] - XYZcg_[0] ) ) / ( 0.5 * Vref_ * Vref_ * Span * Chord * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).CMoz() = ( Fyo * ( RVeco[0] - XYZcg_[0] ) - Fxo * ( RVeco[1] - XYZcg_[1] ) ) / ( 0.5 * Vref_ * Vref_ * Span * Chord * Chord);

          VSPGeom().VortexSheet(k).TrailingVortex(i).Clo() = ( (-Fxo * SA + Fzo * CA )                 ) / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).Cdo() = ( ( Fxo * CA + Fzo * SA ) * CB - Fyo * SB ) / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).Cso() = ( ( Fxo * CA + Fzo * SA ) * SB + Fyo * CB ) / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          
          // Keep track of inviscid loading data... we assume the forces act at the 1/4 chord

          Fx = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Trefftz_Fx();
          Fy = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Trefftz_Fy();
          Fz = VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Trefftz_Fz();
                   
          RVec[0] = 0.25*VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc() + 0.75*VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Xc();                               
          RVec[1] = 0.25*VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc() + 0.75*VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Yc();                               
          RVec[2] = 0.25*VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc() + 0.75*VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Zc();           

          VSPGeom().VortexSheet(k).TrailingVortex(i).CFix() = Fx / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).CFiy() = Fy / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).CFiz() = Fz / ( 0.5 * Vref_ * Vref_ * Span * Chord);

          VSPGeom().VortexSheet(k).TrailingVortex(i).CMix() = ( Fz * ( RVeco[1] - XYZcg_[1] ) - Fy * ( RVeco[2] - XYZcg_[2] ) ) / ( 0.5 * Vref_ * Vref_ * Span * Chord * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).CMiy() = ( Fx * ( RVeco[2] - XYZcg_[2] ) - Fz * ( RVeco[0] - XYZcg_[0] ) ) / ( 0.5 * Vref_ * Vref_ * Span * Chord * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).CMiz() = ( Fy * ( RVeco[0] - XYZcg_[0] ) - Fx * ( RVeco[1] - XYZcg_[1] ) ) / ( 0.5 * Vref_ * Vref_ * Span * Chord * Chord);
                                                    
          VSPGeom().VortexSheet(k).TrailingVortex(i).Cli() = ( (-Fx * SA + Fz * CA )                ) / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).Cdi() = ( ( Fx * CA + Fz * SA ) * CB - Fy * SB ) / ( 0.5 * Vref_ * Vref_ * Span * Chord);
          VSPGeom().VortexSheet(k).TrailingVortex(i).Csi() = ( ( Fx * CA + Fz * SA ) * SB + Fy * CB ) / ( 0.5 * Vref_ * Vref_ * Span * Chord);
                                  
          // Keep track of component group forces and moments
          
          for ( g = 0 ; g <= 1 ; g++ ) {
             
             if ( g == 0 ) c = 0;
             if ( g == 1 ) c = ComponentInThisGroup[VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).ComponentID()];

             // Forces
               
             VSPGeom().ComponentGroupList(c).CFox() += Fxo;
             VSPGeom().ComponentGroupList(c).CFoy() += Fyo;
             VSPGeom().ComponentGroupList(c).CFoz() += Fzo;

             // Moments ... we assume forces act about centroid of airfoil section
             
             ComponentCg[0] = VSPGeom().ComponentGroupList(c).OVec(0);
             ComponentCg[1] = VSPGeom().ComponentGroupList(c).OVec(1);
             ComponentCg[2] = VSPGeom().ComponentGroupList(c).OVec(2);

             VSPGeom().ComponentGroupList(c).CMox() += Fzo * ( RVeco[1] - ComponentCg[1] ) - Fyo * ( RVeco[2] - ComponentCg[2] );   // Roll
             VSPGeom().ComponentGroupList(c).CMoy() += Fxo * ( RVeco[2] - ComponentCg[2] ) - Fzo * ( RVeco[0] - ComponentCg[0] );   // Pitch
             VSPGeom().ComponentGroupList(c).CMoz() += Fyo * ( RVeco[0] - ComponentCg[0] ) - Fxo * ( RVeco[1] - ComponentCg[1] );   // Yaw

             if ( TimeAccurate_ ) {
             
                // Forces
                  
                VSPGeom().ComponentGroupList(c).CFox(Time_) += Fxo;
                VSPGeom().ComponentGroupList(c).CFoy(Time_) += Fyo;
                VSPGeom().ComponentGroupList(c).CFoz(Time_) += Fzo;
             
                // Moments ... we assume forces act about centroid of airfoil section
                
                ComponentCg[0] = VSPGeom().ComponentGroupList(c).OVec(0);
                ComponentCg[1] = VSPGeom().ComponentGroupList(c).OVec(1);
                ComponentCg[2] = VSPGeom().ComponentGroupList(c).OVec(2);
             
                VSPGeom().ComponentGroupList(c).CMox(Time_) += Fzo * ( RVeco[1] - ComponentCg[1] ) - Fyo * ( RVeco[2] - ComponentCg[2] );   // Roll
                VSPGeom().ComponentGroupList(c).CMoy(Time_) += Fxo * ( RVeco[2] - ComponentCg[2] ) - Fzo * ( RVeco[0] - ComponentCg[0] );   // Pitch
                VSPGeom().ComponentGroupList(c).CMoz(Time_) += Fyo * ( RVeco[0] - ComponentCg[0] ) - Fxo * ( RVeco[1] - ComponentCg[1] );   // Yaw
                
             }     
             
          }     
                         
       }
       
    }
    
    // Add in any flat plate drag areas
    
    if ( Vinf_ > 0. ) {
       
       for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
          
          if ( VSPGeom().ComponentGroupList(c).FlatPlateDragRefReNumber() > 0. ) {
             
             ReFact = pow(log10(VSPGeom().ComponentGroupList(c).FlatPlateDragRefReNumber()),2.58) / pow(log10(ReCref_),2.58);
             
             DeltaDrag = VSPGeom().ComponentGroupList(c).DeltaFlatPlateDragArea() * ReFact * 0.5*Vref_*Vref_;
             
             DeltaFxo = DeltaDrag * FreeStreamVelocity_[0] / Vinf_;
             DeltaFyo = DeltaDrag * FreeStreamVelocity_[1] / Vinf_;
             DeltaFzo = DeltaDrag * FreeStreamVelocity_[2] / Vinf_;
             
             CFox_ += DeltaFxo;
             CFox_ += DeltaFyo;
             CFoy_ += DeltaFzo;
             
             VSPGeom().ComponentGroupList(c).CFox() += DeltaFxo;
             VSPGeom().ComponentGroupList(c).CFoy() += DeltaFyo;
             VSPGeom().ComponentGroupList(c).CFoz() += DeltaFzo;
             
          }
          
       }  
       
    }

    // Now calculate CL, CD, CS
 
    CLi_ = (-CFix_ * SA + CFiz_ * CA );
    CDi_ = ( CFix_ * CA + CFiz_ * SA ) * CB - CFiy_ * SB;
    CSi_ = ( CFix_ * CA + CFiz_ * SA ) * SB + CFiy_ * CB;

    CLo_ = (-CFox_ * SA + CFoz_ * CA );
    CDo_ = ( CFox_ * CA + CFoz_ * SA ) * CB - CFoy_ * SB;
    CSo_ = ( CFox_ * CA + CFoz_ * SA ) * SB + CFoy_ * CB;

    CLw_ = (-CFwx_ * SA + CFwz_ * CA );
    CDw_ = ( CFwx_ * CA + CFwz_ * SA ) * CB - CFwy_ * SB;
    CSw_ = ( CFwx_ * CA + CFwz_ * SA ) * SB + CFwy_ * CB;
    
    // Non dimensonalize
    
    CLi_ /= (0.5*Sref_*Vref_*Vref_);   
    CDi_ /= (0.5*Sref_*Vref_*Vref_);   
    CSi_ /= (0.5*Sref_*Vref_*Vref_);   

    CFix_ /= (0.5*Sref_*Vref_*Vref_);
    CFiy_ /= (0.5*Sref_*Vref_*Vref_);
    CFiz_ /= (0.5*Sref_*Vref_*Vref_);

    CMix_ /= (0.5*Sref_*Bref_*Vref_*Vref_); // Roll
    CMiy_ /= (0.5*Sref_*Cref_*Vref_*Vref_); // Pitch
    CMiz_ /= (0.5*Sref_*Bref_*Vref_*Vref_); // Yaw

    CLo_ /= (0.5*Sref_*Vref_*Vref_);   
    CDo_ /= (0.5*Sref_*Vref_*Vref_);   
    CSo_ /= (0.5*Sref_*Vref_*Vref_);   

    CFox_ /= (0.5*Sref_*Vref_*Vref_);
    CFoy_ /= (0.5*Sref_*Vref_*Vref_);
    CFoz_ /= (0.5*Sref_*Vref_*Vref_);

    CMox_ /= (0.5*Sref_*Bref_*Vref_*Vref_); // Roll
    CMoy_ /= (0.5*Sref_*Cref_*Vref_*Vref_); // Pitch
    CMoz_ /= (0.5*Sref_*Bref_*Vref_*Vref_); // Yaw

    CLw_ /= (0.5*Sref_*Vref_*Vref_);   
    CDw_ /= (0.5*Sref_*Vref_*Vref_);   
    CSw_ /= (0.5*Sref_*Vref_*Vref_);   
    
    CFwx_ /= (0.5*Sref_*Vref_*Vref_);
    CFwy_ /= (0.5*Sref_*Vref_*Vref_);
    CFwz_ /= (0.5*Sref_*Vref_*Vref_);

    // Adjust for symmetry
  
    if ( DoSymmetryPlaneSolve_ ) {
   
          CFix_ *= 2.;
          CFiy_ *= 2.; 
          CFiz_ *= 2.; 
       
          CMix_ *= 2.; 
          CMiy_ *= 2.; 
          CMiz_ *= 2.; 
       
           CLi_ *= 2.; 
           CDi_ *= 2.; 
           CSi_ *= 2.; 

           CLo_ *= 2.; 
           CDo_ *= 2.; 
           CSo_ *= 2.; 

          CFox_ *= 2.;
          CFoy_ *= 2.; 
          CFoz_ *= 2.; 
         
          CMox_ *= 2.; 
          CMoy_ *= 2.; 
          CMoz_ *= 2.; 

        CLw_ *= 2.; 
        CDw_ *= 2.; 
        CSw_ *= 2.; 

       CFwx_ *= 2.;
       CFwy_ *= 2.; 
       CFwz_ *= 2.; 
       
       CMix_ = CMiz_ = CFiy_ = 0.;
       
       CMox_ = CMoz_ = CFoy_ = 0.;
       
       CFwy_ = 0.;
    
    }

    if ( Verbose_ ) printf("CL: %f \n",CLi_);
    if ( Verbose_ ) printf("CD: %f \n",CDi_);

    // Non-dimensionalize the component forces and moments

    for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {

       VSPGeom().ComponentGroupList(c).CFix() /= 0.5*Sref_*Vref_*Vref_; 
       VSPGeom().ComponentGroupList(c).CFiy() /= 0.5*Sref_*Vref_*Vref_; 
       VSPGeom().ComponentGroupList(c).CFiz() /= 0.5*Sref_*Vref_*Vref_; 

       VSPGeom().ComponentGroupList(c).CFiwx() /= 0.5*Sref_*Vref_*Vref_; 
       VSPGeom().ComponentGroupList(c).CFiwy() /= 0.5*Sref_*Vref_*Vref_; 
       VSPGeom().ComponentGroupList(c).CFiwz() /= 0.5*Sref_*Vref_*Vref_; 
       
       VSPGeom().ComponentGroupList(c).CMix() /= 0.5*Bref_*Sref_*Vref_*Vref_;
       VSPGeom().ComponentGroupList(c).CMiy() /= 0.5*Cref_*Sref_*Vref_*Vref_;
       VSPGeom().ComponentGroupList(c).CMiz() /= 0.5*Bref_*Sref_*Vref_*Vref_;

       VSPGeom().ComponentGroupList(c).CFox() /= 0.5*Sref_*Vref_*Vref_; 
       VSPGeom().ComponentGroupList(c).CFoy() /= 0.5*Sref_*Vref_*Vref_; 
       VSPGeom().ComponentGroupList(c).CFoz() /= 0.5*Sref_*Vref_*Vref_; 

       VSPGeom().ComponentGroupList(c).CMox() /= 0.5*Bref_*Sref_*Vref_*Vref_;
       VSPGeom().ComponentGroupList(c).CMoy() /= 0.5*Cref_*Sref_*Vref_*Vref_;
       VSPGeom().ComponentGroupList(c).CMoz() /= 0.5*Bref_*Sref_*Vref_*Vref_;
       
       // Now calculate CL, CD, CS
      
       VSPGeom().ComponentGroupList(c).CLi() = (-VSPGeom().ComponentGroupList(c).CFix() * SA + VSPGeom().ComponentGroupList(c).CFiz() * CA );       
       VSPGeom().ComponentGroupList(c).CDi() = ( VSPGeom().ComponentGroupList(c).CFix() * CA + VSPGeom().ComponentGroupList(c).CFiz() * SA ) * CB - VSPGeom().ComponentGroupList(c).CFiy() * SB;       
       VSPGeom().ComponentGroupList(c).CSi() = ( VSPGeom().ComponentGroupList(c).CFix() * CA + VSPGeom().ComponentGroupList(c).CFiz() * SA ) * SB + VSPGeom().ComponentGroupList(c).CFiy() * CB;

       VSPGeom().ComponentGroupList(c).CLo() = (-VSPGeom().ComponentGroupList(c).CFox() * SA + VSPGeom().ComponentGroupList(c).CFoz() * CA );       
       VSPGeom().ComponentGroupList(c).CDo() = ( VSPGeom().ComponentGroupList(c).CFox() * CA + VSPGeom().ComponentGroupList(c).CFoz() * SA ) * CB - VSPGeom().ComponentGroupList(c).CFoy() * SB;       
       VSPGeom().ComponentGroupList(c).CSo() = ( VSPGeom().ComponentGroupList(c).CFox() * CA + VSPGeom().ComponentGroupList(c).CFoz() * SA ) * SB + VSPGeom().ComponentGroupList(c).CFoy() * CB;

       VSPGeom().ComponentGroupList(c).CLiw() = (-VSPGeom().ComponentGroupList(c).CFiwx() * SA + VSPGeom().ComponentGroupList(c).CFiwz() * CA );       
       VSPGeom().ComponentGroupList(c).CDiw() = ( VSPGeom().ComponentGroupList(c).CFiwx() * CA + VSPGeom().ComponentGroupList(c).CFiwz() * SA ) * CB - VSPGeom().ComponentGroupList(c).CFiwy() * SB;       
       VSPGeom().ComponentGroupList(c).CSiw() = ( VSPGeom().ComponentGroupList(c).CFiwx() * CA + VSPGeom().ComponentGroupList(c).CFiwz() * SA ) * SB + VSPGeom().ComponentGroupList(c).CFiwy() * CB;

       if ( TimeAccurate_ ) {

          VSPGeom().ComponentGroupList(c).CFix(Time_) /= 0.5*Sref_*Vref_*Vref_; 
          VSPGeom().ComponentGroupList(c).CFiy(Time_) /= 0.5*Sref_*Vref_*Vref_; 
          VSPGeom().ComponentGroupList(c).CFiz(Time_) /= 0.5*Sref_*Vref_*Vref_; 

          VSPGeom().ComponentGroupList(c).CFiwx(Time_) /= 0.5*Sref_*Vref_*Vref_; 
          VSPGeom().ComponentGroupList(c).CFiwy(Time_) /= 0.5*Sref_*Vref_*Vref_; 
          VSPGeom().ComponentGroupList(c).CFiwz(Time_) /= 0.5*Sref_*Vref_*Vref_; 
                                                         
          VSPGeom().ComponentGroupList(c).CMix(Time_) /= 0.5*Bref_*Sref_*Vref_*Vref_;
          VSPGeom().ComponentGroupList(c).CMiy(Time_) /= 0.5*Cref_*Sref_*Vref_*Vref_;
          VSPGeom().ComponentGroupList(c).CMiz(Time_) /= 0.5*Bref_*Sref_*Vref_*Vref_;
                                               
          VSPGeom().ComponentGroupList(c).CFox(Time_) /= 0.5*Sref_*Vref_*Vref_; 
          VSPGeom().ComponentGroupList(c).CFoy(Time_) /= 0.5*Sref_*Vref_*Vref_; 
          VSPGeom().ComponentGroupList(c).CFoz(Time_) /= 0.5*Sref_*Vref_*Vref_; 
                                               
          VSPGeom().ComponentGroupList(c).CMox(Time_) /= 0.5*Bref_*Sref_*Vref_*Vref_;
          VSPGeom().ComponentGroupList(c).CMoy(Time_) /= 0.5*Cref_*Sref_*Vref_*Vref_;
          VSPGeom().ComponentGroupList(c).CMoz(Time_) /= 0.5*Bref_*Sref_*Vref_*Vref_;
          
          // Now calculate CL, CD, CS
          
          VSPGeom().ComponentGroupList(c).CLi(Time_) = (-VSPGeom().ComponentGroupList(c).CFix() * SA + VSPGeom().ComponentGroupList(c).CFiz() * CA );       
          VSPGeom().ComponentGroupList(c).CDi(Time_) = ( VSPGeom().ComponentGroupList(c).CFix() * CA + VSPGeom().ComponentGroupList(c).CFiz() * SA ) * CB - VSPGeom().ComponentGroupList(c).CFiy() * SB;       
          VSPGeom().ComponentGroupList(c).CSi(Time_) = ( VSPGeom().ComponentGroupList(c).CFix() * CA + VSPGeom().ComponentGroupList(c).CFiz() * SA ) * SB + VSPGeom().ComponentGroupList(c).CFiy() * CB;
                                              
          VSPGeom().ComponentGroupList(c).CLo(Time_) = (-VSPGeom().ComponentGroupList(c).CFox() * SA + VSPGeom().ComponentGroupList(c).CFoz() * CA );       
          VSPGeom().ComponentGroupList(c).CDo(Time_) = ( VSPGeom().ComponentGroupList(c).CFox() * CA + VSPGeom().ComponentGroupList(c).CFoz() * SA ) * CB - VSPGeom().ComponentGroupList(c).CFoy() * SB;       
          VSPGeom().ComponentGroupList(c).CSo(Time_) = ( VSPGeom().ComponentGroupList(c).CFox() * CA + VSPGeom().ComponentGroupList(c).CFoz() * SA ) * SB + VSPGeom().ComponentGroupList(c).CFoy() * CB;

          VSPGeom().ComponentGroupList(c).CLiw(Time_) = (-VSPGeom().ComponentGroupList(c).CFiwx() * SA + VSPGeom().ComponentGroupList(c).CFiwz() * CA );       
          VSPGeom().ComponentGroupList(c).CDiw(Time_) = ( VSPGeom().ComponentGroupList(c).CFiwx() * CA + VSPGeom().ComponentGroupList(c).CFiwz() * SA ) * CB - VSPGeom().ComponentGroupList(c).CFiwy() * SB;       
          VSPGeom().ComponentGroupList(c).CSiw(Time_) = ( VSPGeom().ComponentGroupList(c).CFiwx() * CA + VSPGeom().ComponentGroupList(c).CFiwz() * SA ) * SB + VSPGeom().ComponentGroupList(c).CFiwy() * CB;
   
       }
               
    }
    
    delete [] ComponentInThisGroup;

}

/*##############################################################################
#                                                                              #
#                    VSP_SOLVER CalculateSpanWiseLoading                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateSpanWiseLoading(void)
{
 
    int c, i, k, p,  LE_Edge, TE_Edge, IsARotor, ComponentID, Group;
    double Span, Chord, Velocity, Time;
    
    double Diameter, RPM, Angle, Vec[3];
    double Thrusto, Momento, Powero;
    double Thrusti, Momenti, Poweri;
    double Thrust , Moment , Power ;
    
    double J, CT, CQ, CP, EtaP, CT_h, CQ_h, CP_h, FOM;

    // Write out column labels
    
    if ( !TimeAccurate_ ) {

                      // 1234567890123 12345678901 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789  123456789 
       fprintf(LoadFile_,"Iter         VortexSheet TrailVort     Xavg      Yavg      Zavg      Span     Chord      Area    V/Vref      Cl        Cd        Cs       Clo       Cdo       Cso       Cli       Cdi       Csi        Cx        Cy       Cz        Cxo       Cyo       Czo       Cxi       Cyi       Czi       Cmx       Cmy       Cmz      Cmxo      Cmyo      Cmzo      Cmxi      Cmyi      Cmzi     StallFact ");

    }
    
    else {
       
                      // 1234567890123 12345678901 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789  123456789 
       fprintf(LoadFile_,"Time         VortexSheet TrailVort     Xavg      Yavg      Zavg      Span     Chord      Area    V/Vref      Cl        Cd        Cs       Clo       Cdo       Cso       Cli       Cdi       Csi        Cx        Cy       Cz        Cxo       Cyo       Czo       Cxi       Cyi       Czi       Cmx       Cmy       Cmz      Cmxo      Cmyo      Cmzo      Cmxi      Cmyi      Cmzi     StallFact ");

    }       
       
    fprintf(LoadFile_,"Time/Iter     VortexSheet TrailVort     Xavg      Yavg      Zavg      Span     Chord      Area    V/Vref      Cl        Cd        Cs       Clo       Cdo       Cso       Cli       Cdi       Csi        Cx        Cy       Cz        Cxo       Cyo       Czo       Cxi       Cyi       Czi       Cmx       Cmy       Cmz      Cmxo      Cmyo      Cmzo      Cmxi      Cmyi      Cmzi     StallFact ");
                    // 1234567890 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123 1234567890123
    fprintf(LoadFile_," IsARotor     Diameter        RPM         Thrust        Thrusto       Thrusti        Power         Powero        Poweri         Moment       Momento       Momenti         J             CT            CQ            CP           ETAP          CT_h           CQ_H         CP_H          FOM          Angle \n");
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
    
       for ( i = 1 ; i < VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
          
          // Figure out is this vortex sheet comes off a rotor...
          
          ComponentID = VSPGeom().VortexSheet(k).TrailingVortex(i).ComponentID();
          
          IsARotor = 0;
          
          for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {

             if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) {
             
                for ( p = 1 ; p <= VSPGeom().ComponentGroupList(c).NumberOfComponents() ; p++ ) {
                
                   if ( VSPGeom().ComponentGroupList(c).ComponentList(p) == ComponentID ) {
                      
                      IsARotor = 1;
                      
                      Group = c;
                      
                   }
                   
                }
                
             }
          } 
                                
          LE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).LE_Edge());

          TE_Edge = ABS(VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Edge());
          
          Chord = VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord();
     
          Span = 0.5*( VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).Length() + VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Length() );

          Velocity = 0.5*( sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[0], 2.)
                               + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[1], 2.)
                               + pow(VSPGeom().Grid(MGLevel_).EdgeList(LE_Edge).LocalFreeStreamVelocity()[2], 2.) )
                         + sqrt( pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[0], 2.)
                               + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[1], 2.)
                               + pow(VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).LocalFreeStreamVelocity()[2], 2.) ) )/Vref_;

          Diameter = RPM = Angle = 0.;
          Thrusto = Momento = Powero = 0.;
          Thrusti = Momenti = Poweri = 0.;
          Thrust  = Moment  = Power  = 0.;
          
          J = CT = CQ = CP = EtaP = CT_h = CQ_h = CP_h = FOM = 0.;
  
          if ( IsARotor ) {
           
             Diameter = VSPGeom().ComponentGroupList(Group).RotorDiameter();
             
             RPM = VSPGeom().ComponentGroupList(Group).Omega() * 60 / ( 2.*PI );

             Angle = VSPGeom().ComponentGroupList(Group).TotalRotationAngle()/TORAD;   
             
             Vec[0] = VSPGeom().VortexSheet(k).TrailingVortex(i).CFox() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord;
             Vec[1] = VSPGeom().VortexSheet(k).TrailingVortex(i).CFoy() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord;
             Vec[2] = VSPGeom().VortexSheet(k).TrailingVortex(i).CFoz() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord;
             
             Thrusto = vector_dot(Vec, VSPGeom().ComponentGroupList(Group).RVec());
             
             Vec[0] = VSPGeom().VortexSheet(k).TrailingVortex(i).CFix() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord;
             Vec[1] = VSPGeom().VortexSheet(k).TrailingVortex(i).CFiy() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord;
             Vec[2] = VSPGeom().VortexSheet(k).TrailingVortex(i).CFiz() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord;
             
             Thrusti = vector_dot(Vec, VSPGeom().ComponentGroupList(Group).RVec());
                 
             Thrust = Thrusto + Thrusti;

             // Moments
             
             Vec[0] = VSPGeom().VortexSheet(k).TrailingVortex(i).CMox() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord * Chord;
             Vec[1] = VSPGeom().VortexSheet(k).TrailingVortex(i).CMoy() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord * Chord;
             Vec[2] = VSPGeom().VortexSheet(k).TrailingVortex(i).CMoz() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord * Chord;   
             
             Momento = -vector_dot(Vec, VSPGeom().ComponentGroupList(Group).RVec());
               
             Vec[0] = VSPGeom().VortexSheet(k).TrailingVortex(i).CMix() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord * Chord;
             Vec[1] = VSPGeom().VortexSheet(k).TrailingVortex(i).CMiy() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord * Chord;
             Vec[2] = VSPGeom().VortexSheet(k).TrailingVortex(i).CMiz() * 0.5 * Density_ * Vref_ * Vref_ * Span * Chord * Chord;   
             
             Momenti = -vector_dot(Vec, VSPGeom().ComponentGroupList(Group).RVec());

             Moment = Momento + Momenti;

             // Power
             
             Powero = Momento * VSPGeom().ComponentGroupList(Group).Omega();
             
             Poweri  = Momenti * VSPGeom().ComponentGroupList(Group).Omega();

             Power = Powero + Poweri;
             
             CalculateRotorCoefficientsFromForces(Thrust, Moment, Diameter, RPM, J, CT, CQ, CP, EtaP, CT_h, CQ_h, CP_h, FOM);                                                    

          }       
                        
          Time = CurrentTime_;
          
          if ( NoiseAnalysis_ ) Time = CurrentNoiseTime_ + NoiseTimeShift_;
          
          if ( !TimeAccurate_ ) {
             
             Time = CurrentWakeIteration_;          
          
             fprintf(LoadFile_,"%-13d ",CurrentWakeIteration_-1);
             
          }
          
          else {
             
             fprintf(LoadFile_,"%-13.8f ",Time);
             
          }             
                     
          fprintf(LoadFile_,"%-11d %-9d %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf ",
                  k,
                  i,
                  VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Xc(),    
                  VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Yc(),    
                  VSPGeom().Grid(MGLevel_).EdgeList(TE_Edge).Zc(),      
                  Span,                    
                  VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).LocalChord() * Span,

                  Velocity,
                  
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Clo() + VSPGeom().VortexSheet(k).TrailingVortex(i).Cli(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Cdo() + VSPGeom().VortexSheet(k).TrailingVortex(i).Cdi(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Cso() + VSPGeom().VortexSheet(k).TrailingVortex(i).Csi(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Clo(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Cdo(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Cso(),                     
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Cli(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Cdi(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).Csi(),     
                                                            
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFox() + VSPGeom().VortexSheet(k).TrailingVortex(i).CFix(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFoy() + VSPGeom().VortexSheet(k).TrailingVortex(i).CFiy(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFoz() + VSPGeom().VortexSheet(k).TrailingVortex(i).CFiz(),  
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFox(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFoy(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFoz(),  
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFix(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFiy(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CFiz(),  
                                                            
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMox() + VSPGeom().VortexSheet(k).TrailingVortex(i).CMix(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMoy() + VSPGeom().VortexSheet(k).TrailingVortex(i).CMiy(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMoz() + VSPGeom().VortexSheet(k).TrailingVortex(i).CMiz(),  
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMox(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMoy(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMoz(),  
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMix(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMiy(),
                  VSPGeom().VortexSheet(k).TrailingVortex(i).CMiz(),
                  
                  VSPGeom().VortexSheet(k).TrailingVortex(i).StallFactor());
                  
                  // Rotor data
                  //               1      2      3      4      5      6      7      8      9      10     11     12     13     14     15     16     17     18     19     29     21
          fprintf(LoadFile_,"%10d %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf %13.5lf \n",
                  
                  IsARotor,
 
                  Diameter,
                  RPM,
                  Thrust,
                  Thrusto,
                  Thrusti,
                  Power,
                  Powero,
                  Poweri,
                  Moment,
                  Momento,
                  Momenti,
                  J,
                  CT,
                  CQ,
                  CP,
                  EtaP,
                  CT_h,
                  CQ_h,
                  CP_h,
                  FOM,
                  VSPGeom().ComponentGroupList(Group).TotalRotationAngle()/TORAD);   
                                                            
       }

       fprintf(LoadFile_,"\n\n\n\n");                  
        
    }

    fprintf(LoadFile_,"\n\n\n");
           
}
         
/*##############################################################################
#                                                                              #
#                         VSP_SOLVER WriteFEM2DGeometry                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteFEM2DGeometry(void)
{

    int j;
    int number_of_nodes, number_of_tris;
    char LoadFileName[MAX_CHAR_SIZE];

    // Open the fem load file
    
    snprintf(LoadFileName,sizeof(LoadFileName)*sizeof(char),"%s.fem2d",FileName_);
    
    if ( (FEM2DLoadFile_ = fopen(LoadFileName, "w")) == NULL ) {

       printf("Could not open the fem load file for output! \n");

       exit(1);

    }
    
    // Write out header 

    number_of_tris  = VSPGeom().Grid(0).NumberOfLoops();
    number_of_nodes = VSPGeom().Grid(0).NumberOfNodes();

    fprintf(FEM2DLoadFile_,"NumberOfNodes:%d \n",number_of_nodes);
    fprintf(FEM2DLoadFile_,"NumberOfTris: %d \n",number_of_tris);

    // Write out node data
    
    fprintf(FEM2DLoadFile_,"Nodal data: \n");
    fprintf(FEM2DLoadFile_,"X, Y, Z \n");

    for ( j = 1 ; j <= VSPGeom().Grid(0).NumberOfNodes() ; j++ ) {

       fprintf(FEM2DLoadFile_,"%f %f %f \n",
        VSPGeom().Grid().NodeList(j).x(),
        VSPGeom().Grid().NodeList(j).y(),
        VSPGeom().Grid().NodeList(j).z());
       
    }
        
    // Write out triangulated surface mesh
    
    fprintf(FEM2DLoadFile_,"Tri data: \n");
    fprintf(FEM2DLoadFile_,"Node1, Node2, Node3, SurfType, SurfID, Area, Nx, Ny, Nz \n");

    for ( j = 1 ; j <= VSPGeom().Grid(0).NumberOfLoops() ; j++ ) {
     
       fprintf(FEM2DLoadFile_,"%d %d %d %d %d %f %f %f %f \n",
         VSPGeom().Grid().LoopList(j).Node1(), 
         VSPGeom().Grid().LoopList(j).Node2(), 
         VSPGeom().Grid().LoopList(j).Node3(), 
         VSPGeom().Grid().LoopList(j).SurfaceType(),
         VSPGeom().Grid().LoopList(j).SurfaceID(), 
         VSPGeom().Grid().LoopList(j).Area(),
         VSPGeom().Grid().LoopList(j).Nx(),
         VSPGeom().Grid().LoopList(j).Ny(),
         VSPGeom().Grid().LoopList(j).Nz());

    }

}

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER WriteFEM2DSolution                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteFEM2DSolution(void)
{

    int j;

    fprintf(FEM2DLoadFile_,"\n");
    
    WriteCaseHeader(FEM2DLoadFile_);
            
    // Write out solution

    fprintf(FEM2DLoadFile_,"Solution Data\n");    
    fprintf(FEM2DLoadFile_,"Tri, DeltaCp_or_Cp \n");

    for ( j = 1 ; j <= VSPGeom().Grid(0).NumberOfLoops() ; j++ ) {

       fprintf(FEM2DLoadFile_,"%d %f \n", j, VSPGeom().Grid().LoopList(j).dCp());

    }

}

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER WriteOutTecPlotFile                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteOutTecPlotFile(void)
{

    int j;
    char LoadFileName[MAX_CHAR_SIZE];
    FILE *TecFile;

    // Open the fem load file
    
    snprintf(LoadFileName,sizeof(LoadFileName)*sizeof(char),"%s.tec.dat",FileName_);
    
    if ( (TecFile = fopen(LoadFileName, "w")) == NULL ) {

       printf("Could not open the fem load file for output! \n");

       exit(1);

    }
    
    // Write out header 

    fprintf(TecFile,"VARIABLES=x,y,z,Cp \n");
    fprintf(TecFile,"ZONE N=%d, E=%d, T=\"wall\", VARLOCATION=([1-3]=NODAL,[4]=CELLCENTERED) \n", 
            VSPGeom().Grid(0).NumberOfSurfaceNodes(),
            VSPGeom().Grid(0).NumberOfSurfaceLoops());
    fprintf(TecFile,"ZONETYPE=FETRIANGLE, DATAPACKING=BLOCK \n");
    fprintf(TecFile,"SOLUTIONTIME =  0., STRANDID = 0 \n");

    // Nodal x values
    
    for ( j = 1 ; j <= VSPGeom().Grid(0).NumberOfSurfaceNodes() ; j++ ) {

       fprintf(TecFile,"%f \n", VSPGeom().Grid(0).NodeList(j).x());
  
    }

    // Nodal y values

    for ( j = 1 ; j <= VSPGeom().Grid(0).NumberOfSurfaceNodes() ; j++ ) {

       fprintf(TecFile,"%f \n", VSPGeom().Grid(0).NodeList(j).y());
       
    }

    // Nodal z values
    
    for ( j = 1 ; j <= VSPGeom().Grid(0).NumberOfSurfaceNodes() ; j++ ) {

       fprintf(TecFile,"%f \n", VSPGeom().Grid(0).NodeList(j).z());

    }

    // Cp tri values

    for ( j = 1 ; j <= VSPGeom().Grid(0).NumberOfSurfaceLoops() ; j++ ) {

       fprintf(TecFile,"%f \n", VSPGeom().Grid(0).LoopList(j).dCp());

    }
    
    // Connectivity
    
    for ( j = 1 ; j <= VSPGeom().Grid(0).NumberOfSurfaceLoops() ; j++ ) {

       fprintf(TecFile,"%d %d %d \n",
       VSPGeom().Grid(0).LoopList(j).Node1(),
       VSPGeom().Grid(0).LoopList(j).Node2(),
       VSPGeom().Grid(0).LoopList(j).Node3());
       
    }    
    
    fclose(TecFile);

}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER CreateQuadTreePlaneDataStructures                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateQuadTreePlaneDataStructures(void)
{
   
    int i, j, k, p, q, r, InsertedPoints, Direction;
    double s, dt, t, v1, v2, xyz[3], xyz1[3], xyz2[3];
    double Value, Length, Center[3], Normal[3];
    double Radius, Arb[3], RadiusVector[3], dTheta, Theta;
    double xmin, xmax, ymin, ymax, zmin, zmax, distance, Mag;
    QUAT Quat, InvQuat, Vec;    
    
    printf("Creating quad tree velocity survey data structures... \n");
    
    if ( QuadTreeList_ == NULL ) {
       
       QuadTreeList_ = new QUAD_TREE[NumberOfQuadTrees_ + 1];
       
    }
    
    else {
       
       for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {
          
          QuadTreeList_[j].ClearTree();
          
       }
       
    }
    
    printf("Xmin_: %f \n",Xmin_);
    printf("Xmax_: %f \n",Xmax_);

    printf("Ymin_: %f \n",Ymin_);
    printf("Ymax_: %f \n",Ymax_);
    
    printf("Zmin_: %f \n",Zmin_);
    printf("Zmax_: %f \n",Zmax_);

    Length = MAX3(Xmax_ - Xmin_, Ymax_ - Ymin_, Zmax_ - Zmin_);
    
    distance = 5.*Length;

    xmin = Xmin_ - distance;
    xmax = Xmax_ + distance;
    ymin = Ymin_ - distance;
    ymax = Ymax_ + distance;
    zmin = Zmin_ - distance;
    zmax = Zmax_ + distance;

    if ( DoSymmetryPlaneSolve_ ) ymin = 0.;
           
    for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {
       
       printf("Working on quad tree: %d \n",j);fflush(NULL);

       Value = QuadTreeValue(j);
    
       QuadTreeList_[j].Direction() = Direction = QuadTreeDirection(j);

       printf("Direction, Value: %d %f \n",Direction,Value);
                      
       QuadTreeList_[j].InitializeTree(xmin, xmax, ymin, ymax, zmin, zmax, Value);
           
       InsertedPoints = 0;
       
       // Insert geometry points
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
          
          if ( VSPGeom().ModelType() == PANEL_MODEL || VSPGeom().Grid(MGLevel_).EdgeList(i).IsBoundaryEdge() ) {
          
             if ( Direction == 1 ) {
                
                v1 = VSPGeom().Grid(MGLevel_).EdgeList(i).X1();
                v2 = VSPGeom().Grid(MGLevel_).EdgeList(i).X2();
      
             }
             
             else if ( Direction == 2 ) {
                
                v1 = VSPGeom().Grid(MGLevel_).EdgeList(i).Y1();
                v2 = VSPGeom().Grid(MGLevel_).EdgeList(i).Y2();
      
             }       
             
             else if ( Direction == 3 ) {
                
                v1 = VSPGeom().Grid(MGLevel_).EdgeList(i).Z1();
                v2 = VSPGeom().Grid(MGLevel_).EdgeList(i).Z2();
      
             }  
         
             if ( Value >= MIN(v1,v2) && Value <= MAX(v1,v2) ) {
                
                if ( v1 != v2 ) {
      
                   s = (Value - v1)/(v2 - v1);
                   
                }
                
                else {
                   
                   s = 0.;
                   
                }
             
                xyz[0] = VSPGeom().Grid(MGLevel_).EdgeList(i).X1() + s*(VSPGeom().Grid(MGLevel_).EdgeList(i).X2() - VSPGeom().Grid(MGLevel_).EdgeList(i).X1());
                xyz[1] = VSPGeom().Grid(MGLevel_).EdgeList(i).Y1() + s*(VSPGeom().Grid(MGLevel_).EdgeList(i).Y2() - VSPGeom().Grid(MGLevel_).EdgeList(i).Y1());
                xyz[2] = VSPGeom().Grid(MGLevel_).EdgeList(i).Z1() + s*(VSPGeom().Grid(MGLevel_).EdgeList(i).Z2() - VSPGeom().Grid(MGLevel_).EdgeList(i).Z1());
      
                // Insert the point
                
                InsertedPoints += QuadTreeList_[j].InsertPoint(xyz, i);
      
             }
             
          }
          
       }

       // Insert jet exhaust points, streamwise direction
    
       for ( p = 1 ; p <= NumberOfEngineFaces_ ; p++ ) {
    
          if ( EngineFace(p).SurfaceType() == NOZZLE_FACE ) {
             
             Center[0] = EngineFace(p).NozzleXYZ(0);
             Center[1] = EngineFace(p).NozzleXYZ(1);
             Center[2] = EngineFace(p).NozzleXYZ(2);
    
             Normal[0] = EngineFace(p).NozzleNormal(0);
             Normal[1] = EngineFace(p).NozzleNormal(1);
             Normal[2] = EngineFace(p).NozzleNormal(2);
             
             Radius = EngineFace(p).NozzleRadius();
             
             // Arbitrary vector
             
             Arb[0] = 1.;
             Arb[1] = 2.;
             Arb[2] = 3.;
             
             // Cross Arb into Normal to get radius vector
             
             vector_cross(Normal, Arb, RadiusVector);
             
             Mag = sqrt(vector_dot(RadiusVector,RadiusVector));
             
             RadiusVector[0] /= Mag;
             RadiusVector[1] /= Mag;
             RadiusVector[2] /= Mag;
             
             RadiusVector[0] *= Radius;
             RadiusVector[1] *= Radius;
             RadiusVector[2] *= Radius;           
             
             dTheta = 2.*PI/(16-1);
             
             for ( r = 1 ; r <= 16 ; r++ ) {
                
                Theta = (r-1)*dTheta;
                
                Quat.FormRotationQuat(Normal,Theta);
                
                InvQuat = Quat;
                
                InvQuat.FormInverse();
               
                // Rotate about the normal vector
                
                Vec(0) = RadiusVector[0];
                Vec(1) = RadiusVector[1];
                Vec(2) = RadiusVector[2];
                
                Vec = Quat * Vec * InvQuat;
                
                xyz[0] = Vec(0) + Center[0];
                xyz[1] = Vec(1) + Center[1];
                xyz[2] = Vec(2) + Center[2];
         
                dt = xmax/(VSPGeom().NumberOfWakeTrailingNodes() -1);
                 
                v1 = v2 = 0.;
                
                for ( k = 1 ; k <= VSPGeom().NumberOfWakeTrailingNodes() ; k++ ) {
                   
                   if ( Direction == 1 ) {
                      
                      v1 = xyz[0] + (k-1) * dt * Normal[0];
                      v2 = xyz[0] + (k  ) * dt * Normal[0];
                   
                   }
                   
                   else if ( Direction == 2 ) {
                      
                      v1 = xyz[1] + (k-1) * dt * Normal[1];
                      v2 = xyz[1] + (k  ) * dt * Normal[1];
                   
                   }       
                   
                   else if ( Direction == 3 ) {
                      
                      v1 = xyz[2] + (k-1) * dt * Normal[2];
                      v2 = xyz[2] + (k  ) * dt * Normal[2];
                   
                   }  
                   
                   if ( Value >= MIN(v1,v2) && Value <= MAX(v1,v2) ) {
                   
                      if ( v1 != v2 ) {
                      
                         s = (Value - v1)/(v2 - v1);
                         
                      }
                      
                      else {
                         
                         s = 0.;
                         
                      }
                      
                      xyz[0] = xyz[0] + (k-1) * dt * Normal[0] + s*( dt * Normal[0] );
                      xyz[1] = xyz[1] + (k-1) * dt * Normal[1] + s*( dt * Normal[1] );
                      xyz[2] = xyz[2] + (k-1) * dt * Normal[2] + s*( dt * Normal[2] );
                      
                      if ( Direction == 1 ) xyz[0] = Value;
                      if ( Direction == 2 ) xyz[1] = Value;
                      if ( Direction == 3 ) xyz[2] = Value;
                      
                      // Insert the point
                      
                      InsertedPoints += QuadTreeList_[j].InsertPoint(xyz, i);
                   
                   }
                   
                }
                
             }
             
          }
                    
       }    

       // Insert jet exhaust points... circumferential
    
       for ( p = 1 ; p <= NumberOfEngineFaces_ ; p++ ) {
    
          if ( EngineFace(p).SurfaceType() == NOZZLE_FACE ) {
             
             Center[0] = EngineFace(p).NozzleXYZ(0);
             Center[1] = EngineFace(p).NozzleXYZ(1);
             Center[2] = EngineFace(p).NozzleXYZ(2);
    
             Normal[0] = EngineFace(p).NozzleNormal(0);
             Normal[1] = EngineFace(p).NozzleNormal(1);
             Normal[2] = EngineFace(p).NozzleNormal(2);
             
             Radius = EngineFace(p).NozzleRadius();
             
             // Arbitrary vector
             
             Arb[0] = 1.;
             Arb[1] = 2.;
             Arb[2] = 3.;
             
             // Cross Arb into Normal to get radius vector
             
             vector_cross(Normal, Arb, RadiusVector);
             
             Mag = sqrt(vector_dot(RadiusVector,RadiusVector));
             
             RadiusVector[0] /= Mag;
             RadiusVector[1] /= Mag;
             RadiusVector[2] /= Mag;
             
             RadiusVector[0] *= Radius;
             RadiusVector[1] *= Radius;
             RadiusVector[2] *= Radius;           
             
             dTheta = 2.*PI/(16-1);
             
             for ( r = 1 ; r <= 15 ; r++ ) {
                
                Theta = (r-1)*dTheta;
                
                Quat.FormRotationQuat(Normal,Theta);
                
                InvQuat = Quat;
                
                InvQuat.FormInverse();
               
                // Rotate about the normal vector
                
                Vec(0) = RadiusVector[0];
                Vec(1) = RadiusVector[1];
                Vec(2) = RadiusVector[2];
                
                Vec = Quat * Vec * InvQuat;
                
                xyz1[0] = Vec(0) + Center[0];
                xyz1[1] = Vec(1) + Center[1];
                xyz1[2] = Vec(2) + Center[2];
             
                Theta = (r  )*dTheta;
                
                Quat.FormRotationQuat(Normal,Theta);
                
                InvQuat = Quat;
                
                InvQuat.FormInverse();

                Vec(0) = RadiusVector[0];
                Vec(1) = RadiusVector[1];
                Vec(2) = RadiusVector[2];
                                                
                Vec = Quat * Vec * InvQuat;
                
                xyz2[0] = Vec(0) + Center[0];
                xyz2[1] = Vec(1) + Center[1];
                xyz2[2] = Vec(2) + Center[2];      
                                       
                dt = xmax/(VSPGeom().NumberOfWakeTrailingNodes() -1);
                 
                for ( k = 1 ; k <= VSPGeom().NumberOfWakeTrailingNodes() ; k++ ) {
                   
                   v1 = v2 = 0.;
                   
                   if ( Direction == 1 ) {
                      
                      v1 = xyz1[0] + (k-1) * dt * Normal[0];
                      v2 = xyz2[0] + (k-1) * dt * Normal[0];
                   
                   }
                   
                   else if ( Direction == 2 ) {
                      
                      v1 = xyz1[1] + (k-1) * dt * Normal[1];
                      v2 = xyz2[1] + (k-1) * dt * Normal[1];
                   
                   }       
                   
                   else if ( Direction == 3 ) {
                      
                      v1 = xyz1[2] + (k-1) * dt * Normal[2];
                      v2 = xyz2[2] + (k-1) * dt * Normal[2];
                   
                   }  
                   
                   if ( Value >= MIN(v1,v2) && Value <= MAX(v1,v2) ) {
                   
                      if ( v1 != v2 ) {
                      
                         s = (Value - v1)/(v2 - v1);
                         
                      }
                      
                      else {
                         
                         s = 0.;
                         
                      }
                      
                      xyz[0] = xyz1[0] + (k-1) * dt * Normal[0] + s*( xyz2[0] - xyz1[0] );
                      xyz[1] = xyz1[1] + (k-1) * dt * Normal[1] + s*( xyz2[0] - xyz1[0] ); 
                      xyz[2] = xyz1[2] + (k-1) * dt * Normal[2] + s*( xyz2[0] - xyz1[0] ); 
                      
                      if ( Direction == 1 ) xyz[0] = Value;
                      if ( Direction == 2 ) xyz[1] = Value;
                      if ( Direction == 3 ) xyz[2] = Value;
                      
                      // Insert the point
                      
                      InsertedPoints += QuadTreeList_[j].InsertPoint(xyz, i);
                   
                   }
                   
                }
                
             }
             
          }
                    
       }    
                  
       printf("Inserted: %d points \n",InsertedPoints);fflush(NULL);
   
       QuadTreeList_[j].BufferTree(QuadTreeBufferLevels_);
       
    }
    
    // Mark nodes inside bodies
    
    //int Inside;
    //
    //if ( VSPGeom().ModelType() != VLM_MODEL ) {
    //
    //   for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {
    //      
    //      printf("Checking quad tree: %d for points inside the body... \n",j);fflush(NULL);
    //      
    //      Inside = 0;
    //
    //      for ( i = 1 ; i <= QuadTreeList_[j].NumberOfNodes() ; i++ ) {
    //   
    //         xyz[0] = QuadTreeList_[j].x(i);
    //         xyz[1] = QuadTreeList_[j].y(i);
    //         xyz[2] = QuadTreeList_[j].z(i);
    //         
    //         if ( InsideBody(xyz, distance) ) {
    //            
    //            QuadTreeList_[j].NodeInsideBody(i) = 1;
    //            
    //            Inside++;
    //            
    //         }
    //         
    //      }
    //      
    //      printf("Found %d nodes inside body out of %d \n",Inside,QuadTreeList_[j].NumberOfNodes());
    //      
    //   }
    //   
    //}

}

/*##############################################################################
#                                                                              #
#                           VSP_SOLVER InsideBody                              #
#                                                                              #
##############################################################################*/

int VSP_SOLVER::InsideBody(double xyz[3], double distance)
{
   
    int Level, StackSize, Loop, i, Next, cpu, Intersections;
    int Node1, Node2, Node3;
    double p1[3], p2[3], p3[3], p4[3], p5[3], tt[3], uu[3], ww[3];
    BBOX RayBox;
    
    // Cast a ray...
    
    p4[0] = xyz[0] + 0.001;
    p4[1] = xyz[1] + 0.001;      
    p4[2] = xyz[2] + 0.001;            
    
    p5[0] = p4[0] + distance*1.0; 
    p5[1] = p4[1] + distance*1.0;
    p5[2] = p4[2] + distance*1.0;

    RayBox.x_min = MIN(p4[0],p5[0]);
    RayBox.x_max = MAX(p4[0],p5[0]);
             
    RayBox.y_min = MIN(p4[1],p5[1]);
    RayBox.y_max = MAX(p4[1],p5[1]);
    
    RayBox.z_min = MIN(p4[2],p5[2]);
    RayBox.z_max = MAX(p4[2],p5[2]);
                  
    // Grab the current cpu thread id

#ifdef VSPAERO_OPENMP  
    cpu = omp_get_thread_num();
#else
    cpu = 0;
#endif  
    
    // Insert loops into stack
    
    Level = VSPGeom().NumberOfGridLevels();
 
    StackSize = 0;

    for ( Loop = 1 ; Loop <= VSPGeom().Grid(Level).NumberOfLoops() ; Loop++ ) {
     
       StackSize++;
       
       LoopStackList_[cpu][StackSize].Level = Level;
       LoopStackList_[cpu][StackSize].Loop  = Loop;

    }

    // Update the search ID value... reset things after we have done all the loops
    
    SearchID_[cpu]++;
    
    if ( SearchID_[cpu] > VSPGeom().Grid(MGLevel_).NumberOfLoops() ) {
    
       for ( Level = 1 ; Level <= VSPGeom().NumberOfGridLevels() ; Level++ ) {
      
          zero_int_array(EdgeIsUsed_[cpu][Level], VSPGeom().Grid(Level).NumberOfEdges()); 
          
          zero_int_array(LoopIsUsed_[cpu][Level], VSPGeom().Grid(Level).NumberOfLoops()); 
          
       }
       
       SearchID_[cpu] = 1;

    }
    
    // Now loop over stack and look for intersections with the ray
       
    Intersections = 0;

    Next = 1;
        
    while ( Next <= StackSize ) {
     
       Level = LoopStackList_[cpu][Next].Level;
       Loop  = LoopStackList_[cpu][Next].Loop;
       
       if ( Level == 0 || compare_boxes(VSPGeom().Grid(Level).LoopList(Loop).BoundBox(), RayBox) ) {
    
          // Final level, check this tri
          
          if ( Level == 0 ) {
             
             // Check for intersection
             
             Node1 = VSPGeom().Grid(Level).LoopList(Loop).Node1();
             Node2 = VSPGeom().Grid(Level).LoopList(Loop).Node2();
             Node3 = VSPGeom().Grid(Level).LoopList(Loop).Node3();
             
             p1[0] = VSPGeom().Grid(Level).NodeList(Node1).x();
             p1[1] = VSPGeom().Grid(Level).NodeList(Node1).y();
             p1[2] = VSPGeom().Grid(Level).NodeList(Node1).z();
             
             p2[0] = VSPGeom().Grid(Level).NodeList(Node2).x();
             p2[1] = VSPGeom().Grid(Level).NodeList(Node2).y();
             p2[2] = VSPGeom().Grid(Level).NodeList(Node2).z();
             
             p3[0] = VSPGeom().Grid(Level).NodeList(Node3).x();
             p3[1] = VSPGeom().Grid(Level).NodeList(Node3).y();
             p3[2] = VSPGeom().Grid(Level).NodeList(Node3).z();
                    
             if ( tri_seg_int(p1, p2, p3, p4, p5, tt, uu, ww) > 0 ) {
                
                Intersections++;

             }

          }
          
          else {
         
             for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; i++ ) {

                StackSize++;
    
                LoopStackList_[cpu][StackSize].Level = Level - 1;
                
                LoopStackList_[cpu][StackSize].Loop  = VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(i);

             } 
             
          }
                    
       }
       
       Next++;
       
    }
    
    Intersections = 0;
    
    Intersections = Intersections % 2;
    
    return Intersections;
          
}
                
/*##############################################################################
#                                                                              #
#                VSP_SOLVER CalculateQuadTreeVelocitySurvey                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateQuadTreeVelocitySurvey(int Case)
{

    int i, j, k, v, cpu, NearBody;
    double xyz[3], q[5];
    char FileNameWithExt[MAX_CHAR_SIZE];
    FILE *QuadFile;
    
    // Initialize to free stream values

    for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {

       for ( i = 1 ; i <= QuadTreeList_[j].NumberOfNodes() ; i++ ) {
       
          QuadTreeList_[j].velocity(i)[0] = FreeStreamVelocity_[0];
          QuadTreeList_[j].velocity(i)[1] = FreeStreamVelocity_[1];
          QuadTreeList_[j].velocity(i)[2] = FreeStreamVelocity_[2];

       }
       
    }
    
    // Add in the rotor induced velocities
    
    for ( k = 1 ; k <= NumberOfRotors_ ; k++ ) {

       for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {
   
          for ( i = 1 ; i <= QuadTreeList_[j].NumberOfNodes() ; i++ ) {
             
             if ( !QuadTreeList_[j].NodeInsideBody(i) ) {
          
                xyz[0] = QuadTreeList_[j].x(i);
                xyz[1] = QuadTreeList_[j].y(i);
                xyz[2] = QuadTreeList_[j].z(i);
         
                RotorDisk(k).Velocity(xyz, q);                   
         
                QuadTreeList_[j].velocity(i)[0] += q[0];
                QuadTreeList_[j].velocity(i)[1] += q[1];
                QuadTreeList_[j].velocity(i)[2] += q[2];
                
                // If ground effects... add in ground effects ... z plane
                
                if ( DoGroundEffectsAnalysis() ) {
         
                   xyz[0] = QuadTreeList_[j].x(i);
                   xyz[1] = QuadTreeList_[j].y(i);
                   xyz[2] = QuadTreeList_[j].z(i);
         
                   xyz[2] *= -1.;
                  
                   RotorDisk(k).Velocity(xyz, q);        
         
                   q[2] *= -1.;
                  
                   QuadTreeList_[j].velocity(i)[0] += q[0];
                   QuadTreeList_[j].velocity(i)[1] += q[1];
                   QuadTreeList_[j].velocity(i)[2] += q[2];
         
                }             
                
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
         
                   xyz[0] = QuadTreeList_[j].x(i);
                   xyz[1] = QuadTreeList_[j].y(i);
                   xyz[2] = QuadTreeList_[j].z(i);
                   
                   if ( DoSymmetryPlaneSolve_ ) xyz[1] *= -1.;
                   
                   RotorDisk(k).Velocity(xyz, q);        
         
                   if ( DoSymmetryPlaneSolve_ ) q[1] *= -1.;
                  
                   QuadTreeList_[j].velocity(i)[0] += q[0];
                   QuadTreeList_[j].velocity(i)[1] += q[1];
                   QuadTreeList_[j].velocity(i)[2] += q[2];
                   
                   // If ground effects... add in ground effects ... z plane
                   
                   if ( DoGroundEffectsAnalysis() ) {
      
                      xyz[2] *= -1.;
                     
                      RotorDisk(k).Velocity(xyz, q);        
            
                      q[1] *= -1.;
                      q[2] *= -1.;
                        
                      QuadTreeList_[j].velocity(i)[0] += q[0];
                      QuadTreeList_[j].velocity(i)[1] += q[1];
                      QuadTreeList_[j].velocity(i)[2] += q[2];
         
                   }
                     
                }            
               
             }    
             
          }
   
       }
       
    }

    // Add in any engine flow fields
    
    for ( k = 1 ; k <= NumberOfEngineFaces_ ; k++ ) {
     
       for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {
   
          for ( i = 1 ; i <= QuadTreeList_[j].NumberOfNodes() ; i++ ) {
             
             if ( !QuadTreeList_[j].NodeInsideBody(i) ) {
          
                xyz[0] = QuadTreeList_[j].x(i);
                xyz[1] = QuadTreeList_[j].y(i);
                xyz[2] = QuadTreeList_[j].z(i);
	  
		          EngineFace(k).Velocity(xyz, q);   
      
                QuadTreeList_[j].velocity(i)[0] += q[0];
                QuadTreeList_[j].velocity(i)[1] += q[1];
                QuadTreeList_[j].velocity(i)[2] += q[2];
			       
                // If there is a ground effects, z - plane
                
                if ( DoGroundEffectsAnalysis() ) {
               
                   xyz[0] = QuadTreeList_[j].x(i);
                   xyz[1] = QuadTreeList_[j].y(i);
                   xyz[2] = QuadTreeList_[j].z(i);
                   
                   xyz[2] *= -1.;
                  
                   EngineFace(k).Velocity(xyz, q);      
               
                   q[2] *= -1.;
                   
                   QuadTreeList_[j].velocity(i)[0] += q[0];
                   QuadTreeList_[j].velocity(i)[1] += q[1];
                   QuadTreeList_[j].velocity(i)[2] += q[2];  
                     
                }
			  
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
                   
                   xyz[0] = QuadTreeList_[j].x(i);
                   xyz[1] = QuadTreeList_[j].y(i);
                   xyz[2] = QuadTreeList_[j].z(i);
                   
                   if ( DoSymmetryPlaneSolve_ ) xyz[1] *= -1.;
                   
                   EngineFace(k).Velocity(xyz, q);          
                   
                   if ( DoSymmetryPlaneSolve_ ) q[1] *= -1.;
                      
                   QuadTreeList_[j].velocity(i)[0] += q[0];
                   QuadTreeList_[j].velocity(i)[1] += q[1];
                   QuadTreeList_[j].velocity(i)[2] += q[2];          
                   
                   // If there is a ground effects, z - plane
                   
                   if ( DoGroundEffectsAnalysis() ) {
                   
                      xyz[2] *= -1.;
                      
                      EngineFace(j).Velocity(xyz, q);      
                   
                      q[1] *= -1.;
                      q[2] *= -1.;
                   
                      QuadTreeList_[j].velocity(i)[0] += q[0];
                      QuadTreeList_[j].velocity(i)[1] += q[1];
                      QuadTreeList_[j].velocity(i)[2] += q[2];                       
                   
                   }    
                   
                }
		
             }   
	     
          }
	  
       }
       
    }
        
    // Surface vortex induced velocities

    for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {

       for ( i = 1 ; i <= QuadTreeList_[j].NumberOfNodes() ; i++ ) {
            
          if ( !QuadTreeList_[j].NodeInsideBody(i) ) {
            
             xyz[0] = QuadTreeList_[j].x(i);
             xyz[1] = QuadTreeList_[j].y(i);
             xyz[2] = QuadTreeList_[j].z(i);
          
             NearBody = CalculateSurfaceInducedVelocityAtOffBodyPoint(xyz, q);
      
             if ( !NearBody ) {
                
                QuadTreeList_[j].velocity(i)[0] += q[0];
                QuadTreeList_[j].velocity(i)[1] += q[1];
                QuadTreeList_[j].velocity(i)[2] += q[2];
                
             }
             
             else {
                
                QuadTreeList_[j].velocity(i)[0] = q[0];
                QuadTreeList_[j].velocity(i)[1] = q[1];
                QuadTreeList_[j].velocity(i)[2] = q[2];
                
             }                
      
             if ( !NearBody ) {
                
                // If ground effects... add in ground effects ... z plane
                
                if ( DoGroundEffectsAnalysis() ) {
         
                  xyz[0] = QuadTreeList_[j].x(i);
                  xyz[1] = QuadTreeList_[j].y(i);
                  xyz[2] = QuadTreeList_[j].z(i);
                
                  xyz[2] *= -1.;
                  
                  NearBody = CalculateSurfaceInducedVelocityAtOffBodyPoint(xyz, q);
         
                  q[2] *= -1.;
                  
                  QuadTreeList_[j].velocity(i)[0] += q[0];
                  QuadTreeList_[j].velocity(i)[1] += q[1];
                  QuadTreeList_[j].velocity(i)[2] += q[2];
                  
                }
                       
                // If there is a symmetry plane, calculate influence of the reflection
                
                if ( DoSymmetryPlaneSolve_ ) {
         
                   xyz[0] = QuadTreeList_[j].x(i);
                   xyz[1] = QuadTreeList_[j].y(i);
                   xyz[2] = QuadTreeList_[j].z(i);
                  
                   if ( DoSymmetryPlaneSolve_ ) xyz[1] *= -1.;
                  
                   NearBody = CalculateSurfaceInducedVelocityAtOffBodyPoint(xyz, q);
         
                   if ( DoSymmetryPlaneSolve_ ) q[1] *= -1.;
                  
                   QuadTreeList_[j].velocity(i)[0] += q[0];
                   QuadTreeList_[j].velocity(i)[1] += q[1];
                   QuadTreeList_[j].velocity(i)[2] += q[2];
         
                   // If ground effects... add in ground effects ... z plane
                   
                   if ( DoGroundEffectsAnalysis() ) {
         
                     xyz[2] *= -1.;
                     
                     NearBody = CalculateSurfaceInducedVelocityAtOffBodyPoint(xyz, q);
            
                     q[1] *= -1.;
                     q[2] *= -1.;
                     
                     QuadTreeList_[j].velocity(i)[0] += q[0];
                     QuadTreeList_[j].velocity(i)[1] += q[1];
                     QuadTreeList_[j].velocity(i)[2] += q[2];
                     
                   }
                         
                }
                
             }
             
          }
          
       }
       
    }
    
    // Calculate pressures

    double gamma, gm1, gm2, gm3, q2, qmax, rho, pinf;

    // Compressible relations..
    
    gamma = 1.4;
    
    gm1 = gamma - 1.;
    
    gm2 = 0.5*gm1*Mach_*Mach_;
    
    gm3 = 1./gm1;

    qmax = 0.98*sqrt( 1./gm2 + 1. );
    
    for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {

       for ( i = 1 ; i <= QuadTreeList_[j].NumberOfNodes() ; i++ ) {

          q[0] = QuadTreeList_[j].velocity(i)[0]/Vref_;
          q[1] = QuadTreeList_[j].velocity(i)[1]/Vref_;
          q[2] = QuadTreeList_[j].velocity(i)[2]/Vref_;
          
          if ( Mach_ < 1. ) {
             
             QuadTreeList_[j].Cp(i) = 1. - q[0]*q[0] - q[1]*q[1] - q[2]*q[2];
             
          }
          
          else {
             
             q2 = q[0]*q[0] - q[1]*q[1] - q[2]*q[2];
             
             q2 = MIN(q2,qmax);
             
             rho = pow(1. - gm2*(q2 - 1.), gm3);
             
             pinf = 1./(gamma*Mach_*Mach_);
             
             QuadTreeList_[j].Cp(i) = 2.*( pow(rho, gamma) - 1.)*pinf;

          }
          
       }
       
    }
             
    // Write out the data

    for ( j = 1 ; j <= NumberOfQuadTrees_ ; j++ ) {

       snprintf(FileNameWithExt,sizeof(FileNameWithExt)*sizeof(char),"%s.case.%d.quad.%d.dat",FileName_,Case,j);
       
       if ( (QuadFile = fopen(FileNameWithExt, "w")) == NULL ) {
     
          printf("Could not open the quad tree file: %s for output! \n",FileNameWithExt);
     
          exit(1);
     
       }  
       
       fprintf(QuadFile,"%d %lf %lf %lf\n",QuadTreeDirection_[j],QuadTreeValue_[j],Vref_, Vmax_);
       
       QuadTreeList_[j].WriteQuadTreeToFile(QuadFile);     
       
       fclose(QuadFile);    
       
    }
 
}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER CalculateVelocitySurvey                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateVelocitySurvey(int Case)
{

    int i, k, p;
    double xyz[3], q[5];
    double *U, *V, *W;
    
    U = new double[NumberofSurveyPoints_ + 1];
    V = new double[NumberofSurveyPoints_ + 1];
    W = new double[NumberofSurveyPoints_ + 1];

    zero_double_array(U, NumberofSurveyPoints_);
    zero_double_array(V, NumberofSurveyPoints_);
    zero_double_array(W, NumberofSurveyPoints_);

    // Initialize to free stream values

#pragma omp parallel for  
    for ( i = 1 ; i <= NumberofSurveyPoints_ ; i++ ) {

       U[i] = FreeStreamVelocity_[0];
       V[i] = FreeStreamVelocity_[1];
       W[i] = FreeStreamVelocity_[2];

    }
    
    // Add in the rotor induced velocities
 
    for ( k = 1 ; k <= NumberOfRotors_ ; k++ ) {
    
//////#pragma omp parallel for private(xyz,q)           
       for ( i = 1 ; i <= NumberofSurveyPoints_ ; i++ ) {
    
          xyz[0] = SurveyPointList(i).x();
          xyz[1] = SurveyPointList(i).y();
          xyz[2] = SurveyPointList(i).z();
   
          RotorDisk(k).Velocity(xyz, q);                   
   
          U[i] += q[0];
          V[i] += q[1];
          W[i] += q[2];
          
          // If ground effects... add in ground effects ... z plane
          
          if ( DoGroundEffectsAnalysis() ) {
   
             xyz[0] = SurveyPointList(i).x();
             xyz[1] = SurveyPointList(i).y();
             xyz[2] = SurveyPointList(i).z();
                
             xyz[2] *= -1.;
            
             RotorDisk(k).Velocity(xyz, q);        
   
             q[2] *= -1.;
            
             U[i] += q[0];
             V[i] += q[1];
             W[i] += q[2];
   
          }             
          
          // If there is a symmetry plane, calculate influence of the reflection
          
          if ( DoSymmetryPlaneSolve_ ) {
   
             xyz[0] = SurveyPointList(i).x();
             xyz[1] = SurveyPointList(i).y();
             xyz[2] = SurveyPointList(i).z();
             
             if ( DoSymmetryPlaneSolve_ ) xyz[1] *= -1.;
             
             RotorDisk(k).Velocity(xyz, q);        
   
             if ( DoSymmetryPlaneSolve_ ) q[1] *= -1.;
            
             U[i] += q[0];
             V[i] += q[1];
             W[i] += q[2];
             
             // If ground effects... add in ground effects ... z plane
             
             if ( DoGroundEffectsAnalysis() ) {

                xyz[2] *= -1.;
               
                RotorDisk(k).Velocity(xyz, q);        
      
                q[1] *= -1.;
                q[2] *= -1.;
               
                U[i] += q[0];
                V[i] += q[1];
                W[i] += q[2];
   
             }
               
          }            
         
       }    
       
    }

    // Surface vortex induced velocities

    for ( i = 1 ; i <= NumberofSurveyPoints_ ; i++ ) {
  
       xyz[0] = SurveyPointList(i).x();
       xyz[1] = SurveyPointList(i).y();
       xyz[2] = SurveyPointList(i).z();
    
       CalculateSurfaceInducedVelocityAtPoint(xyz, q);

       U[i] += q[0];
       V[i] += q[1];
       W[i] += q[2];

       // If ground effects... add in ground effects ... z plane
       
       if ( DoGroundEffectsAnalysis() ) {

         xyz[0] = SurveyPointList(i).x();
         xyz[1] = SurveyPointList(i).y();
         xyz[2] = SurveyPointList(i).z();
       
         xyz[2] *= -1.;
         
         CalculateSurfaceInducedVelocityAtPoint(xyz, q);

         q[2] *= -1.;
         
         U[i] += q[0];
         V[i] += q[1];
         W[i] += q[2];
         
       }
              
       // If there is a symmetry plane, calculate influence of the reflection
       
       if ( DoSymmetryPlaneSolve_ ) {

          xyz[0] = SurveyPointList(i).x();
          xyz[1] = SurveyPointList(i).y();
          xyz[2] = SurveyPointList(i).z();
         
          if ( DoSymmetryPlaneSolve_ ) xyz[1] *= -1.;
         
          CalculateSurfaceInducedVelocityAtPoint(xyz, q);

          if ( DoSymmetryPlaneSolve_ ) q[1] *= -1.;
         
          U[i] += q[0];
          V[i] += q[1];
          W[i] += q[2];

          // If ground effects... add in ground effects ... z plane
          
          if ( DoGroundEffectsAnalysis() ) {

            xyz[2] *= -1.;
            
            CalculateSurfaceInducedVelocityAtPoint(xyz, q);
   
            q[1] *= -1.;
            q[2] *= -1.;
            
            U[i] += q[0];
            V[i] += q[1];
            W[i] += q[2];
            
          }
                
       }
       
    }

    // Write out the velocity survey
    
    if ( !TimeAccurate_ ) fprintf(SurveyFile_,"Case: %d \n",ABS(Case));  
    if (  TimeAccurate_ ) fprintf(SurveyFile_,"Time: %f \n",CurrentTime_);  
 
    for ( i = 1 ; i <= NumberofSurveyPoints_ ; i++ ) {

       xyz[0] = SurveyPointList(i).x();
       xyz[1] = SurveyPointList(i).y();
       xyz[2] = SurveyPointList(i).z();
       
       fprintf(SurveyFile_, "%10.5f %10.5f%10.5f    %10.5f %10.5f %10.5f \n",
               SurveyPointList(i).x(),
               SurveyPointList(i).y(),
               SurveyPointList(i).z(),
               U[i],
               V[i],
               W[i]);
     
    }
    
    fprintf(SurveyFile_,"\n\n\n");     

    delete [] U;
    delete [] V;
    delete [] W;
 
}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER WriteOutAerothermalDatabaseHeader                #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteOutAerothermalDatabaseHeader(void)
{
   
    char DumChar[MAX_CHAR_SIZE];
    int i, number_of_nodes, number_of_tris, number_of_loops, number_of_edges;
    int i_size, c_size, f_size, DumInt, ComponentID, ModelType;
    
    float Sref = float( Sref_ );
    float Cref = float( Cref_ );
    float Bref = float( Bref_ );
    float X_cg = float( XYZcg_[0] );
    float Y_cg = float( XYZcg_[1] );
    float Z_cg = float( XYZcg_[2] );

    // Sizeof int and float

    i_size = sizeof(int);
    c_size = sizeof(char);
    f_size = sizeof(float);

    // Write out coded id to allow us to determine endiannes of files

    DumInt = -123789456 + 3; // Version 3 of the ADB file

    fwrite(&DumInt, i_size, 1, ADBFile_);
    
    // Write out model type... VLM or PANEL
    
    ModelType =VSPGeom().ModelType();
    
    fwrite(&ModelType, i_size, 1, ADBFile_);

    // Write out symmetry flag
    
    fwrite(&DoSymmetryPlaneSolve_, i_size, 1, ADBFile_);

    // Write out unsteady analysis flag
    
    if ( TimeAccurate_) {
    
       DumInt = 1;
    
       fwrite(&DumInt, i_size, 1, ADBFile_);    
       
    }
    
    else {
       
       DumInt = 0;
       
       fwrite(&DumInt, i_size, 1, ADBFile_);    
       
    }       
    
    // Write out header to aerodynamics file

    number_of_loops = VSPGeom().Grid(MGLevel_).NumberOfLoops();
    number_of_tris  = VSPGeom().Grid(0).NumberOfLoops();
    number_of_nodes = VSPGeom().Grid(0).NumberOfNodes();
    number_of_edges = VSPGeom().Grid(MGLevel_).NumberOfEdges();
    
    fwrite(&number_of_loops, i_size, 1, ADBFile_);
    fwrite(&number_of_nodes, i_size, 1, ADBFile_);
    fwrite(&number_of_tris,  i_size, 1, ADBFile_);
    fwrite(&number_of_edges, i_size, 1, ADBFile_);

    fwrite(&Sref,                   f_size, 1, ADBFile_);
    fwrite(&Cref,                   f_size, 1, ADBFile_);
    fwrite(&Bref,                   f_size, 1, ADBFile_);
    fwrite(&X_cg,                   f_size, 1, ADBFile_);
    fwrite(&Y_cg,                   f_size, 1, ADBFile_);
    fwrite(&Z_cg,                   f_size, 1, ADBFile_);
 
    // Write out SurfaceID flags, names...
    
    DumInt = VSPGeom().NumberOfSurfaces();
   
    fwrite(&DumInt, i_size, 1, ADBFile_);
    
    for ( i = 1 ; i <= VSPGeom().NumberOfSurfaces() ; i++ ) { 
    
       fwrite(&(i), i_size, 1, ADBFile_);
    
       snprintf(DumChar,sizeof(DumChar)*sizeof(char),"%s",VSPGeom().SurfaceNameList(i));
       
       fwrite(DumChar, c_size, 100, ADBFile_);
       
       DumInt = VSPGeom().ComponentIDForSurface(i);
     
       fwrite(&DumInt, i_size, 1, ADBFile_);
       
       printf("Surface: %d ... ComponentID: %d ... Name: %s ... SurfaceGIDList: %s \n",
       i,
       DumInt,
       VSPGeom().SurfaceNameList(i),
       VSPGeom().SurfaceGIDList(i));fflush(NULL);
    
    }    

}   

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER ReadInAerothermalDatabaseHeader                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ReadInAerothermalDatabaseHeader(void)
{
   
    int i, Wings, Bodies, Surfs;
    int i_size, c_size, f_size;
    
    int DumInt;
    float DumFloat;
    char DumChar[MAX_CHAR_SIZE];

    // Sizeof int and float

    i_size = sizeof(int);
    c_size = sizeof(char);
    f_size = sizeof(float);

    // Read in endiannes of files

    fread(&DumInt, i_size, 1, InputADBFile_);
    
    // Read in model type... VLM or PANEL
    
    fread(&DumInt, i_size, 1, InputADBFile_);

    // Read in symmetry flag
    
    fread(&DumInt, i_size, 1, InputADBFile_);

    // Read in unsteady analysis flag
    
    fread(&TimeAccurate_, i_size, 1, InputADBFile_);    

    // Read in header to aerodynamics file

    fread(&DumInt,   i_size, 1, InputADBFile_);
    fread(&DumInt,   i_size, 1, InputADBFile_);
    fread(&DumInt,   i_size, 1, InputADBFile_);
    fread(&DumInt,   i_size, 1, InputADBFile_);    
    fread(&DumFloat, f_size, 1, InputADBFile_);
    fread(&DumFloat, f_size, 1, InputADBFile_);
    fread(&DumFloat, f_size, 1, InputADBFile_);
    fread(&DumFloat, f_size, 1, InputADBFile_);
    fread(&DumFloat, f_size, 1, InputADBFile_);
    fread(&DumFloat, f_size, 1, InputADBFile_);

    // Read in Cart3d ID flags, names...

    fread(&Surfs, i_size, 1, InputADBFile_);

    for ( i = 1 ; i <=Surfs ; i++ ) { 
     
       fread(&DumInt, i_size, 1,   InputADBFile_);

       fread(DumChar, c_size, 100, InputADBFile_);

       fread(&DumInt, i_size, 1,   InputADBFile_);

    }    
    
}   
 
/*##############################################################################
#                                                                              #
#                VSP_SOLVER WriteOutAerothermalDatabaseGeometry                #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteOutAerothermalDatabaseGeometry(void)
{

    int i, j, k, p, r, Node1, Node2, Node3, SurfaceType, ComponentID, SurfaceID;
    int i_size, c_size, f_size, MinValidTimeStep;
    int Level, NumberOfCoarseEdges, NumberOfCoarseNodes, MaxLevels;
    int NumberOfKuttaTE, NumberOfKuttaNodes, NumberOfControlLoops;
    int NumberOfControlSurfaces, Loop, NumberOfNozzles;
    float Area;
    float x, y, z;

    // Sizeof int and float

    i_size = sizeof(int);
    c_size = sizeof(char);
    f_size = sizeof(float);

    // Write out triangulated surface mesh

    for ( j = 1 ; j <= VSPGeom().Grid().NumberOfLoops() ; j++ ) {

       Node1       = VSPGeom().Grid().LoopList(j).Node1();
       Node2       = VSPGeom().Grid().LoopList(j).Node2();
       Node3       = VSPGeom().Grid().LoopList(j).Node3();

       SurfaceType = VSPGeom().Grid().LoopList(j).SurfaceType();
              
       SurfaceID   = VSPGeom().Grid().LoopList(j).SurfaceID();
       
       ComponentID = VSPGeom().Grid().LoopList(j).ComponentID();
       
       MinValidTimeStep = VSPGeom().Grid().LoopList(j).MinValidTimeStep();

       Area        = float( VSPGeom().Grid().LoopList(j).Area() );
 
       fwrite(&(Node1),            i_size, 1, ADBFile_);
       fwrite(&(Node2),            i_size, 1, ADBFile_);
       fwrite(&(Node3),            i_size, 1, ADBFile_);
       fwrite(&(ComponentID),      i_size, 1, ADBFile_);
       fwrite(&(SurfaceID),        i_size, 1, ADBFile_);
       fwrite(&(MinValidTimeStep), i_size, 1, ADBFile_);
       
       fwrite(&Area, f_size, 1, ADBFile_);

    }

    // Write out node data

    for ( j = 1 ; j <= VSPGeom().Grid().NumberOfNodes() ; j++ ) {

       x = float( VSPGeom().Grid().NodeList(j).x() );
       y = float( VSPGeom().Grid().NodeList(j).y() );
       z = float( VSPGeom().Grid().NodeList(j).z() );
       
       fwrite(&(x), f_size, 1, ADBFile_);
       fwrite(&(y), f_size, 1, ADBFile_);
       fwrite(&(z), f_size, 1, ADBFile_);
       
    }

    // Number of rotors and nozzles...
                
    fwrite(&NumberOfRotors_, i_size, 1, ADBFile_);

    NumberOfNozzles = 0;
    
    for ( i = 1 ; i <= NumberOfEngineFaces_ ; i++ ) {
       
       if ( EngineFace(i).SurfaceType() == NOZZLE_FACE ) NumberOfNozzles++;
       
    }
   
    fwrite(&NumberOfNozzles, i_size, 1, ADBFile_);
 
    // Write out the rotor data
 
    for ( i = 1 ; i <= NumberOfRotors_ ; i++ ) {
     
       RotorDisk(i).Write_Binary_STP_Data(ADBFile_);
     
    }    

    // Write out the engine nozzle data
      
    for ( i = 1 ; i <= NumberOfEngineFaces_ ; i++ ) {
       
       if ( EngineFace(i).SurfaceType() == NOZZLE_FACE ) EngineFace(i).Write_Binary_STP_Data(ADBFile_);
       
    }        
    
    // Write out the edges for each grid level
        
    MaxLevels = VSPGeom().NumberOfGridLevels();

    fwrite(&MaxLevels, i_size, 1, ADBFile_); 
   
    // Loop over each level

    for ( Level = 1 ; Level <= MaxLevels ; Level++ ) {

       NumberOfCoarseNodes = VSPGeom().Grid(Level).NumberOfNodes();

       NumberOfCoarseEdges = VSPGeom().Grid(Level).NumberOfEdges();
 
       fwrite(&NumberOfCoarseNodes, i_size, 1, ADBFile_); 

       fwrite(&NumberOfCoarseEdges, i_size, 1, ADBFile_); 

       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfNodes() ; j++ ) {

          x = float( VSPGeom().Grid(Level).NodeList(j).x() );
          y = float( VSPGeom().Grid(Level).NodeList(j).y() );
          z = float( VSPGeom().Grid(Level).NodeList(j).z() );
          
          fwrite(&(x), f_size, 1, ADBFile_);
          fwrite(&(y), f_size, 1, ADBFile_);
          fwrite(&(z), f_size, 1, ADBFile_);         
     
       }
       
       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfEdges() ; j++ ) {
        
          SurfaceID = VSPGeom().Grid(Level).EdgeList(j).SurfaceID();
   
          MinValidTimeStep = VSPGeom().Grid(Level).EdgeList(j).MinValidTimeStep();
               
          if ( VSPGeom().Grid(Level).EdgeList(j).Loop1() == VSPGeom().Grid(Level).EdgeList(j).Loop2() ) SurfaceID *= -1;         

          Node1 = VSPGeom().Grid(Level).EdgeList(j).Node1();
          Node2 = VSPGeom().Grid(Level).EdgeList(j).Node2();  

          fwrite(&SurfaceID,        i_size, 1, ADBFile_);
          fwrite(&MinValidTimeStep, i_size, 1, ADBFile_);
          
          fwrite(&Node1, i_size, 1, ADBFile_);
          fwrite(&Node2, i_size, 1, ADBFile_);

       }
  
    }
    
    // Write out kutta edges
    
    Level = 1;
    
    NumberOfKuttaTE = 0;
    
    for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {
 
       if ( VSPGeom().Grid(Level).EdgeList(i).IsTrailingEdge() ) {     
          
          NumberOfKuttaTE++;
          
       }
       
    }
    
    fwrite(&NumberOfKuttaTE, i_size, 1, ADBFile_);
    
    for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {
 
       if ( VSPGeom().Grid(Level).EdgeList(i).IsTrailingEdge() ) {     

          fwrite(&i, i_size, 1, ADBFile_); 
          
       }
       
    }
    
    // Write out kutta nodes
    
    NumberOfKuttaNodes = 0;
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
            
       NumberOfKuttaNodes += VSPGeom().VortexSheet(k).NumberOfTrailingVortices();
       
    }

    fwrite(&NumberOfKuttaNodes, i_size, 1, ADBFile_);
 
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
            
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {

          Node1 = VSPGeom().VortexSheet(k).TrailingVortex(i).TE_Node();
  
          fwrite(&Node1, i_size, 1, ADBFile_); 

       }
    
    }
    
    // Write out control surfaces
    
    NumberOfControlSurfaces = VSPGeom().NumberOfControlSurfaces();
 
    fwrite(&NumberOfControlSurfaces, i_size, 1, ADBFile_); 

    for ( k = 1 ; k <= VSPGeom().NumberOfControlSurfaces() ; k++ ) {
       
       p = 0;
       
       fwrite(&p, i_size, 1, ADBFile_);

       // Hinge data
       
       x = float( VSPGeom().ControlSurface(k).HingeNode_1(0) );
       y = float( VSPGeom().ControlSurface(k).HingeNode_1(1) );
       z = float( VSPGeom().ControlSurface(k).HingeNode_1(2) );   

       fwrite(&x, f_size, 1, ADBFile_); 
       fwrite(&y, f_size, 1, ADBFile_); 
       fwrite(&z, f_size, 1, ADBFile_);     
       
       x = float( VSPGeom().ControlSurface(k).HingeNode_2(0) );
       y = float( VSPGeom().ControlSurface(k).HingeNode_2(1) );
       z = float( VSPGeom().ControlSurface(k).HingeNode_2(2) );   
       
       fwrite(&x, f_size, 1, ADBFile_); 
       fwrite(&y, f_size, 1, ADBFile_); 
       fwrite(&z, f_size, 1, ADBFile_);       
       
       x = float( VSPGeom().ControlSurface(k).HingeVec(0) );
       y = float( VSPGeom().ControlSurface(k).HingeVec(1) );
       z = float( VSPGeom().ControlSurface(k).HingeVec(2) );   
       
       fwrite(&x, f_size, 1, ADBFile_); 
       fwrite(&y, f_size, 1, ADBFile_); 
       fwrite(&z, f_size, 1, ADBFile_);                   
       
       // Affected loops

       NumberOfControlLoops = VSPGeom().ControlSurface(k).NumberOfLoops();

       fwrite(&NumberOfControlLoops, i_size, 1, ADBFile_);
       
       for ( p = 1 ; p <= VSPGeom().ControlSurface(k).NumberOfLoops() ; p++ ) {
          
          Loop = VSPGeom().ControlSurface(k).LoopList(p);
    
          fwrite(&Loop, i_size, 1, ADBFile_);
             
       }
                                               
    }

}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER ReadInAerothermalDatabaseGeometry                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ReadInAerothermalDatabaseGeometry(void)
{

    int i, j, k, p, Level, MaxLevels, NumberOfKuttaTE, NumberOfKuttaNodes, NumberOfControlSurfaces, NumberOfRotors;
    int i_size, c_size, f_size, NumberOfNozzles;
    
    int DumInt;
    float DumFloat;

    // Sizeof int and float

    i_size = sizeof(int);
    c_size = sizeof(char);
    f_size = sizeof(float);

    // Read in triangulated surface mesh

    for ( j = 1 ; j <= VSPGeom().Grid().NumberOfLoops() ; j++ ) {

       fread(&DumInt,   i_size, 1, InputADBFile_);
       fread(&DumInt,   i_size, 1, InputADBFile_);
       fread(&DumInt,   i_size, 1, InputADBFile_);
       fread(&DumInt,   i_size, 1, InputADBFile_);
       fread(&DumInt,   i_size, 1, InputADBFile_);
       fread(&DumFloat, f_size, 1, InputADBFile_);

    }

    // Read in node data

    for ( j = 1 ; j <= VSPGeom().Grid().NumberOfNodes() ; j++ ) {

       fread(&DumFloat, f_size, 1, InputADBFile_);
       fread(&DumFloat, f_size, 1, InputADBFile_);
       fread(&DumFloat, f_size, 1, InputADBFile_);
       
    }

    // Number of rotors and nozzles...
    
    fread(&NumberOfRotors, i_size, 1, InputADBFile_);
 
    fread(&NumberOfNozzles, i_size, 1, InputADBFile_);

    // Read in the rotor data

    for ( i = 1 ; i <= NumberOfRotors ; i++ ) {
     
       RotorDisk(i).Skip_Read_Binary_STP_Data(InputADBFile_);
     
    }

    // Read in the engine nozzle data

    j = 0;
    
    for ( i = 1 ; i <= NumberOfNozzles ; i++ ) {
     
       if ( EngineFace(i).SurfaceType() == NOZZLE_FACE ) {
	  
	       EngineFace(i).Skip_Read_Binary_STP_Data(ADBFile_);
	       
	       j++;
	  
       }
       
    }
    
    if ( j != NumberOfNozzles ) {
       
       printf("Error... inconsistency in number of nozzles from .adb and .vspaero files! \n");
       fflush(NULL);exit(1);
       
    }
    
    // Read in the edges for each grid level

    fread(&MaxLevels, i_size, 1, InputADBFile_); 
  
    // Loop over each level

    for ( Level = 1 ; Level <= MaxLevels ; Level++ ) {

       fread(&DumInt, i_size, 1, InputADBFile_); 

       fread(&DumInt, i_size, 1, InputADBFile_); 

       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfNodes() ; j++ ) {

          fread(&DumFloat, f_size, 1, InputADBFile_);
          fread(&DumFloat, f_size, 1, InputADBFile_);
          fread(&DumFloat, f_size, 1, InputADBFile_);         
     
       }
       
       for ( j = 1 ; j <= VSPGeom().Grid(Level).NumberOfEdges() ; j++ ) {

          fread(&DumInt, i_size, 1, InputADBFile_);
          
          fread(&DumInt, i_size, 1, InputADBFile_);
          fread(&DumInt, i_size, 1, InputADBFile_);

       }
  
    }
    
    // Read in kutta edges

    fread(&NumberOfKuttaTE, i_size, 1, InputADBFile_);
    
    for ( i = 1 ; i <= NumberOfKuttaTE ; i++ ) {
 
       fread(&DumInt, i_size, 1, InputADBFile_); 

    }
    
    // Read in kutta nodes

    fread(&NumberOfKuttaNodes, i_size, 1, InputADBFile_);

    for ( k = 1 ; k <= NumberOfKuttaNodes ; k++ ) {

       fread(&DumInt, i_size, 1, InputADBFile_); 

    }
    
    // Read in control surfaces

    fread(&NumberOfControlSurfaces, i_size, 1, InputADBFile_); 
        
    for ( j = 1 ; j <= NumberOfControlSurfaces ; j++ ) {

       fread(&k, i_size, 1, InputADBFile_);

       // Hinge data
       
       fread(&DumFloat, f_size, 1, InputADBFile_); 
       fread(&DumFloat, f_size, 1, InputADBFile_); 
       fread(&DumFloat, f_size, 1, InputADBFile_);     
       
       fread(&DumFloat, f_size, 1, InputADBFile_); 
       fread(&DumFloat, f_size, 1, InputADBFile_); 
       fread(&DumFloat, f_size, 1, InputADBFile_);       
   
       fread(&DumFloat, f_size, 1, InputADBFile_); 
       fread(&DumFloat, f_size, 1, InputADBFile_); 
       fread(&DumFloat, f_size, 1, InputADBFile_);                   
       
       // Affected loops
   
       fread(&k, i_size, 1, InputADBFile_);
       
       for ( p = 1 ; p <= k ; p++ ) {
   
          fread(&DumInt, i_size, 1, InputADBFile_);
   
       }             
          
    }    

}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER WriteOutAerothermalDatabaseSolution                #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteOutAerothermalDatabaseSolution(void)
{

    int i, j, k, NumTrailVortices;
    int i_size, c_size, f_size, d_size;

    float DumFloat;
    
    float Cp, Cp_Unsteady, Gamma;

    // Write out case data to adb case file
        
    if ( Verbose_ ) { printf("Mach_: %f \n",Mach_);fflush(NULL); };
    if ( Verbose_ ) { printf("AngleOfAttack_/TORAD: %f \n",double(AngleOfAttack_/TORAD));fflush(NULL); };
    if ( Verbose_ ) { printf("CaseString: %s \n",CaseString_);fflush(NULL); };

    if ( Verbose_ ) { printf("Writing out case line to ADBCaseListFile_... \n");fflush(NULL); };
    
    fprintf(ADBCaseListFile_,"%10.7f %10.7f %10.7f    %-200s \n",
     Mach_, 
     double(AngleOfAttack_/TORAD),
     double(AngleOfBeta_/TORAD),
     CaseString_);
    
    // Sizeof int and float

    i_size = sizeof(int);
    c_size = sizeof(char);
    f_size = sizeof(float);
    d_size = sizeof(double);

    // Write out Mach, Alpha, Beta

    if ( Verbose_ ) { printf("Writing out adb header data... \n");fflush(NULL); };
    
    DumFloat = float( Mach_ );

    fwrite(&DumFloat, f_size, 1, ADBFile_);

    DumFloat = float( AngleOfAttack_ );

    fwrite(&DumFloat, f_size, 1, ADBFile_);

    DumFloat = float( AngleOfBeta_ );

    fwrite(&DumFloat, f_size, 1, ADBFile_);    

    // Write out min and min and max Cp
 
    if ( Verbose_ ) { printf("Writing out adb Cpmin/max data... \n");fflush(NULL); };
   
    DumFloat = float( CpMin_ );
    
    fwrite(&(DumFloat), f_size, 1, ADBFile_);
    
    DumFloat = float( CpMax_ );
    
    fwrite(&(DumFloat), f_size, 1, ADBFile_);
        
    // Write out the vortex strengths, and both the steady and unsteady Cp on the computational mesh

    if ( Verbose_ ) { printf("Writing out adb gamma and dCp_Unsteady data... \n");fflush(NULL); };

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       fwrite(&(Gamma_[0][i]                ), d_size, 1, ADBFile_);
       fwrite(&(VSPGeom().Grid(MGLevel_).LoopList(i).dCp_Unsteady()), d_size, 1, ADBFile_);
           
    }   
      
    if ( Verbose_ ) { printf("Writing out adb Fx,y,z data... \n");fflush(NULL); };
      
    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
       
       fwrite(&(VSPGeom().Grid(MGLevel_).EdgeList(j).Fx()), d_size, 1, ADBFile_);
       fwrite(&(VSPGeom().Grid(MGLevel_).EdgeList(j).Fy()), d_size, 1, ADBFile_);
       fwrite(&(VSPGeom().Grid(MGLevel_).EdgeList(j).Fz()), d_size, 1, ADBFile_);
         
    }

    // Write out surface velocities on the computational mesh
    
    if ( Verbose_ ) { printf("Writing out adb vortex loop U,V,W data... \n");fflush(NULL); };
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       fwrite(&(VSPGeom().Grid(MGLevel_).LoopList(i).U()), d_size, 1, ADBFile_);
       fwrite(&(VSPGeom().Grid(MGLevel_).LoopList(i).V()), d_size, 1, ADBFile_);
       fwrite(&(VSPGeom().Grid(MGLevel_).LoopList(i).W()), d_size, 1, ADBFile_);

    }    
           
    // Write out solution on the input tri mesh

    if ( Verbose_ ) { printf("Writing out adb grid loop Gamma, Cp, and Cp_Unsteady data... \n");fflush(NULL); };

    for ( j = 1 ; j <= VSPGeom().Grid().NumberOfLoops() ; j++ ) {
  
       Gamma       = float( VSPGeom().Grid().LoopList(j).Gamma() );
       Cp          = float( VSPGeom().Grid().LoopList(j).dCp() );
       Cp_Unsteady = float( VSPGeom().Grid().LoopList(j).dCp_Unsteady() ) ;
       
      //Cp = 0.;
      //
      //for ( k = 1 ; k <= VSPGeom().Grid().LoopList(j).NumberOfNodes() ; k++ ) {
      //
      //   Cp += float( VSPGeom().Grid().LoopList(j).U_Node(k) );
      //   
      //}
      //
      //Cp /= VSPGeom().Grid().LoopList(j).NumberOfNodes();

       fwrite(&Cp,          f_size, 1, ADBFile_); // Total Delta Cp, or CP
       fwrite(&Cp_Unsteady, f_size, 1, ADBFile_); // Unsteady component of Delta Cp, or Cp
       fwrite(&Gamma,       f_size, 1, ADBFile_); // Circulation strength
              
    }

    // Write out wake shape

    if ( Verbose_ ) { printf("Determining number of trailing vortices for adb file output... \n");fflush(NULL); };

    NumTrailVortices = 0;
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
      
       NumTrailVortices += VSPGeom().VortexSheet(k).NumberOfTrailingVortices();

    }    
      
    if ( Verbose_ ) { printf("There are %d trailing vortices for adb file output... \n",NumTrailVortices);fflush(NULL); };

    if ( Verbose_ ) { printf("Writing out adb number of trailing vortices header... \n");fflush(NULL); };
      
    fwrite(&NumTrailVortices, i_size, 1, ADBFile_);

    if ( Verbose_ ) { printf("Writing out adb number of trailing vortices data... \n");fflush(NULL); };

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
           
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {

          VSPGeom().VortexSheet(k).TrailingVortex(i).WriteToFile(ADBFile_);

       }
       
    }     

    // Write out control surface deflection angles

    if ( Verbose_ ) { printf("Writing out adb control surface data... \n");fflush(NULL); };

    for ( k = 1 ; k <= VSPGeom().NumberOfControlSurfaces() ; k++ ) {
    
       DumFloat = float( VSPGeom().ControlSurface(k).DeflectionAngle() );
    
       fwrite(&(DumFloat), f_size, 1, ADBFile_); 
    
    }

    if ( Verbose_ ) { printf("Done writing out adb file data... \n");fflush(NULL); };

}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER ReadInAerothermalDatabaseSolution                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ReadInAerothermalDatabaseSolution(int TimeCase)
{

    int i, j, k;
    int i_size, c_size, f_size, d_size;

    int DumInt;
    float DumFloat;
    float Cp, Cp_Unsteady, Gamma;

    // Sizeof int and float

    i_size = sizeof(int);
    c_size = sizeof(char);
    f_size = sizeof(float);
    d_size = sizeof(double);

    // Read in Mach, Alpha, Beta

    fread(&DumFloat, f_size, 1, InputADBFile_);

    fread(&DumFloat, f_size, 1, InputADBFile_);

    fread(&DumFloat, f_size, 1, InputADBFile_); 

    // Read in min and min and max Cp

    fread(&DumFloat, f_size, 1, InputADBFile_);

    fread(&DumFloat, f_size, 1, InputADBFile_);
       
    // Read the vortex strengths and unsteady Cp on the computational mesh

    // This will be N - TimeCase
    
    if ( TimeCase >= 0 && TimeCase <= 5 ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
   
          fread(&(      GammaNoise_[TimeCase][i]), d_size, 1, InputADBFile_);
          fread(&(dCpUnsteadyNoise_[TimeCase][i]), d_size, 1, InputADBFile_);

       }  

    }
 
    // This will be N, but shift current to N-1, and N-1 to N-2
    
    else if ( TimeCase == -1 ) {

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
   
                GammaNoise_[5][i] =       GammaNoise_[4][i];
                GammaNoise_[4][i] =       GammaNoise_[3][i];
                GammaNoise_[3][i] =       GammaNoise_[2][i];
                GammaNoise_[2][i] =       GammaNoise_[1][i];
                GammaNoise_[1][i] =       GammaNoise_[0][i];
                
          dCpUnsteadyNoise_[5][i] = dCpUnsteadyNoise_[4][i];                                
          dCpUnsteadyNoise_[4][i] = dCpUnsteadyNoise_[3][i];                
          dCpUnsteadyNoise_[3][i] = dCpUnsteadyNoise_[2][i];
          dCpUnsteadyNoise_[2][i] = dCpUnsteadyNoise_[1][i];
          dCpUnsteadyNoise_[1][i] = dCpUnsteadyNoise_[0][i];
     
       }  
              
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
   
          fread(&(      GammaNoise_[0][i]), d_size, 1, InputADBFile_);
          fread(&(dCpUnsteadyNoise_[0][i]), d_size, 1, InputADBFile_);
     
       }  
       
    }    
    
    else {
       
       printf("Unknown ADB read case: %d \n",TimeCase);
       fflush(NULL);
       exit(1);
       
    }
   
    // Read in the edge forces on the computational mesh

    // This will be N - TimeCase
    
    if ( TimeCase >= 0 && TimeCase <= 5 ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
          
          fread(&(FxNoise_[TimeCase][i]), d_size, 1, InputADBFile_);
          fread(&(FyNoise_[TimeCase][i]), d_size, 1, InputADBFile_);
          fread(&(FzNoise_[TimeCase][i]), d_size, 1, InputADBFile_);
            
       }
       
    }

    // This will be N, but shift current to N-1
    
    else if ( TimeCase == -1 ) {

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {

          FxNoise_[5][i] = FxNoise_[4][i];
          FyNoise_[5][i] = FyNoise_[4][i];
          FzNoise_[5][i] = FzNoise_[4][i];

          FxNoise_[4][i] = FxNoise_[3][i];
          FyNoise_[4][i] = FyNoise_[3][i];
          FzNoise_[4][i] = FzNoise_[3][i];

          FxNoise_[3][i] = FxNoise_[2][i];
          FyNoise_[3][i] = FyNoise_[2][i];
          FzNoise_[3][i] = FzNoise_[2][i];

          FxNoise_[2][i] = FxNoise_[1][i];
          FyNoise_[2][i] = FyNoise_[1][i];
          FzNoise_[2][i] = FzNoise_[1][i];
             
          FxNoise_[1][i] = FxNoise_[0][i];
          FyNoise_[1][i] = FyNoise_[0][i];
          FzNoise_[1][i] = FzNoise_[0][i];
     
       }  
              
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
          
          fread(&(FxNoise_[0][i]), d_size, 1, InputADBFile_);
          fread(&(FyNoise_[0][i]), d_size, 1, InputADBFile_);
          fread(&(FzNoise_[0][i]), d_size, 1, InputADBFile_);
            
       }
       
    }    
    
    else {
       
       printf("Unknown ADB read case: %d \n",TimeCase);
       fflush(NULL);
       exit(1);
       
    }    
    
    // Read in surface velocities on the computational mesh

    // This will be N - TimeCase
    
    if ( TimeCase >= 0 && TimeCase <= 5 ) {
       
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
   
          fread(&(UNoise_[TimeCase][i]), d_size, 1, InputADBFile_);
          fread(&(VNoise_[TimeCase][i]), d_size, 1, InputADBFile_);
          fread(&(WNoise_[TimeCase][i]), d_size, 1, InputADBFile_);

       }  
       
    }
    
    // This will be N, but shift current to N-1
    
    else if ( TimeCase == -1 ) {

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

          UNoise_[5][i] = UNoise_[4][i];
          VNoise_[5][i] = VNoise_[4][i];
          WNoise_[5][i] = WNoise_[4][i];
          
          UNoise_[4][i] = UNoise_[3][i];
          VNoise_[4][i] = VNoise_[3][i];
          WNoise_[4][i] = WNoise_[3][i];

          UNoise_[3][i] = UNoise_[2][i];
          VNoise_[3][i] = VNoise_[2][i];
          WNoise_[3][i] = WNoise_[2][i];

          UNoise_[2][i] = UNoise_[1][i];
          VNoise_[2][i] = VNoise_[1][i];
          WNoise_[2][i] = WNoise_[1][i];
             
          UNoise_[1][i] = UNoise_[0][i];
          VNoise_[1][i] = VNoise_[0][i];
          WNoise_[1][i] = WNoise_[0][i];
     
       }  
              
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
   
          fread(&(UNoise_[0][i]), d_size, 1, InputADBFile_);
          fread(&(VNoise_[0][i]), d_size, 1, InputADBFile_);
          fread(&(WNoise_[0][i]), d_size, 1, InputADBFile_);
     
       }  
       
    }    
    
    else {
       
       printf("Unknown ADB read case: %d \n",TimeCase);
       fflush(NULL);
       exit(1);
       
    }
      
    // Loop over surfaces and read in solution

    for ( j = 1 ; j <= VSPGeom().Grid().NumberOfLoops() ; j++ ) {
  
       fread(&Cp,          f_size, 1, InputADBFile_); // Delta Cp, or CP
       fread(&Cp_Unsteady, f_size, 1, InputADBFile_); // Unsteady Delta Cp, or Cp
       fread(&Gamma,       f_size, 1, InputADBFile_); // Circulation strength

    }

    // Read in wake shape
    
    fread(&DumInt, i_size, 1, InputADBFile_);
 
    if ( Verbose_ ) { printf("There are %d trailing vortices for adb file output... \n",DumInt);fflush(NULL); };

    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
      
       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfTrailingVortices() ; i++ ) {
  
          VSPGeom().VortexSheet(k).TrailingVortex(i).SkipReadInFile(InputADBFile_);

       }
       
    }     
    
    // Read in control surface deflection angles
  
    for ( k = 1 ; k <= VSPGeom().NumberOfControlSurfaces() ; k++ ) {
    
       DumFloat = float( VSPGeom().ControlSurface(k).DeflectionAngle() );
    
       fread(&(DumFloat), f_size, 1, InputADBFile_); 
    
    }

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER InterpolateExistingSolution                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::InterpolateExistingSolution(double Time)
{
   
    int i, j, Edge, MaxSize;
    double *Result, DeltaCp;
   
    MaxSize = MAX(VSPGeom().Grid(MGLevel_).NumberOfLoops(), VSPGeom().Grid(MGLevel_).NumberOfEdges());
    
    Result = new double[MaxSize + 1];
    
    // Gamma
    
    InterpolateInTime(Time, GammaNoise_, Result, VSPGeom().Grid(MGLevel_).NumberOfLoops());
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) Gamma_[0][i] = Result[i];

    // Unsteady Cp and forces
   
    InterpolateInTime(Time, dCpUnsteadyNoise_, Result, VSPGeom().Grid(MGLevel_).NumberOfLoops());
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) VSPGeom().Grid(MGLevel_).LoopList(i).dCp_Unsteady() = Result[i];

    for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; j++ ) {
     
       VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fx() = 0.;
       VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fy() = 0.;
       VSPGeom().Grid(MGLevel_).EdgeList(j).Unsteady_Fz() = 0.;
    
    }
     
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       DeltaCp = VSPGeom().Grid(MGLevel_).LoopList(i).dCp_Unsteady();
    
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j++ ) {
          
          Edge = VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);
          
          VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fx() -= DeltaCp * VSPGeom().Grid(MGLevel_).LoopList(i).Area() * VSPGeom().Grid(MGLevel_).LoopList(i).Nx()/VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges();
          VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fy() -= DeltaCp * VSPGeom().Grid(MGLevel_).LoopList(i).Area() * VSPGeom().Grid(MGLevel_).LoopList(i).Ny()/VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges();
          VSPGeom().Grid(MGLevel_).EdgeList(Edge).Unsteady_Fz() -= DeltaCp * VSPGeom().Grid(MGLevel_).LoopList(i).Area() * VSPGeom().Grid(MGLevel_).LoopList(i).Nz()/VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges();
          
       }
      
    }

    // Unsteady velocities

    InterpolateInTime(Time, UNoise_, Result, VSPGeom().Grid(MGLevel_).NumberOfLoops());
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) VSPGeom().Grid(MGLevel_).LoopList(i).U() = Result[i];
    
    InterpolateInTime(Time, VNoise_, Result, VSPGeom().Grid(MGLevel_).NumberOfLoops());
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) VSPGeom().Grid(MGLevel_).LoopList(i).V() = Result[i];
    
    InterpolateInTime(Time, WNoise_, Result, VSPGeom().Grid(MGLevel_).NumberOfLoops());
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) VSPGeom().Grid(MGLevel_).LoopList(i).W() = Result[i];

    // Unsteady edge forces

    InterpolateInTime(Time, FxNoise_, Result, VSPGeom().Grid(MGLevel_).NumberOfEdges());
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) VSPGeom().Grid(MGLevel_).EdgeList(i).Fx() = Result[i];

    InterpolateInTime(Time, FyNoise_, Result, VSPGeom().Grid(MGLevel_).NumberOfEdges());
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) VSPGeom().Grid(MGLevel_).EdgeList(i).Fy() = Result[i];

    InterpolateInTime(Time, FzNoise_, Result, VSPGeom().Grid(MGLevel_).NumberOfEdges());
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) VSPGeom().Grid(MGLevel_).EdgeList(i).Fz() = Result[i];
 
    delete [] Result;
       
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER InterpolateInTime                             #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::InterpolateInTime(double Time, double **ArrayIn, double *ArrayOut, int NumValues)
{
   
   int i;
   double InterpTime[6], Wgt[5];
   double m0, m1, n0, n1, p0, p1, p, t;
   
   // Steady state case
   
   if ( SteadyStateNoise_ || DoSolutionInterrogation_ ) {

      for ( i = 1 ; i <= NumValues ; i++ ) {
         
         ArrayOut[i] = ArrayIn[0][i];
 
      }
      
   }      
   
   else {
      
      // Otherwise we have to interpolate in time
         
      InterpTime[0] = CurrentTime_ +    DeltaTime_;
      InterpTime[1] = CurrentTime_               ;
      InterpTime[2] = CurrentTime_ -    DeltaTime_;
      InterpTime[3] = CurrentTime_ - 2.*DeltaTime_;
      InterpTime[4] = CurrentTime_ - 3.*DeltaTime_;
      InterpTime[5] = CurrentTime_ - 4.*DeltaTime_;

      if ( Time > InterpTime[1] ) {
   
         for ( i = 1 ; i <= NumValues ; i++ ) {
            
            ArrayOut[i] = ArrayIn[1][i];
               
         }
   
      }
      
      else if ( Time < InterpTime[2] ) {
         
         for ( i = 1 ; i <= NumValues ; i++ ) {
            
            ArrayOut[i] = ArrayIn[2][i];
              
         }
   
      }
      
      else {
   
         // Linear interpolation
         
         if ( NoiseInterpolation_ == NOISE_LINEAR_INTERPOLATION ) {
     
            Wgt[0] = ( Time - InterpTime[2] ) / DeltaTime_;
            Wgt[1] = 1. - Wgt[0];
      
            for ( i = 1 ; i <= NumValues ; i++ ) {
               
               ArrayOut[i] = Wgt[1] * ArrayIn[2][i] + Wgt[0] * ArrayIn[1][i];
       
            }
            
         }
         
         // Quadratic interpolation
         
         else if ( NoiseInterpolation_ == NOISE_QUADRATIC_INTERPOLATION ) {
            
            Wgt[2] = 0.5*( Time - InterpTime[2] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ );
            Wgt[1] =    -( Time - InterpTime[3] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ );
            Wgt[0] = 0.5*( Time - InterpTime[3] ) * ( Time - InterpTime[2] ) / ( DeltaTime_ * DeltaTime_ );
   
            for ( i = 1 ; i <= NumValues ; i++ ) {
               
               ArrayOut[i] = Wgt[2] * ArrayIn[3][i] + Wgt[1] * ArrayIn[2][i] + Wgt[0] * ArrayIn[1][i];
       
            }
                     
         }
   
         // Cubic interpolation
         
         // 0 3
         // 1 2
         // 2 1
         // 3 0
         
         else if ( NoiseInterpolation_ == NOISE_CUBIC_INTERPOLATION ) {
            
            Wgt[3] = -( Time - InterpTime[3] ) * ( Time - InterpTime[2] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ )/6.;
            Wgt[2] =  ( Time - InterpTime[4] ) * ( Time - InterpTime[2] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ )/2.;
            Wgt[1] = -( Time - InterpTime[4] ) * ( Time - InterpTime[3] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ )/2.;
            Wgt[0] =  ( Time - InterpTime[4] ) * ( Time - InterpTime[3] ) * ( Time - InterpTime[2] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ )/6.;
   
            for ( i = 1 ; i <= NumValues ; i++ ) {
               
               ArrayOut[i] = Wgt[3] * ArrayIn[4][i] + Wgt[2] * ArrayIn[3][i] + Wgt[1] * ArrayIn[2][i] + Wgt[0] * ArrayIn[1][i];
       
            }
                     
         }
   
         // Quartic interpolation
         
         else if ( NoiseInterpolation_ == NOISE_QUARTIC_INTERPOLATION ) {
            
            Wgt[4] =  ( Time - InterpTime[4] ) * ( Time - InterpTime[3] ) * ( Time - InterpTime[2] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ * DeltaTime_ )/24.;  //  (4-3)*(4-2)*(4-1)*(4-0)    ( 1)( 2)( 3)( 4) =  24
            Wgt[3] = -( Time - InterpTime[5] ) * ( Time - InterpTime[3] ) * ( Time - InterpTime[2] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ * DeltaTime_ )/6.;   //  (3-4)*(3-2)*(3-1)*(3-0)    (-1)( 1)( 2)( 3) = -6
            Wgt[2] =  ( Time - InterpTime[5] ) * ( Time - InterpTime[4] ) * ( Time - InterpTime[2] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ * DeltaTime_ )/4.;   //  (2-4)*(2-3)*(2-1)*(2-0)    (-2)(-1)( 1)( 2) =  4
            Wgt[1] = -( Time - InterpTime[5] ) * ( Time - InterpTime[4] ) * ( Time - InterpTime[3] ) * ( Time - InterpTime[1] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ * DeltaTime_ )/6.;   //  (1-4)*(1-3)*(1-2)*(1-0)    (-3)(-2)(-1)( 1) = -6
            Wgt[0] =  ( Time - InterpTime[5] ) * ( Time - InterpTime[4] ) * ( Time - InterpTime[3] ) * ( Time - InterpTime[2] ) / ( DeltaTime_ * DeltaTime_ * DeltaTime_ * DeltaTime_ )/24.;  //  (0-4)*(0-3)*(0-2)*(0-1)    (-4)(-3)(-2)(-1) =  24
   
            for ( i = 1 ; i <= NumValues ; i++ ) {
               
               ArrayOut[i] = Wgt[4] * ArrayIn[5][i] + Wgt[3] * ArrayIn[4][i] + Wgt[2] * ArrayIn[3][i] + Wgt[1] * ArrayIn[2][i] + Wgt[0] * ArrayIn[1][i];
       
            }
                     
         }
   
         // Cubic Hermite Spline
         
         else if ( NoiseInterpolation_ == NOISE_CUBIC_HERMITE_INTERPOLATION ) {
            
            for ( i = 1 ; i <= NumValues ; i++ ) {
               
               // Slopes
               
               m1 = 0.5*( ArrayIn[0][i] - ArrayIn[2][i] );
               m0 = 0.5*( ArrayIn[1][i] - ArrayIn[3][i] );
    
               // End values
               
               p1 = ArrayIn[1][i];
               p0 = ArrayIn[2][i];
               
               // 0-1 interval value
               
               t = ( Time - InterpTime[2] ) / DeltaTime_;
               
               // Final interpolation
               
               p = ( 2.*t*t*t - 3.*t*t + 1.)*p0 + (t*t*t - 2.*t*t + t)*m0 + (-2.*t*t*t + 3.*t*t)*p1 + (t*t*t - t*t)*m1;
                              
               ArrayOut[i] = p;
       
            }
                     
         }
   
         // Quintic Hermite Spline
         
         else if ( NoiseInterpolation_ == NOISE_QUINTIC_HERMITE_INTERPOLATION ) {
            
            for ( i = 1 ; i <= NumValues ; i++ ) {
               
               // Slopes
               
               m1 = 0.5*( ArrayIn[0][i] - ArrayIn[2][i] );
               m0 = 0.5*( ArrayIn[1][i] - ArrayIn[3][i] );
               
               // 2nd derivatives
   
               n1 = ( ArrayIn[0][i] - 2.*ArrayIn[1][i] + ArrayIn[2][i] );
               n0 = ( ArrayIn[1][i] - 2.*ArrayIn[2][i] + ArrayIn[3][i] );
   
               // End values
               
               p1 = ArrayIn[1][i];
               p0 = ArrayIn[2][i];
               
               // 0-1 interval value
               
               t = ( Time - InterpTime[2] ) / DeltaTime_;
               
               // Final interpolation
               
               p = ( 1.0                       - 10.0*t*t*t + 15.0*t*t*t*t - 6.0*t*t*t*t*t )*p0
                 + (           t               -  6.0*t*t*t +  8.0*t*t*t*t - 3.0*t*t*t*t*t )*m0
                 + (                   0.5*t*t -  1.5*t*t*t +  1.5*t*t*t*t - 0.5*t*t*t*t*t )*n0
                 + (                              0.5*t*t*t -  1.0*t*t*t*t + 0.5*t*t*t*t*t )*n1
                 + (                           -  4.0*t*t*t +  7.0*t*t*t*t - 3.0*t*t*t*t*t )*m1
                 + (                             10.0*t*t*t - 15.0*t*t*t*t + 6.0*t*t*t*t*t )*p1;
                              
               ArrayOut[i] = p;
       
            }
                     
         }
                                 
         else {
            
            printf("Unknown type of interpolation method in noise routines! \n");
            fflush(NULL);
            exit(1);
            
         }
   
      }
      
   }

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER SavePeriodicNoiseSolution                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::SavePeriodicNoiseSolution(void)
{
   
    int i;
    
    // Save Gamma
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
       GammaNoise_[6][i] = GammaNoise_[0][i];
       GammaNoise_[7][i] = GammaNoise_[1][i];
       GammaNoise_[8][i] = GammaNoise_[2][i];

    }
    
    // Save the unsteady Cp
  
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
       dCpUnsteadyNoise_[6][i] = dCpUnsteadyNoise_[0][i];
       dCpUnsteadyNoise_[7][i] = dCpUnsteadyNoise_[1][i];
       dCpUnsteadyNoise_[8][i] = dCpUnsteadyNoise_[2][i];

    }
    
    // Save velocities
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
    
       UNoise_[6][i] = UNoise_[0][i];
       VNoise_[6][i] = VNoise_[0][i];        
       WNoise_[6][i] = WNoise_[0][i];           

       UNoise_[7][i] = UNoise_[1][i];
       VNoise_[7][i] = VNoise_[1][i];        
       WNoise_[7][i] = WNoise_[1][i];           

       UNoise_[8][i] = UNoise_[2][i];
       VNoise_[8][i] = VNoise_[2][i];        
       WNoise_[8][i] = WNoise_[2][i];           
    
    }    
    
    // Save edge forces

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
       
       FxNoise_[6][i] = FxNoise_[0][i]; 
       FyNoise_[6][i] = FyNoise_[0][i]; 
       FzNoise_[6][i] = FzNoise_[0][i]; 

       FxNoise_[7][i] = FxNoise_[1][i]; 
       FyNoise_[7][i] = FyNoise_[1][i]; 
       FzNoise_[7][i] = FzNoise_[1][i]; 

       FxNoise_[8][i] = FxNoise_[2][i]; 
       FyNoise_[8][i] = FyNoise_[2][i]; 
       FzNoise_[8][i] = FzNoise_[2][i]; 
         
    }
      
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER RestorePeriodicNoiseSolution                  #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestorePeriodicNoiseSolution(void)
{
   
    int i;
    
    // Restore Gamma
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
       GammaNoise_[0][i] = GammaNoise_[6][i];
       GammaNoise_[1][i] = GammaNoise_[7][i];
       GammaNoise_[2][i] = GammaNoise_[8][i];

    }
    
    // Restore the unsteady Cp
  
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
          
       dCpUnsteadyNoise_[0][i] = dCpUnsteadyNoise_[6][i];
       dCpUnsteadyNoise_[1][i] = dCpUnsteadyNoise_[7][i];
       dCpUnsteadyNoise_[2][i] = dCpUnsteadyNoise_[8][i];

    }
    
    // Restore velocities
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
    
       UNoise_[0][i] = UNoise_[6][i];
       VNoise_[0][i] = VNoise_[6][i];        
       WNoise_[0][i] = WNoise_[6][i];           

       UNoise_[1][i] = UNoise_[7][i];
       VNoise_[1][i] = VNoise_[7][i];        
       WNoise_[1][i] = WNoise_[7][i];           

       UNoise_[2][i] = UNoise_[8][i];
       VNoise_[2][i] = VNoise_[8][i];        
       WNoise_[2][i] = WNoise_[8][i];           
    
    }    
    
    // Restore edge forces

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
       
       FxNoise_[0][i] = FxNoise_[6][i]; 
       FyNoise_[0][i] = FyNoise_[6][i]; 
       FzNoise_[0][i] = FzNoise_[6][i]; 
                                 
       FxNoise_[1][i] = FxNoise_[7][i]; 
       FyNoise_[1][i] = FyNoise_[7][i]; 
       FzNoise_[1][i] = FzNoise_[7][i]; 
                                 
       FxNoise_[2][i] = FxNoise_[8][i]; 
       FyNoise_[2][i] = FyNoise_[8][i]; 
       FzNoise_[2][i] = FzNoise_[8][i]; 
         
    }
      
}

/*##############################################################################
#                                                                              #
#                        VSP_SOLVER WriteRestartFile                           #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteRestartFile(void)
{
    
    int i, i_size, d_size;
    char FileNameWithExt[MAX_CHAR_SIZE];
    FILE *RestartFile;
    
    printf("Saving restart file... \n");fflush(NULL);

    i_size = sizeof(int);

    d_size = sizeof(double);
    
    // Open restart file
    
    snprintf(FileNameWithExt,sizeof(FileNameWithExt)*sizeof(char),"%s.restart",FileName_);
    
    if ( (RestartFile = fopen(FileNameWithExt, "wb")) == NULL ) {

       printf("Could not open the restart file for output! \n");

       exit(1);

    }   
    
    // Write out the grid level we solved on
    
    fwrite(&(MGLevel_), i_size, 1, RestartFile);
    
    // Write out the vortex strengths
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {

       fwrite(&(Gamma_[0][i]), d_size, 1, RestartFile);
       fwrite(&(Gamma_[1][i]), d_size, 1, RestartFile);
       fwrite(&(Gamma_[2][i]), d_size, 1, RestartFile);
       
    }    
    
    fclose(RestartFile);

}

/*##############################################################################
#                                                                              #
#                        VSP_SOLVER LoadRestartFile                            #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::LoadRestartFile(void)
{

    int i, i_size, d_size, Level;
    char FileNameWithExt[MAX_CHAR_SIZE];
    FILE *RestartFile;
    
    printf("Loading restart file... \n");fflush(NULL);
    
    i_size = sizeof(int);
    
    d_size = sizeof(double);
    
    // Open restart file
    
    snprintf(FileNameWithExt,sizeof(FileNameWithExt)*sizeof(char),"%s.restart",FileName_);
    
    if ( (RestartFile = fopen(FileNameWithExt, "rb")) == NULL ) {

       printf("Could not open the restart file for output! \n");

       exit(1);

    }   
    
    // Read in the grid level we solved on
    
    fread(&(Level), i_size, 1, RestartFile);    
    
    // Write in the vortex strengths
    
    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
     
       fread(&(Gamma_[0][i]), d_size, 1, RestartFile);
       fread(&(Gamma_[1][i]), d_size, 1, RestartFile);
       fread(&(Gamma_[2][i]), d_size, 1, RestartFile);
       
    }    
    
    fclose(RestartFile);
    
    // See if restart file was for the same level we are solving
    // on now... otherwise we need to prolongate the solution
    
    if ( Level != MGLevel_ ) InterpolateSolutionFromGrid(Level);

}

/*##############################################################################
#                                                                              #
#            VSP_SOLVER CreateSurfaceVorticesInteractionList                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CreateSurfaceVorticesInteractionList(void)
{
 
    int i, j, k, p, cpu, Level, Loop, NumberOfEdges, NumberOfLoops, CurrentLoop;
    int TestEdge, MaxInteractionLoops, MaxInteractionEdges, LoopOffSet;
    int Done, Found, TotalFound, CommonEdges, MaxLevels, **EdgeIsCommon;
    int LoopType;

    double xyz[3], Vec[3], Distance, Test;

    INTERACTION_LISTS *InteractionList;

    // Allocate space for final interaction lists

    MaxInteractionLoops = MaxInteractionEdges = 0;
    
    for ( Level = 1 ; Level <= VSPGeom().NumberOfGridLevels() ; Level++ ) {
       
       MaxInteractionLoops += VSPGeom().Grid(Level).NumberOfLoops();
       
    }

    for ( Level = 1 ; Level <= VSPGeom().NumberOfGridLevels() ; Level++ ) {

       MaxInteractionEdges += VSPGeom().Grid(Level).NumberOfEdges();
       
    }

    LoopType = 0;
    
    // Forward loop list
    
    FastMatrix_.SizeForwardLoopList(LoopType,MaxInteractionEdges);
    
    FastMatrix_.NumberOfForwardInteractionLoops(LoopType) = 0;

    if ( CurrentWakeIteration_ == 0 && LoopType == FIXED_LOOPS ) { printf("Creating interaction lists... \n\n");fflush(NULL); };

    // Forward sweep
    
    if ( CurrentWakeIteration_ == 0 && LoopType == FIXED_LOOPS ) printf("Forward sweep... \n");

    FastMatrix_.NumberOfForwardInteractionLoops(LoopType) = VSPGeom().Grid(MGLevel_).NumberOfLoops();

#pragma omp parallel for private(xyz,InteractionList,NumberOfEdges,NumberOfLoops,i) schedule(dynamic)
    for ( k = 1 ; k <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; k++ ) {

       if ( LoopType == FIXED_LOOPS && (k/1000)*1000 == k ) { printf("%d / %d \r",k,VSPGeom().Grid(MGLevel_).NumberOfLoops());fflush(NULL); };

       xyz[0] = VSPGeom().Grid(MGLevel_).LoopList(k).Xc();
       xyz[1] = VSPGeom().Grid(MGLevel_).LoopList(k).Yc();
       xyz[2] = VSPGeom().Grid(MGLevel_).LoopList(k).Zc();

       InteractionList = CreateInteractionList(VSPGeom().Grid(MGLevel_).LoopList(k).ComponentID(), k, xyz);

       // Save the sorted edge list

       NumberOfEdges = InteractionList->NumberOfInteractionEdges;
      
       FastMatrix_.ForwardInteractionLoopList(LoopType)[k].Level() = MGLevel_;
                                        
       FastMatrix_.ForwardInteractionLoopList(LoopType)[k].Loop() = k;
                                        
       FastMatrix_.ForwardInteractionLoopList(LoopType)[k].SizeEdgeList(NumberOfEdges);
       
       for ( i = 1 ; i <= FastMatrix_.ForwardInteractionLoopList(LoopType)[k].NumberOfVortexEdges() ; i++ ) {

          FastMatrix_.ForwardInteractionLoopList(LoopType)[k].SurfaceVortexEdgeInteractionList()[i] = InteractionList->EdgeInteractionList[i];

       }       

    }

    // Now do backwards sweep / multipole on forward list
 
    FastMatrix_.MergeForwardList(NumberOfThreads_, MGLevel_, LoopType, VSPGeom_, Mach_, FarAway_);

    if ( CurrentWakeIteration_ == 0 && LoopType == FIXED_LOOPS ) printf("Forward Mode: total multipole speed up ratio: %Lf \n",FastMatrix_.ForwardSpeedRatio());
    
    // Create forward edge interaction list
 
    FastMatrix_.CreateForwardEdgeList(NumberOfThreads_, MGLevel_, LoopType, VSPGeom_);
   
}

/*##############################################################################
#                                                                              #
#            VSP_SOLVER CalculateSurfaceInducedVelocityAtPoint                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateSurfaceInducedVelocityAtPoint(double xyz[3], double q[3])
{
 
    int j, NumberOfEdges;
    double U, V, W, dq[3];
    VSP_EDGE *VortexEdge;
    INTERACTION_LISTS *InteractionList;
    
    // Create interaction list for this xyz location

    InteractionList = CreateInteractionList(0, 0, xyz);
    
    NumberOfEdges = InteractionList->NumberOfInteractionEdges;

    U = V = W = 0.;

#pragma omp parallel for reduction(+:U,V,W) private(j,VortexEdge,dq)
    for ( j = 1 ; j <= NumberOfEdges ; j++ ) {
     
       VortexEdge = InteractionList->EdgeInteractionList[j];
 
       VortexEdge->InducedVelocity(xyz, dq);
 
       U += dq[0];
       V += dq[1];
       W += dq[2];
  
    }

    q[0] = U;
    q[1] = V;
    q[2] = W;    

}

/*##############################################################################
#                                                                              #
#     VSP_SOLVER CalculateSurfaceInducedVelocityAtOffBodyPoint                 #
#                                                                              #
##############################################################################*/

int VSP_SOLVER::CalculateSurfaceInducedVelocityAtOffBodyPoint(double xyz[3], double q[3])
{
 
    int j, Hits, NumberOfEdges, Loop1, Loop2;
    double U1, V1, W1, U2, V2, W2, dq[3], Distance, Weight, TotalWeight;
    VSP_EDGE *VortexEdge;
    INTERACTION_LISTS *InteractionList;
    
    // Create interaction list for this xyz location

    InteractionList = CreateInteractionList(0, 0, xyz);
    
    NumberOfEdges = InteractionList->NumberOfInteractionEdges;

    U1 = V1 = W1 = 0.;

#pragma omp parallel for reduction(+:U1,V1,W1) private(j,VortexEdge,dq)
    for ( j = 1 ; j <= NumberOfEdges ; j++ ) {
     
       VortexEdge = InteractionList->EdgeInteractionList[j];
 
       VortexEdge->InducedVelocity(xyz, dq);
 
       U1 += dq[0];
       V1 += dq[1];
       W1 += dq[2];
  
    }

    Hits = 0;
    
    U2 = V2 = W2 = TotalWeight = 0.;

#pragma omp parallel for reduction(+:U2,V2,W2,Hits,TotalWeight) private(j,VortexEdge,dq,Distance,Loop1,Loop2,Weight)
    for ( j = 1 ; j <= NumberOfEdges ; j++ ) {
     
       VortexEdge = InteractionList->EdgeInteractionList[j];
 
       if ( VortexEdge->Level() == 1 && VortexEdge->SurfaceID() > 0 ) {
          
          Distance = sqrt( pow(xyz[0] - VortexEdge->Xc(), 2.)
                         + pow(xyz[1] - VortexEdge->Yc(), 2.)
                         + pow(xyz[2] - VortexEdge->Zc(), 2.) );
                         
          if ( Distance <= VortexEdge->Length() && ( Mach_ < 1. || xyz[0] - VortexEdge->Xc() > 0. ) ) {
             
             Loop1 = VortexEdge->Loop1();
             Loop2 = VortexEdge->Loop2();
             
             Weight = 1./MAX(1.e-7,Distance);
             
             U2 += 0.5*Weight*(VSPGeom().Grid(MGLevel_).LoopList(Loop1).U() + VSPGeom().Grid(MGLevel_).LoopList(Loop2).U());
             V2 += 0.5*Weight*(VSPGeom().Grid(MGLevel_).LoopList(Loop1).V() + VSPGeom().Grid(MGLevel_).LoopList(Loop2).V());
             W2 += 0.5*Weight*(VSPGeom().Grid(MGLevel_).LoopList(Loop1).W() + VSPGeom().Grid(MGLevel_).LoopList(Loop2).W());
                    
             TotalWeight += Weight;
                       
             Hits++;
       
          }
          
       }
  
    }

    if ( DoSymmetryPlaneSolve_ && ABS(xyz[1]) <= 0.001 ) V2 = 0.;
    
    if ( Hits > 0 ) {
       
       U1 = U2 / TotalWeight;
       V1 = V2 / TotalWeight;
       W1 = W2 / TotalWeight;
       
    }

    q[0] = U1;
    q[1] = V1;
    q[2] = W1;    
    
    if ( Hits ) return 1;
    
    return 0;

}

/*##############################################################################
#                                                                              #
#            VSP_SOLVER CalculateSurfaceInducedVelocityAtPoint                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateSurfaceInducedVelocityAtPoint(int ComponentID, int pLoop, double xyz[3], double q[3])
{
 
    int j, NumberOfEdges;
    double U, V, W, dq[3];
    VSP_EDGE *VortexEdge;
    INTERACTION_LISTS *InteractionList;
    
    // Create interaction list for this xyz location

    InteractionList = CreateInteractionList(ComponentID, pLoop, xyz);

    NumberOfEdges = InteractionList->NumberOfInteractionEdges;

    U = V = W = 0.;

#pragma omp parallel for reduction(+:U,V,W) private(j,VortexEdge,dq)
    for ( j = 1 ; j <= NumberOfEdges ; j++ ) {
     
       VortexEdge = InteractionList->EdgeInteractionList[j];

       VortexEdge->InducedVelocity(xyz, dq);
   
       U += dq[0];
       V += dq[1];
       W += dq[2];

    }
    
    q[0] = U;
    q[1] = V;
    q[2] = W;    

}

/*##############################################################################
#                                                                              #
#            VSP_SOLVER CalculateSurfaceInducedVelocityAtPoint                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateSurfaceInducedVelocityAtPoint(double xyz[3], double q[3], double CoreWidth)
{
 
    int j, NumberOfEdges;
    double U, V, W, dq[3];
    VSP_EDGE *VortexEdge;
    INTERACTION_LISTS *InteractionList;
     
    // Create interaction list for this xyz location

    InteractionList = CreateInteractionList(0, 0, xyz);

    NumberOfEdges = InteractionList->NumberOfInteractionEdges;

    U = V = W = 0.;

#pragma omp parallel for reduction(+:U,V,W) private(j,VortexEdge,dq)
    for ( j = 1 ; j <= NumberOfEdges ; j++ ) {
     
       // Calculate induced velocity from this edge
       
       VortexEdge = InteractionList->EdgeInteractionList[j];

       VortexEdge->InducedVelocity(xyz, dq);
       
       // Add in induced velocity

       U += dq[0];
       V += dq[1];
       W += dq[2];

    }

    q[0] = U;
    q[1] = V;
    q[2] = W;    
        
}

/*##############################################################################
#                                                                              #
#                 VSP_SOLVER AdjustNearSurfaceVelocities                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::AdjustNearSurfaceVelocities(double xyz[3], double q[3], int NumberOfEdges, VSP_EDGE **InteractionList)
{
 
    int j;
    double Vec1[3], Vec2[3], qVec[3], Normal[3], Dot, Distance, Ratio, Angle;
    VSP_EDGE *VortexEdge;
 
    // Adjust velocities near panel model surfaces
    
    if ( VSPGeom().ModelType() == PANEL_MODEL && !TimeAccurate_ ) {
 
       qVec[0] = q[0];
       qVec[1] = q[1];
       qVec[2] = q[2];
       
       if ( DoSymmetryPlaneSolve_ && xyz[1] < 0. ) qVec[1] *= -1.;

       for ( j = 1 ; j <= NumberOfEdges ; j++ ) {
          
          VortexEdge = InteractionList[j];
          
          // Are we on the finest grid level
  
          if ( VortexEdge->Level() <= 1 ) {

             // Calculate distance to surface

             Vec1[0] = xyz[0];
             Vec1[1] = xyz[1];
             Vec1[2] = xyz[2];

             Vec2[0] = VortexEdge->Xc();
             Vec2[1] = VortexEdge->Yc();
             Vec2[2] = VortexEdge->Zc();

             if ( DoSymmetryPlaneSolve_ && xyz[1] < 0. ) Vec1[1] *= -1.;

             Vec1[0] -= Vec2[0];
             Vec1[1] -= Vec2[1];
             Vec1[2] -= Vec2[2];
             
             // Calculate angle
             
             Distance = sqrt(vector_dot(Vec1,Vec1));

             Normal[0] = VortexEdge->Normal()[0];
             Normal[1] = VortexEdge->Normal()[1];
             Normal[2] = VortexEdge->Normal()[2];
             
             if ( DoSymmetryPlaneSolve_ && xyz[1] < 0. ) Normal[1] *= -1.;
             
             Dot = vector_dot(Vec1,Normal);
             
             Dot /= Distance;
             
             Dot = MAX(-1.,MIN(Dot,1.));
             
             Angle = acos(Dot);
             
             if ( Dot > 0. && Angle <= 0.5*PI ) {
             
                // Ratio of distance to surface edge length
                
                Ratio = Distance / VortexEdge->Length();
                
                // Component of velocity in direction of surface normal
                             
                Dot = vector_dot(Normal, qVec);
                
                // Does velocity pull us into body
         
                if ( Dot < 0. && Ratio < 1. ) {
   
                   // Damp out velocity near wall
    
                   Dot *= exp(-5.*Ratio);

                   qVec[0] -= Dot * Normal[0];
                   qVec[1] -= Dot * Normal[1];
                   qVec[2] -= Dot * Normal[2];
                      
                }
   
             }
             
          }
          
       }

       if ( DoSymmetryPlaneSolve_ && xyz[1] < 0. ) qVec[1] *= -1.;

       q[0] = qVec[0];
       q[1] = qVec[1];
       q[2] = qVec[2];
       
    } 

}

/*##############################################################################
#                                                                              #
#                    VSP_SOLVER CreateInteractionList                          #
#                                                                              #
##############################################################################*/

INTERACTION_LISTS *VSP_SOLVER::CreateInteractionList(int ComponentID, int pLoop, double xyz[3])
{

    int i, j, cpu, CoarseGridEdge, Level, Loop, LoopComponentID;
    int StackSize, MoveDownLevel, Next, AddEdges, NumberOfUsedEdges;
    int NumberOfInteractionLoops, NumberOfInteractionEdges;
    double Distance, Test, NormalDistance, Vec[3], Tolerance, Ratio;

    // Grab the current cpu thread id

#ifdef VSPAERO_OPENMP  
    cpu = omp_get_thread_num();
#else
    cpu = 0;
#endif    

    // Insert loops on coarsest level into stack
    
    Level = VSPGeom().NumberOfGridLevels();
 
    StackSize = 0;

    for ( Loop = 1 ; Loop <= VSPGeom().Grid(Level).NumberOfLoops() ; Loop++ ) {
     
       StackSize++;
       
       LoopStackList_[cpu][StackSize].Level = Level;
       LoopStackList_[cpu][StackSize].Loop  = Loop;

    }

    // Update the search ID value... reset things after we have done all the loops
    
    SearchID_[cpu]++;
    
    if ( SearchID_[cpu] > VSPGeom().Grid(MGLevel_).NumberOfLoops() ) {
    
       for ( Level = 1 ; Level <= VSPGeom().NumberOfGridLevels() ; Level++ ) {
      
          zero_int_array(EdgeIsUsed_[cpu][Level], VSPGeom().Grid(Level).NumberOfEdges()); 
        
          zero_int_array(LoopIsUsed_[cpu][Level], VSPGeom().Grid(Level).NumberOfLoops()); 
          
       }
       
       SearchID_[cpu] = 1;

    }

    // Now loop over stack and begin AGMP process

    NumberOfUsedEdges = 0;

    Next = 1;
        
    while ( Next <= StackSize ) {
     
       Level = LoopStackList_[cpu][Next].Level;
       Loop  = LoopStackList_[cpu][Next].Loop;
       
       LoopComponentID = VSPGeom().Grid(Level).LoopList(Loop).ComponentID();
           
       // If we are far enough away from this loop, add it's edges to the interaction list
             
       MoveDownLevel = 0;

       Vec[0] = xyz[0] - VSPGeom().Grid(Level).LoopList(Loop).Xc();
       Vec[1] = xyz[1] - VSPGeom().Grid(Level).LoopList(Loop).Yc();
       Vec[2] = xyz[2] - VSPGeom().Grid(Level).LoopList(Loop).Zc();
       
       if ( Mach_ > 1. ) Vec[0] /= (Mach_*Mach_ - 1.);

       Distance = sqrt( SQR(Vec[0]) + SQR(Vec[1]) + SQR(Vec[2]) );
       
       if ( pLoop > 0 ) Distance -= 0.5*VSPGeom().Grid(MGLevel_).LoopList(pLoop).Length();
  
       Test = FarAway_ * ( VSPGeom().Grid(Level).LoopList(Loop).Length() + VSPGeom().Grid(Level).LoopList(Loop).CentroidOffSet() );

       if ( Level == MGLevel_ || ( Test <= Distance && !inside_box(VSPGeom().Grid(Level).LoopList(Loop).BoundBox(), xyz) ) ) {

          if ( !TimeAccurate_ || ( TimeAccurate_ && VSPGeom().Grid(Level).LoopList(Loop).MinValidTimeStep() <= Time_ ) ) {

             // Add loop to list
             
             if ( LoopIsUsed_[cpu][Level][Loop] != SearchID_[cpu] ) LoopIsUsed_[cpu][Level][Loop] = SearchID_[cpu];

             // Add edges to list
             
             for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfEdges() ; i++ ) {
       
                j = VSPGeom().Grid(Level).LoopList(Loop).Edge(i);
                
                if ( EdgeIsUsed_[cpu][Level][j] != SearchID_[cpu] ) {

                   EdgeIsUsed_[cpu][Level][j] = SearchID_[cpu];

                }
                
             }
             
          }
             
       }
       
       // If xyz too close to this loop, move down a level
       
       else {

          if ( Level > MGLevel_ ) {
         
             for ( i = 1 ; i <= VSPGeom().Grid(Level).LoopList(Loop).NumberOfFineGridLoops() ; i++ ) {

                StackSize++;
    
                LoopStackList_[cpu][StackSize].Level = Level - 1;
                
                LoopStackList_[cpu][StackSize].Loop  = VSPGeom().Grid(Level).LoopList(Loop).FineGridLoop(i);

             }   
             
          }
                    
       }
         
       // Move onto next entry in the stack

       Next++;
       
    }
    
    // Pack the edge list
 
    NumberOfInteractionEdges = 0;

    // Add in all the used edges on the coarsest grid level

    Level = VSPGeom().NumberOfGridLevels();

    for ( i = VSPGeom().Grid(Level).NumberOfEdges() ; i >= 1 ; i-- ) {

       if ( EdgeIsUsed_[cpu][Level][i] == SearchID_[cpu] ) TempInteractionList_[cpu].EdgeInteractionList[++NumberOfInteractionEdges] = &(VSPGeom().Grid(Level).EdgeList(i)); 
       
    }

    // Add in the finer grid edges that are not already marked on a coarser grid
    
    for ( Level = VSPGeom().NumberOfGridLevels() - 1 ; Level >= MGLevel_ ; Level-- ) {
    
       for ( i = VSPGeom().Grid(Level).NumberOfEdges() ; i >= 1 ; i-- ) {

         // Add those edges that are used at this level
         
         if ( EdgeIsUsed_[cpu][Level][i] == SearchID_[cpu] ) {

             CoarseGridEdge = VSPGeom().Grid(Level).EdgeList(i).CoarseGridEdge();
             
             // Coarse edge was not added, so add this one in

             if ( EdgeIsUsed_[cpu][Level+1][CoarseGridEdge] != SearchID_[cpu] ) {

                TempInteractionList_[cpu].EdgeInteractionList[++NumberOfInteractionEdges] = &(VSPGeom().Grid(Level).EdgeList(i));    
               
             }

          }    
          
       }   
       
    }
    
    TempInteractionList_[cpu].NumberOfInteractionEdges = NumberOfInteractionEdges;
   
    // Reverse order of the edge list
    
    VSP_EDGE *TempEdge;
    
    for ( i = 1 ; i <= NumberOfInteractionEdges / 2 ; i++ ) {

       TempEdge = TempInteractionList_[cpu].EdgeInteractionList[i];
       
       TempInteractionList_[cpu].EdgeInteractionList[i] = TempInteractionList_[cpu].EdgeInteractionList[NumberOfInteractionEdges - i + 1];
       
       TempInteractionList_[cpu].EdgeInteractionList[NumberOfInteractionEdges - i + 1] = TempEdge;
              
    }
    
    // Pack the loop list
 
    NumberOfInteractionLoops = 0;

    // Add in all the used loops at each level

    for ( Level = VSPGeom().NumberOfGridLevels() ; Level >= MGLevel_ ; Level-- ) {

       for ( i = VSPGeom().Grid(Level).NumberOfLoops() ; i >= 1 ; i-- ) {
      
          if ( LoopIsUsed_[cpu][Level][i] == SearchID_[cpu] ) TempInteractionList_[cpu].LoopInteractionList[++NumberOfInteractionLoops] = &(VSPGeom().Grid(Level).LoopList(i)); 

       }
       
    }

    TempInteractionList_[cpu].NumberOfInteractionLoops = NumberOfInteractionLoops;

    // Reverse order of the loop list
    
    VSP_LOOP *TempLoop;
    
    for ( i = 1 ; i <= NumberOfInteractionLoops / 2 ; i++ ) {
 
       TempLoop = TempInteractionList_[cpu].LoopInteractionList[i];
       
       TempInteractionList_[cpu].LoopInteractionList[i] = TempInteractionList_[cpu].LoopInteractionList[NumberOfInteractionLoops - i + 1];
       
       TempInteractionList_[cpu].LoopInteractionList[NumberOfInteractionLoops - i + 1] = TempLoop;
              
    }        
    
    return &(TempInteractionList_[cpu]);
    
}

/*##############################################################################
#                                                                              #
#                        VSP_SOLVER NodeIsInsideLoop                           #
#                                                                              #
##############################################################################*/

int VSP_SOLVER::NodeIsInsideLoop(VSP_LOOP &Loop, double xyz[3])
{
   
   int i, Edge;
   
   for ( i = 1 ; i <= Loop.NumberOfEdges() ; i++ ) {
  
      Edge = Loop.Edge(i);
      
   }   
   
   return 1;
   
}

/*##############################################################################
#                                                                              #
#                   VSP_SOLVER ProlongateSolutionFromGrid                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ProlongateSolutionFromGrid(int Level)
{
 
    int i_c, i_f, g_c, g_f;
    double Fact;
   
    g_c = Level;
    g_f = Level - 1;
    
    // Subtract out initial restricted solution from coarse the coarse grid
    // solution - this ends up with the correction being stored.

    for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfLoops() ; i_f++ ) {

       i_c = VSPGeom().Grid(g_f).LoopList(i_f).CoarseGridLoop();
       
       Fact = VSPGeom().Grid(g_f).LoopList(i_f).Area() 
            / VSPGeom().Grid(g_c).LoopList(i_c).Area();
  
       VSPGeom().Grid(g_c).LoopList(i_c).Gamma() -= Fact * VSPGeom().Grid(g_f).LoopList(i_f).Gamma();
       
    }

    // Prolongate correction from coarse to fine grid - direct injection

    for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfLoops() ; i_f++ ) {

       i_c = VSPGeom().Grid(g_f).LoopList(i_f).CoarseGridLoop();
  
       VSPGeom().Grid(g_f).LoopList(i_f).Gamma() += VSPGeom().Grid(g_c).LoopList(i_c).Gamma();
       
    }

}

/*##############################################################################
#                                                                              #
#                   VSP_SOLVER RestrictSolutionFromGrid                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestrictSolutionFromGrid(int Level)
{
 
    int i_c, i_f, g_c, g_f;

    // Restrict solution from Level i, to level i+1
    
    g_f = Level;
    g_c = Level + 1;
    
    // Zero out stuff on the coarsest grid

#pragma omp parallel for     
    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {

       VSPGeom().Grid(g_c).LoopList(i_c).Gamma() = 0.;

       VSPGeom().Grid(g_c).LoopList(i_c).StallFactor() = 0.;
       
       VSPGeom().Grid(g_c).LoopList(i_c).VortexStretchingRatio() = 0.;

    }
  
    // Restrict the solution to the coarse grid

    for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfLoops() ; i_f++ ) {

       i_c = VSPGeom().Grid(g_f).LoopList(i_f).CoarseGridLoop();

       VSPGeom().Grid(g_c).LoopList(i_c).Gamma() += VSPGeom().Grid(g_f).LoopList(i_f).Gamma();

       VSPGeom().Grid(g_c).LoopList(i_c).StallFactor() += VSPGeom().Grid(g_f).LoopList(i_f).StallFactor();
  
       VSPGeom().Grid(g_c).LoopList(i_c).VortexStretchingRatio() += VSPGeom().Grid(g_f).LoopList(i_f).VortexStretchingRatio();
  
    }

    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
       
       VSPGeom().Grid(g_c).LoopList(i_c).Gamma() /= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfFineGridLoops();

       VSPGeom().Grid(g_c).LoopList(i_c).StallFactor() /= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfFineGridLoops();

       VSPGeom().Grid(g_c).LoopList(i_c).VortexStretchingRatio() /= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfFineGridLoops();
       
    }

}

/*##############################################################################
#                                                                              #
#                   VSP_SOLVER RestrictVortexCoreWidthFromGrid                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestrictVortexCoreWidthFromGrid(int Level)
{
 
    int i_c, i_f, g_c, g_f;

    // Restrict solution from Level i, to level i+1
    
    g_f = Level;
    g_c = Level + 1;
    
    // Zero out stuff on the coarsest grid

    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {

       VSPGeom().Grid(g_c).LoopList(i_c).CoreWidth() = 0.;

    }
  
    // Restrict the solution to the coarse grid

    for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfLoops() ; i_f++ ) {

       i_c = VSPGeom().Grid(g_f).LoopList(i_f).CoarseGridLoop();

       VSPGeom().Grid(g_c).LoopList(i_c).CoreWidth() += VSPGeom().Grid(g_f).LoopList(i_f).CoreWidth();

    }

    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
       
       VSPGeom().Grid(g_c).LoopList(i_c).CoreWidth() /= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfFineGridLoops();
       
    }

}

/*##############################################################################
#                                                                              #
#                   VSP_SOLVER RestrictPerturbationSolutionFromGrid            #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestrictPerturbationSolutionFromGrid(int Level)
{
 
    int i_c, i_f, g_c, g_f, Node1, Node2;
    double Fact;

    // Restrict solution from Level i, to level i+1
    
    g_f = Level;
    g_c = Level + 1;
    
    // Zero out stuff on the coarsest grid

    for ( i_c = 0 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {

       VSPGeom().Grid(g_c).LoopList(i_c).dGamma() = 0.;
       
       VSPGeom().Grid(g_c).LoopList(i_c).dStallFactor() = 0.;
       
       VSPGeom().Grid(g_c).LoopList(i_c).dVortexStretchingRatio() = 0.;
       
    }

    // Restrict the delta gammas to the coarse grid
 
    for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfLoops() ; i_f++ ) {

       i_c = VSPGeom().Grid(g_f).LoopList(i_f).CoarseGridLoop();

       VSPGeom().Grid(g_c).LoopList(i_c).dGamma() += VSPGeom().Grid(g_f).LoopList(i_f).dGamma();

       VSPGeom().Grid(g_c).LoopList(i_c).dStallFactor() += VSPGeom().Grid(g_f).LoopList(i_f).dStallFactor();
  
       VSPGeom().Grid(g_c).LoopList(i_c).dVortexStretchingRatio() += VSPGeom().Grid(g_f).LoopList(i_f).dVortexStretchingRatio();
  
    }

    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
       
       VSPGeom().Grid(g_c).LoopList(i_c).dGamma() /= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfFineGridLoops();

       VSPGeom().Grid(g_c).LoopList(i_c).dStallFactor() /= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfFineGridLoops();
       
       VSPGeom().Grid(g_c).LoopList(i_c).dVortexStretchingRatio() /= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfFineGridLoops();
       
    }
        
    // Restrict delta mesh to the coarse grid
    
    for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfNodes() ; i_f++ ) {

       i_c = VSPGeom().Grid(g_f).NodeList(i_f).CoarseGridNode();

       VSPGeom().Grid(g_c).NodeList(i_c).dX() = VSPGeom().Grid(g_f).NodeList(i_f).dX();
       VSPGeom().Grid(g_c).NodeList(i_c).dY() = VSPGeom().Grid(g_f).NodeList(i_f).dY();
       VSPGeom().Grid(g_c).NodeList(i_c).dZ() = VSPGeom().Grid(g_f).NodeList(i_f).dZ();
  
    }    

    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfEdges() ; i_c++ ) {

       Node1 = VSPGeom().Grid(g_c).EdgeList(i_c).Node1();
       Node2 = VSPGeom().Grid(g_c).EdgeList(i_c).Node2();
       
       VSPGeom().Grid(g_c).EdgeList(i_c).dX1() = VSPGeom().Grid(g_c).NodeList(Node1).dX();
       VSPGeom().Grid(g_c).EdgeList(i_c).dY1() = VSPGeom().Grid(g_c).NodeList(Node1).dY();
       VSPGeom().Grid(g_c).EdgeList(i_c).dZ1() = VSPGeom().Grid(g_c).NodeList(Node1).dZ();

       VSPGeom().Grid(g_c).EdgeList(i_c).dX2() = VSPGeom().Grid(g_c).NodeList(Node2).dX();
       VSPGeom().Grid(g_c).EdgeList(i_c).dY2() = VSPGeom().Grid(g_c).NodeList(Node2).dY();
       VSPGeom().Grid(g_c).EdgeList(i_c).dZ2() = VSPGeom().Grid(g_c).NodeList(Node2).dZ();
         
    }    
    
}

/*##############################################################################
#                                                                              #
#              VSP_SOLVER RestrictAdjointSolutionFromGrid                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestrictAdjointSolutionFromGrid(int Level)
{
 
    int i_c, i_f, g_c, g_f;
    double Fact;

    // Restrict solution from Level i, to level i+1
    
    g_f = Level;
    g_c = Level + 1;
    
    // Zero out stuff on the coarsest grid

#pragma omp parallel for     
    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {

       VSPGeom().Grid(g_c).LoopList(i_c).Psi() = 0.;

    }
  
    // Restrict the adjoint solution to the coarse grid loops

    for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfLoops() ; i_f++ ) {

       i_c = VSPGeom().Grid(g_f).LoopList(i_f).CoarseGridLoop();

       VSPGeom().Grid(g_c).LoopList(i_c).Psi() += VSPGeom().Grid(g_f).LoopList(i_f).Psi();
  
    }

    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
       
       VSPGeom().Grid(g_c).LoopList(i_c).Psi() /= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfFineGridLoops();
       
    }

    // Restrict the adjoint solution to the coarse grid nodes

    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfNodes() ; i_c++ ) {

       i_f = VSPGeom().Grid(g_c).NodeList(i_c).FineGridNode();

       VSPGeom().Grid(g_c).NodeList(i_c).Psi(0) = VSPGeom().Grid(g_f).NodeList(i_f).Psi(0);
       VSPGeom().Grid(g_c).NodeList(i_c).Psi(1) = VSPGeom().Grid(g_f).NodeList(i_f).Psi(1);
       VSPGeom().Grid(g_c).NodeList(i_c).Psi(2) = VSPGeom().Grid(g_f).NodeList(i_f).Psi(2);
  
    }

}

/*##############################################################################
#                                                                              #
#                   VSP_SOLVER RestrictKTFactorFromGrid                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::RestrictKTFactorFromGrid(int Level)
{
 
    int i_c, i_f, g_c, g_f, Loop1, Loop2;
    double Fact, Area1, Area2, wgt1, wgt2;

    // Restrict solution from Level i, to level i+1
    
    g_f = Level;
    g_c = Level + 1;
    
    // Zero out stuff on the coarsest grid
    
    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {

       VSPGeom().Grid(g_c).LoopList(i_c).KTFact() = 0.;

    }
  
    // Restrict the solution to the coarse grid
 
    for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfLoops() ; i_f++ ) {

       i_c = VSPGeom().Grid(g_f).LoopList(i_f).CoarseGridLoop();
       
       Fact = VSPGeom().Grid(g_f).LoopList(i_f).Area()
            / VSPGeom().Grid(g_c).LoopList(i_c).Area();

       VSPGeom().Grid(g_c).LoopList(i_c).KTFact() += Fact*VSPGeom().Grid(g_f).LoopList(i_f).KTFact();
  
    }
    
    // Update KT Factor on the coarse grid edges

    for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfEdges() ; i_c++ ) {
    
       Loop1 = VSPGeom().Grid(g_c).EdgeList(i_c).Loop1();
       Loop2 = VSPGeom().Grid(g_c).EdgeList(i_c).Loop2();
       
       Area1 = VSPGeom().Grid(g_c).LoopList(Loop1).Area();
       Area2 = VSPGeom().Grid(g_c).LoopList(Loop1).Area();
       
       wgt2 = Area2 / ( Area1 + Area2 );
       wgt1 = 1. - wgt2;
       
       VSPGeom().Grid(g_c).EdgeList(i_c).KTFact() = wgt1 *  VSPGeom().Grid(g_c).LoopList(Loop1).KTFact() + wgt2 *  VSPGeom().Grid(g_c).LoopList(Loop2).KTFact();
       
    }
       
}


/*##############################################################################
#                                                                              #
#                       VSP_SOLVER InterpolateSolutionFromGrid                 #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::InterpolateSolutionFromGrid(int Level)
{
 
    int i, j, i_c, i_f, g_c, g_f, Edge, Iter, Node, Node1, Node2, Done;
    int *FixedNode,  NodeHits;
    double Fact, *dCp, *Denom, *Res, *Dif, *Sum, Delta, Eps, ResMax, ResMax0;
    double Wgt1, Wgt2, CpAvg;
    
    while ( Level >= 1 ) {
        
       g_c = Level;
       g_f = Level - 1;
       
       // Smooth pressure
   
       dCp = new double[VSPGeom().Grid(g_c).NumberOfNodes() + 1];
       
       Denom = new double[VSPGeom().Grid(g_c).NumberOfNodes() + 1];
       
       zero_double_array(dCp, VSPGeom().Grid(g_c).NumberOfNodes());
       
       zero_double_array(Denom, VSPGeom().Grid(g_c).NumberOfNodes());
   
       Res = new double[VSPGeom().Grid(g_c).NumberOfNodes() + 1];
       
       Dif = new double[VSPGeom().Grid(g_c).NumberOfNodes() + 1];
       
       Sum = new double[VSPGeom().Grid(g_c).NumberOfNodes() + 1];
          
       zero_double_array(Sum,VSPGeom().Grid(g_c).NumberOfNodes());
             
       // Create nodal value of CP
   
       for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
   
          for ( j = 1 ; j <= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfEdges() ; j++ ) {
           
             Edge = VSPGeom().Grid(g_c).LoopList(i_c).Edge(j);
             
             Node1 = VSPGeom().Grid(g_c).EdgeList(Edge).Node1();
             Node2 = VSPGeom().Grid(g_c).EdgeList(Edge).Node2();
             
             // Only smooth the steady component
        
             dCp[Node1] += ( VSPGeom().Grid(g_c).LoopList(i_c).dCp() - VSPGeom().Grid(g_c).LoopList(i_c).dCp_Unsteady() ) * VSPGeom().Grid(g_c).LoopList(i_c).Area();
             dCp[Node2] += ( VSPGeom().Grid(g_c).LoopList(i_c).dCp() - VSPGeom().Grid(g_c).LoopList(i_c).dCp_Unsteady() ) * VSPGeom().Grid(g_c).LoopList(i_c).Area();
                                  
             Denom[Node1] += VSPGeom().Grid(g_c).LoopList(i_c).Area();
             Denom[Node2] += VSPGeom().Grid(g_c).LoopList(i_c).Area();
             
          }
   
       }
   
       for ( j = 1 ; j <= VSPGeom().Grid(g_c).NumberOfNodes() ; j++ ) {
          
          dCp[j] /= Denom[j];
          
       }
   
       // Enforce kutta condition on trailing edge
     
       FixedNode = new int[VSPGeom().Grid(g_c).NumberOfNodes() + 1];
       
       zero_int_array(FixedNode, VSPGeom().Grid(g_c).NumberOfNodes());
   
       if ( VSPGeom().ModelType() == VLM_MODEL && Mach_ < 1. ) {
          
          for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfKuttaNodes() ; i++ ) {
      
             Node = VSPGeom().Grid(g_c).KuttaNode(i);
          
             FixedNode[Node] = 1;
      
          }
   
          for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfNodes() ; i++ ) {
             
             if ( VSPGeom().Grid(g_c).NodeList(i).IsBoundaryEdgeNode() ) FixedNode[i] = 1;
             
          }
                 
       }
       
       // Panel Model
       
       else if ( VSPGeom().ModelType() == PANEL_MODEL ) {
          
          for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfKuttaNodes() ; i++ ) {
      
             Node = VSPGeom().Grid(g_c).KuttaNode(i);
     
             FixedNode[Node] = 1;
      
          }
          
          for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfNodes() ; i++ ) {
             
             if ( VSPGeom().Grid(g_c).NodeList(i).IsBoundaryEdgeNode() ) FixedNode[i] = 1;
             
          }
          
          for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
           
             if ( LoopIsOnBaseRegion_[i_c] ) {
           
                for ( j = 1 ; j <= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfEdges() ; j++ ) {
                 
                   Edge = VSPGeom().Grid(g_c).LoopList(i_c).Edge(j);
                   
                   Node1 = VSPGeom().Grid(g_c).EdgeList(Edge).Node1();
                   Node2 = VSPGeom().Grid(g_c).EdgeList(Edge).Node2();
                
                   FixedNode[Node1] = 1;
                   FixedNode[Node2] = 1;
   
                }
                
             }
             
          }   
              
       }
       
       // Smooth the pressures
   
// djk ... edit this to stop surface pressure smoothing
   
       if ( 0&& g_c == MGLevel_ ) {
   
          // Count edge hits per node
          
          for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfEdges() ; i++ ) {
          
             // Edge to node pointers
          
             Node1 = VSPGeom().Grid(g_c).EdgeList(i).Node1();
             Node2 = VSPGeom().Grid(g_c).EdgeList(i).Node2();
          
             Sum[Node1] += 1.;
             Sum[Node2] += 1.;
            
          }
          
          // Loop over and smooth all residuals
          
          for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfNodes() ; i++ ) {
          
             Res[i] = dCp[i];
          
             Dif[i] = 0.;
          
          }
   
          // Do a few iterations of smoothing
      
          Iter = 1;
          
          Done = 0;
      
          while ( !Done && Iter <= 2 ) {
             
             ResMax = ResMax0 = 0.;
      
             // Loop over the edges and scatter fluxes
      
             for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfEdges() ; i++ ) {
      
                 // Edge to node pointers
      
                 Node1 = VSPGeom().Grid(g_c).EdgeList(i).Node1();
                 Node2 = VSPGeom().Grid(g_c).EdgeList(i).Node2();
           
                 Delta = Res[Node1] - Res[Node2];
      
                 Dif[Node1] -= Delta;
                 Dif[Node2] += Delta;
      
             }
      
             Eps = 1.;
             
             for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfNodes() ; i++ ) {
      
                if ( !FixedNode[i] ) {
      
                   Fact = Eps*Sum[i];
                   
                   Delta = ( dCp[i] + Fact*Res[i] + Eps*Dif[i] )/( 1. + Fact ) - Res[i];
                   
                   ResMax += Delta*Delta;
      
                   Res[i] += Delta;
      
                }
      
                Dif[i] = 0.;
      
             }
             
             ResMax = sqrt(ResMax/VSPGeom().Grid(g_c).NumberOfNodes());
             
             if ( Iter == 1 ) ResMax0 = ResMax;
             
             if ( ResMax0 != 0. ) {
                
                //printf("Iter: %d ... Resmax: %f \n",Iter,log10(ResMax/ResMax0));
                
                if ( log10(ResMax/ResMax0) <= -2. ) Done = 1;
                
             }  
             
             Iter++;     
                    
          }
      
          // Update nodal values with smoothed result
          
          for ( i = 1 ; i <= VSPGeom().Grid(g_c).NumberOfNodes() ; i++ ) {
      
             dCp[i] = Res[i];
      
          }           
       
          // Finally, update loop values
      
          for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
             
             NodeHits = 0;
             
             CpAvg = 0.;
      
             for ( j = 1 ; j <= VSPGeom().Grid(g_c).LoopList(i_c).NumberOfEdges() ; j++ ) {
          
                Edge = VSPGeom().Grid(g_c).LoopList(i_c).Edge(j);
                
                Node1 = VSPGeom().Grid(g_c).EdgeList(Edge).Node1();
                Node2 = VSPGeom().Grid(g_c).EdgeList(Edge).Node2();
                
                Wgt1 = Wgt2 = 0.;
                
                if ( !FixedNode[Node1] && Sum[Node1] > 0. ) { Wgt1 = 1.; NodeHits++; }
                if ( !FixedNode[Node2] && Sum[Node2] > 0. ) { Wgt2 = 1.; NodeHits++; }
                
                CpAvg += Wgt1*dCp[Node1] + Wgt2*dCp[Node2];
                
             }
      
             if ( NodeHits > 0 ) VSPGeom().Grid(g_c).LoopList(i_c).dCp() = CpAvg / NodeHits;
             
          }
   
              
       }
   
       delete [] FixedNode;
       delete [] dCp;
       delete [] Denom;
       delete [] Res;
       delete [] Dif;
       delete [] Sum;
          
       // Enforce base pressures
       
       if ( VSPGeom().ModelType() == PANEL_MODEL && g_c == MGLevel_ ) {
          
          // Base
          
          for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
             
             if ( LoopIsOnBaseRegion_[i_c] ) VSPGeom().Grid(g_c).LoopList(i_c).dCp() = CpBase_;
          
          }            
       
       }
       
       // Add back in unsteady component
       
       for ( i_c = 1 ; i_c <= VSPGeom().Grid(g_c).NumberOfLoops() ; i_c++ ) {
   
          VSPGeom().Grid(g_c).LoopList(i_c).dCp() += VSPGeom().Grid(g_c).LoopList(i_c).dCp_Unsteady();
   
       }    
   
       // Prolongate solution from coarse to fine grid
   
#pragma omp parallel for private(i_c)     
       for ( i_f = 1 ; i_f <= VSPGeom().Grid(g_f).NumberOfLoops() ; i_f++ ) {
   
          i_c = VSPGeom().Grid(g_f).LoopList(i_f).CoarseGridLoop();
   
          VSPGeom().Grid(g_f).LoopList(i_f).dCp()          = VSPGeom().Grid(g_c).LoopList(i_c).dCp();
          
          VSPGeom().Grid(g_f).LoopList(i_f).dCp_Unsteady() = VSPGeom().Grid(g_c).LoopList(i_c).dCp_Unsteady();
   
          VSPGeom().Grid(g_f).LoopList(i_f).Gamma()        = VSPGeom().Grid(g_c).LoopList(i_c).Gamma();
             
       }  
     
       Level--;
         
    }
   
}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER SmoothPrincipalPart                         #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::SmoothPrincipalPart(void)
{
 
    int i, j, k;
    double Ws, Weight, WeightSum;
    
    // Create smoothed version of principal part

    for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
       
       VSPGeom().Grid(MGLevel_).LoopList(i).Ws() = 0.;
       
       WeightSum = 0;
       
       for ( j = 1 ; j <= VSPGeom().Grid(MGLevel_).LoopList(i).NumberOfEdges() ; j ++ ) {
          
          k = VSPGeom().Grid(MGLevel_).LoopList(i).Edge(j);

          Ws = VSPGeom().Grid(MGLevel_).EdgeList(k).GeneralizedPrincipalPartOfDownWash() * VSPGeom().Grid(MGLevel_).EdgeList(k).Length() / VSPGeom().Grid(MGLevel_).LoopList(i).Area();
          
          Weight = pow(VSPGeom().Grid(MGLevel_).EdgeList(k).Length(),2.);

          if ( Ws > 0. ) {

             VSPGeom().Grid(MGLevel_).LoopList(i).Ws() += Ws*Weight;
            
             WeightSum += Weight;
             
          }
          
       }
       
       if ( WeightSum > 0. ) VSPGeom().Grid(MGLevel_).LoopList(i).Ws() /= WeightSum;
       
    }
       
}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER UpdateVortexEdgeStrengths                   #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdateVortexEdgeStrengths(int Level, int UpdateType)
{

    int i, j, k, Edge, Loop, LoopL, LoopR, Sign;
    double StallFactor, VortexStretchingRatio;

    // Copy current value over to vortex loops
    
    if ( Level == MGLevel_ ) {
     
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
        
          VSPGeom().Grid(MGLevel_).LoopList(i).Gamma() = Gamma(i);
 
       }

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
        
          VSPGeom().Grid(MGLevel_).LoopList(i).StallFactor() = 1.;

       }
         
    }
    
    // Calculate delta-gammas for each surface vortex edge for the body loops

    for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfSurfaceEdges() ; i++ ) {

       VSPGeom().Grid(Level).EdgeList(i).Gamma() = VSPGeom().Grid(Level).LoopList(VSPGeom().Grid(Level).EdgeList(i).LoopL()).Gamma()
                                                 - VSPGeom().Grid(Level).LoopList(VSPGeom().Grid(Level).EdgeList(i).LoopR()).Gamma();
   
    }    

    // Calculate wake gamma values, per kutta condition

    if ( Level == MGLevel_ ) {

       // Propagate stall factors for each trailing vortex loop
              
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             j = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaEdge();
                   
             VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor() = VSPGeom().VortexSheet(k).TrailingVortex(j).StallFactor();
  
          }
       
       }

       // Steady state solution... all wake gammas updated
               
       if ( !TimeAccurate_ ) {     
              
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                
                Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
                
                Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
   
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
   
                StallFactor = VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor();
                
                VSPGeom().Grid(MGLevel_).LoopList(Loop).StallFactor() = StallFactor;
                
                VSPGeom().Grid(MGLevel_).LoopList(Loop).Gamma() = Sign * VSPGeom().Grid(Level).EdgeList(Edge).Gamma();  
   
             }
    
          }
          
       }
       
       // Only the implicit gamma term at first bound vortex on wake is included
       
       else if ( TimeAccurate_ && UpdateType == ALL_WAKE_GAMMAS ) {
          
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                
                Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
                
                Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
   
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
   
                StallFactor = VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor();
                
                VortexStretchingRatio = VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio();
                
                if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() == 1 ) {
                
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).StallFactor() = StallFactor;
                   
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).VortexStretchingRatio() = VortexStretchingRatio;
                   
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).Gamma() = Sign * VSPGeom().Grid(Level).EdgeList(Edge).Gamma();  
                   
                }
                
                else {
                   
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).StallFactor() = StallFactor;
                   
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).VortexStretchingRatio() = VortexStretchingRatio;
                   
                }
   
             }
    
          }          
          
       }
       
       else {
          
          printf("Unknown update type for updating wake gammas... what did you do?!?!?! \n");
          fflush(NULL);
          exit(1);
          
       }
  
    }
 
    // Calculate delta-gammas for each wake vortex edge for the wake loops

    for ( i = VSPGeom().Grid(Level).NumberOfSurfaceEdges() + 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {

       LoopL = VSPGeom().Grid(Level).EdgeList(i).LoopL();
       LoopR = VSPGeom().Grid(Level).EdgeList(i).LoopR();
       
       VSPGeom().Grid(Level).EdgeList(i).Gamma() = VSPGeom().Grid(Level).LoopList(LoopL).Gamma()
                                                 * VSPGeom().Grid(Level).LoopList(LoopL).StallFactor()
                                                 * VSPGeom().Grid(Level).LoopList(LoopL).VortexStretchingRatio()
                                                 
                                                 - VSPGeom().Grid(Level).LoopList(LoopR).Gamma()
                                                 * VSPGeom().Grid(Level).LoopList(LoopR).StallFactor()
                                                 * VSPGeom().Grid(Level).LoopList(LoopR).VortexStretchingRatio();
                 
          
    }    
      
}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER UpdatePerturbationVortexEdgeStrengths              #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdatePerturbationVortexEdgeStrengths(int Level)
{

    int i, j, k, Edge, Loop, LoopL, LoopR, Node1, Node2, Sign;
    double StallFactor, dStallFactor, dVortexStretchingRatio;

    // Copy current value over to vortex loops
    
    if ( Level == MGLevel_ ) {
     
       for ( i = 0 ; i <= VSPGeom().Grid(MGLevel_).NumberOfSurfaceLoops() ; i++ ) {
        
          VSPGeom().Grid(MGLevel_).LoopList(i).dGamma() = dGamma(i);

       }

       for ( i = 0 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
        
          VSPGeom().Grid(MGLevel_).LoopList(i).dStallFactor() = 0.;
          
       }

       for ( i = 0 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
        
          VSPGeom().Grid(MGLevel_).LoopList(i).dVortexStretchingRatio() = 0.;
          
       }
              
    }
 
    // Copy current value over to nodes 
    
    if ( Level == MGLevel_ ) {
     
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfNodes() ; i++ ) {
        
          VSPGeom().Grid(MGLevel_).NodeList(i).dX() = dX(i);
          VSPGeom().Grid(MGLevel_).NodeList(i).dY() = dY(i);
          VSPGeom().Grid(MGLevel_).NodeList(i).dZ() = dZ(i);

       }

       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfEdges() ; i++ ) {
       
          Node1 = VSPGeom().Grid(MGLevel_).EdgeList(i).Node1();
          Node2 = VSPGeom().Grid(MGLevel_).EdgeList(i).Node2();

          VSPGeom().Grid(MGLevel_).EdgeList(i).dX1() = VSPGeom().Grid(MGLevel_).NodeList(Node1).dX();
          VSPGeom().Grid(MGLevel_).EdgeList(i).dY1() = VSPGeom().Grid(MGLevel_).NodeList(Node1).dY();
          VSPGeom().Grid(MGLevel_).EdgeList(i).dZ1() = VSPGeom().Grid(MGLevel_).NodeList(Node1).dZ();
       
          VSPGeom().Grid(MGLevel_).EdgeList(i).dX2() = VSPGeom().Grid(MGLevel_).NodeList(Node2).dX();
          VSPGeom().Grid(MGLevel_).EdgeList(i).dY2() = VSPGeom().Grid(MGLevel_).NodeList(Node2).dY();
          VSPGeom().Grid(MGLevel_).EdgeList(i).dZ2() = VSPGeom().Grid(MGLevel_).NodeList(Node2).dZ();
            
       }    
      
    }
        
    // Calculate delta-gammas for each surface vortex edge for the body loops

    for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfSurfaceEdges() ; i++ ) {

       VSPGeom().Grid(Level).EdgeList(i).dGamma() = VSPGeom().Grid(Level).LoopList(VSPGeom().Grid(Level).EdgeList(i).LoopL()).dGamma()
                                                  - VSPGeom().Grid(Level).LoopList(VSPGeom().Grid(Level).EdgeList(i).LoopR()).dGamma();

    }    

    // Calculate wake gamma values, per kutta condition

    if ( Level == MGLevel_ ) {

       // Propagate stall factors for each trailing vortex loop
              
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
       
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             j = VSPGeom().VortexSheet(k).WakeLoopList(i).KuttaEdge();
                   
             VSPGeom().VortexSheet(k).WakeLoopList(i).dStallFactor() = VSPGeom().VortexSheet(k).TrailingVortex(j).dStallFactor();
       
          }
       
       }     

       // Calculate delta-gammas for each trailing vortex edge
       
       if ( !TimeAccurate_ ) {       
   
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                
                Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
                
                Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
   
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
                     
                // Delta Gamma, using current stall factor value
                
                StallFactor = VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor();
   
                VSPGeom().Grid(MGLevel_).LoopList(Loop).dGamma() = Sign * VSPGeom().Grid(Level).EdgeList(Edge).dGamma();  
                
                // Delta stall gamma
                
                dStallFactor = VSPGeom().VortexSheet(k).WakeLoopList(i).dStallFactor();
   
                VSPGeom().Grid(MGLevel_).LoopList(Loop).dStallFactor() = dStallFactor;   
               
             }
    
          }
          
       }

       else {       
   
          for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
                
                Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
                
                Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
   
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
                             
                if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() == 1 ) {
   
                   // Delta Gamma
                   
                   StallFactor = VSPGeom().VortexSheet(k).WakeLoopList(i).StallFactor();
      
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).dGamma() = Sign * VSPGeom().Grid(Level).EdgeList(Edge).dGamma();  
                   
                   // Delta stall factor
                   
                   dStallFactor = VSPGeom().VortexSheet(k).WakeLoopList(i).dStallFactor();
      
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).dStallFactor() = dStallFactor;   
                    
                   // Delta vortex stretching ratio
                   
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).dVortexStretchingRatio() = 0.;   
                                                                                             
                }
                
                else {
            
                   // Delta Gamma
            
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).dGamma() = 0.;
                   
                   // Delta stall factor
                   
                   dStallFactor = VSPGeom().VortexSheet(k).WakeLoopList(i).dStallFactor();
      
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).dStallFactor() = dStallFactor;   
                    
                   // Delta vortex stretching ratio
                   
                   dVortexStretchingRatio = VSPGeom().VortexSheet(k).WakeLoopList(i).dVortexStretchingRatio();
      
                   VSPGeom().Grid(MGLevel_).LoopList(Loop).dVortexStretchingRatio() = dVortexStretchingRatio;   
   
                }                
                 
             }
    
          }
          
       }
       
    }
   
    // Calculate delta-gammas for each wake vortex edge for the wake loops

    for ( i = VSPGeom().Grid(Level).NumberOfSurfaceEdges() + 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {

       LoopL = VSPGeom().Grid(Level).EdgeList(i).LoopL();
       LoopR = VSPGeom().Grid(Level).EdgeList(i).LoopR();
         
       // Delta gamma
       
       VSPGeom().Grid(Level).EdgeList(i).dGamma() = VSPGeom().Grid(Level).LoopList(LoopL).dGamma()
                                                  * VSPGeom().Grid(Level).LoopList(LoopL).StallFactor()
                                                  * VSPGeom().Grid(Level).LoopList(LoopL).VortexStretchingRatio()
                                                  
                                                  - VSPGeom().Grid(Level).LoopList(LoopR).dGamma()
                                                  * VSPGeom().Grid(Level).LoopList(LoopR).StallFactor()
                                                  * VSPGeom().Grid(Level).LoopList(LoopR).VortexStretchingRatio();

       // Delta stall gamma
       
       VSPGeom().Grid(Level).EdgeList(i).dStallGamma() = VSPGeom().Grid(Level).LoopList(LoopL).Gamma()
                                                       * VSPGeom().Grid(Level).LoopList(LoopL).dStallFactor()
                                                       * VSPGeom().Grid(Level).LoopList(LoopL).VortexStretchingRatio()
                                                       
                                                       - VSPGeom().Grid(Level).LoopList(LoopR).Gamma()
                                                       * VSPGeom().Grid(Level).LoopList(LoopR).dStallFactor()
                                                       * VSPGeom().Grid(Level).LoopList(LoopR).VortexStretchingRatio();

       // Delta stall gamma
       
       VSPGeom().Grid(Level).EdgeList(i).dVortexStretchingRatioGamma() = VSPGeom().Grid(Level).LoopList(LoopL).Gamma()
                                                                       * VSPGeom().Grid(Level).LoopList(LoopL).StallFactor()
                                                                       * VSPGeom().Grid(Level).LoopList(LoopL).dVortexStretchingRatio()
                                                                       
                                                                       - VSPGeom().Grid(Level).LoopList(LoopR).Gamma()
                                                                       * VSPGeom().Grid(Level).LoopList(LoopR).StallFactor()
                                                                       * VSPGeom().Grid(Level).LoopList(LoopR).dVortexStretchingRatio();

                                                   
   }    

}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER UpdateVortexCoreWidths                      #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::UpdateVortexCoreWidths(int Level, int UpdateType)
{

    int i, j, k, Loop;

    // Copy current value over to vortex loops
    
    if ( Level == MGLevel_ ) {
     
       for ( i = 1; i <= VSPGeom().Grid(Level).NumberOfLoops() ; i++ ) {
       
          VSPGeom().Grid(Level).LoopList(i).CoreWidth() = 0.;
       
       }
               
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( j = 1 ; j <= VSPGeom().VortexSheet(k).NumberOfKuttaEdges() ; j++ ) {
        
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
   
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
                
                VSPGeom().Grid(Level).LoopList(Loop).CoreWidth() = VSPGeom().VortexSheet(k).CoreWidth();
   
             }
             
          }
   
       }       
       
    }
    
    // Zero out core width

    for ( i = 1; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {

       VSPGeom().Grid(Level).EdgeList(i).CoreWidth() = 0.;
   
    }    

    // Update core width on wakes

    for ( i = VSPGeom().Grid(Level).NumberOfSurfaceEdges() + 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {

       if ( !VSPGeom().Grid(Level).EdgeList(i).IsWakeTrailingEdge() ) {
      
          VSPGeom().Grid(Level).EdgeList(i).CoreWidth() = 0.5*( VSPGeom().Grid(Level).LoopList(VSPGeom().Grid(Level).EdgeList(i).LoopL()).CoreWidth()
                                                              + VSPGeom().Grid(Level).LoopList(VSPGeom().Grid(Level).EdgeList(i).LoopR()).CoreWidth() );
                                                              
       }
   
    }    

}

/*##############################################################################
#                                                                              #
#                       VSP_SOLVER ZeroVortexCoreWidths                        #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroVortexCoreWidths(int Level, int UpdateType)
{

    int i, j, k, Loop;

    // Copy current value over to vortex loops
    
    if ( Level == MGLevel_ ) {
     
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( j = 1 ; j <= VSPGeom().VortexSheet(k).NumberOfKuttaEdges() ; j++ ) {
        
             for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
   
                Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
                
                VSPGeom().Grid(Level).LoopList(Loop).CoreWidth() = 0.;
   
             }
             
          }
   
       }       
         
    }
    
    // Zero out core width

    for ( i = 1; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {

       VSPGeom().Grid(Level).EdgeList(i).CoreWidth() = 0.;
   
    }    

    // Update core width on wakes

    for ( i = VSPGeom().Grid(Level).NumberOfSurfaceEdges() + 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {

       VSPGeom().Grid(Level).EdgeList(i).CoreWidth() = 0.;
   
    }    

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER ConvectUnsteadyWakes                          #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ConvectUnsteadyWakes(void)
{

    int i, j, k, t, j1, j2, Node, Edge, Sign, Loop, UpwindWakeLoop;
    double x, y, z, StallFactor, dStallFactor;
    
    // Convect the vorticity down stream after each time step

    for ( t = Time_ + 1 ; t >= 2 ; t-- ) {
       
       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
             
             Edge = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
             
             Sign = SGN(VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalTrailingEdge());
   
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
             
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() == t ) {
             
                 UpwindWakeLoop = VSPGeom().Grid(MGLevel_).LoopList(Loop).UpwindWakeLoop();
                 
                 // Gamma

                 VSPGeom().Grid(MGLevel_).LoopList(Loop).Gamma() = VSPGeom().Grid(MGLevel_).LoopList(UpwindWakeLoop).Gamma();
          
                 // Stall factors

                 VSPGeom().Grid(MGLevel_).LoopList(Loop).StallFactor() = VSPGeom().Grid(MGLevel_).LoopList(UpwindWakeLoop).StallFactor();     
                 
                 // Loop circumference
                 
                 VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(0) = VSPGeom().Grid(MGLevel_).LoopList(UpwindWakeLoop).Circumference(0); 
                 
             }     
   
          }
   
       }
       
    }
                   
}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER ApplyVortexStretchingModel                    #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ApplyVortexStretchingModel(void)
{

    int i, k, Loop;
    double Ratio, Residual;
    
    // Store circumference of first bound vortex ring for current time step
    
    for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {

       for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
  
          Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();

          if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() == 1 ) {
             
              VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(0) = VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1);

          }     

       }

    }

    // Apply vortex stretching model
    
    if ( !ImplicitWake_ || ( ImplicitWake_ && CurrentWakeIteration_ <= ImplicitWakeStartIteration_ ) ) {

       for ( k = 1 ; k <= VSPGeom().NumberOfVortexSheets() ; k++ ) {
   
          for ( i = 1 ; i <= VSPGeom().VortexSheet(k).NumberOfWakeLoops() ; i++ ) {
     
             Loop = VSPGeom().VortexSheet(k).WakeLoopList(i).GlobalLoop();
   
             if ( VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() > 1 &&
                  VSPGeom().Grid(MGLevel_).LoopList(Loop).MinValidTimeStep() <= Time_ ) {
                                
                Residual = ABS(VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() * VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1) - VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(0));
                
                MaxResidual_ = MAX(MaxResidual_,Residual);
                
                L2Residual_ += Residual*Residual;                
                
                Ratio = VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(0) / VSPGeom().Grid(MGLevel_).LoopList(Loop).Circumference(1);
           
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() = Ratio;
   
             }     
             
             else {
                
                VSPGeom().VortexSheet(k).WakeLoopList(i).VortexStretchingRatio() = 1.;
                
             }
   
          }
   
       }
       
    }

}

/*##############################################################################
#                                                                              #
#                          VSP_SOLVER ZeroVortexState                          #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::ZeroVortexState(void)
{

    int i, j, k, Level;

    // Copy current value over to vortex loops
    
    for ( Level = 1 ; Level <= NumberOfMGLevels_ ; Level++ ) {
  
       for ( i = 1 ; i <= VSPGeom().Grid(MGLevel_).NumberOfLoops() ; i++ ) {
        
          VSPGeom().Grid(MGLevel_).LoopList(i).Gamma() = 0.;
       
       }

       // Calculate delta-gammas for each surface vortex edge
       
       for ( i = 1 ; i <= VSPGeom().Grid(Level).NumberOfEdges() ; i++ ) {
   
          VSPGeom().Grid(Level).EdgeList(i).Gamma() = 0.;
                     
       }    
       
    }

}

/*##############################################################################
#                                                                              #
#                      VSP_SOLVER OutputStatusFile                             #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::OutputStatusFile(int FinalIteration)
{

    int i;
    double E, Ewake, AR, ToQS, Time, LoD, LoDwake, CurrentCPUTime;

    CurrentCPUTime = myclock() - StartSolveTime_;
             
    AR = Bref_ * Bref_ / Sref_;

    ToQS = 0.;
    
    for ( i = 1 ; i <= NumberOfRotors_ ; i++ ) {
     
       if ( Verbose_ ) printf("RotorDisk(%d).RotorThrust(): %f \n",i,RotorDisk(i).RotorThrust());
            
       ToQS += RotorDisk(i).RotorThrust() / ( 0.5 * Density_ * Vref_ * Vref_ * Sref_);
       
    }    
 
    E = Ewake = 0.;
    
    if ( CDi() > 0. && ( ( !TimeAccurate_ && CurrentWakeIteration_ > 1 ) || CurrentWakeIteration_ == WakeIterations_ || ( TimeAccurate_ && Time_ > 1 ) ) ) E = (CLi() * CLi() /(PI * AR)) / CDi() ;
 
    if ( CDiw() > 0. && ( ( !TimeAccurate_ && CurrentWakeIteration_ > 1 ) || CurrentWakeIteration_ == WakeIterations_ ||  ( TimeAccurate_ && Time_ > 1 ) ) ) Ewake = (CLiw() * CLiw() /(PI * AR)) / CDiw() ;

    LoD = LoDwake = 0.;
    
    if ( CDo() + CDi() > 0. && ( ( !TimeAccurate_ && CurrentWakeIteration_ > 1 ) || CurrentWakeIteration_ == WakeIterations_ ||  ( TimeAccurate_ && Time_ > 1 )) ) LoD = CLi()/(CDo() + CDi());
       
    if ( CDo() + CDiw() > 0. && ( ( !TimeAccurate_ && CurrentWakeIteration_ > 1 ) || CurrentWakeIteration_ == WakeIterations_ ||  ( TimeAccurate_ && Time_ > 1 )) ) LoDwake = CLiw()/(CDo() + CDiw());

    if ( !TimeAccurate_ ) {
   
       fprintf(StatusFile_,"%16d %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf \n",
               CurrentWakeIteration_,
               Mach_,
               double(AngleOfAttack_/TORAD),
               double(AngleOfBeta_/TORAD),               
               CLo(),               
               CLi(),
               double(CLi() + CLo()),
               CDo(),
               CDi(),
               double(CDo() + CDi()),
               CSo(),
               CSi(),
               double(CSo() + CSi()),            
               LoD,
               E,     
               CMox(),
               CMoy(),
               CMoz(),                             
               CMix(),
               CMiy(),
               CMiz(),
               double(CMox() + CMix()),
               double(CMoy() + CMiy()),            
               double(CMoz() + CMiz()),       
               CFox(),            
               CFoy(),            
               CFoz(),  
               CFix(),            
               CFiy(),            
               CFiz(),                                 
               double(CFox() + CFix()),            
               double(CFoy() + CFiy()),            
               double(CFoz() + CFiz()),                     

               double(CLiw() + CLo()),
               double(CDiw() + CDo()),
               double(CSiw() + CSo()),

               
               CLiw(),
               CDiw(),
               CSiw(),
               
               double(CFox() + CFiwx()),            
               double(CFoy() + CFiwy()),            
               double(CFoz() + CFiwz()),    
                             
               CFiwx(),
               CFiwy(),
               CFiwz(),
               
               LoDwake,
               Ewake,                           
               ToQS,
               log10(L2Residual_),
               log10(MaxResidual_),
               CurrentCPUTime);

       printf("%9d %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf \n",
               CurrentWakeIteration_,
               Mach_,
               double(AngleOfAttack_/TORAD),
               double(AngleOfBeta_/TORAD),               
               CLo(),               
               CLi(),
               double(CLi() + CLo()),
               CDo(),
               CDi(),
               double(CDo() + CDi()),  
               LoD,
               E,     
               double(CMox() + CMix()),
               double(CMoy() + CMiy()),            
               double(CMoz() + CMiz()),               
               CLiw(),
               CDiw(),
               LoDwake,
               Ewake,                           
               ToQS,
               log10(L2Residual_),
               log10(MaxResidual_),
               CurrentCPUTime);
                
    }
    
    else {
    
       if ( FinalIteration ) {
       
          fprintf(StatusFile_,"%16d %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf \n",
                  Time_,
                  Mach_,
                  double(AngleOfAttack_/TORAD),
                  double(AngleOfBeta_/TORAD),               
                  CLo(),               
                  CLi(),
                  double(CLi() + CLo()),
                  CDo(),
                  CDi(),
                  double(CDo() + CDi()),
                  CSo(),
                  CSi(),
                  double(CSo() + CSi()),            
                  LoD,
                  E,     
                  CMox(),
                  CMoy(),
                  CMoz(),                             
                  CMix(),
                  CMiy(),
                  CMiz(),
                  double(CMox() + CMix()),
                  double(CMoy() + CMiy()),            
                  double(CMoz() + CMiz()),       
                  CFox(),            
                  CFoy(),            
                  CFoz(),  
                  CFix(),            
                  CFiy(),            
                  CFiz(),                                 
                  double(CFox() + CFix()),            
                  double(CFoy() + CFiy()),            
                  double(CFoz() + CFiz()),                     
                  CLiw(),
                  CDiw(),
                  CSiw(),
                  CFiwx(),
                  CFiwy(),
                  CFiwz(),
                  LoDwake,
                  Ewake,                           
                  ToQS,
                  log10(L2Residual_),
                  log10(MaxResidual_),
                  CurrentCPUTime);
                  
       }

       if ( FinalIteration ) {
          
          printf("%9d %9d %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf \n",
                  Time_,
                  CurrentWakeIteration_,
                  Mach_,
                  double(AngleOfAttack_/TORAD),
                  double(AngleOfBeta_/TORAD),               
                  CLo(),               
                  CLi(),
                  double(CLi() + CLo()),
                  CDo(),
                  CDi(),
                  double(CDo() + CDi()),  
                  LoD,
                  E,     
                  double(CMox() + CMix()),
                  double(CMoy() + CMiy()),            
                  double(CMoz() + CMiz()),               
                  CLiw(),
                  CDiw(),
                  LoDwake,
                  Ewake,                           
                  ToQS,
                  log10(L2Residual_),
                  log10(MaxResidual_),
                  CurrentCPUTime);
                  
       }
       
       else {
          
          printf("%9d %9d %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf %9.5lf \r",
                  Time_,
                  CurrentWakeIteration_,
                  Mach_,
                  double(AngleOfAttack_/TORAD),
                  double(AngleOfBeta_/TORAD),               
                  CLo(),               
                  CLi(),
                  double(CLi() + CLo()),
                  CDo(),
                  CDi(),
                  double(CDo() + CDi()),  
                  LoD,
                  E,     
                  double(CMox() + CMix()),
                  double(CMoy() + CMiy()),            
                  double(CMoz() + CMiz()),               
                  CLiw(),
                  CDiw(),
                  LoDwake,
                  Ewake,                           
                  ToQS,
                  log10(L2Residual_),
                  log10(MaxResidual_),
                  CurrentCPUTime);

       }          
                    
    }       

}

/*##############################################################################
#                                                                              #
#                     VSP_SOLVER WriteCaseHeader                               #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteCaseHeader(FILE *fid)
{
    char headerFormatStr[] = "%-20s %12s %-20s\n";
    char dataFormatStr[] =   "%-20s %12.7lf %-20s\n";
    
    fprintf(fid,"\n");
    fprintf(fid,"***************************************************************************************************************************************************************************************** \n");
    fprintf(fid,"\n");
    
    //          123456789012345678901234567890123456789
    fprintf(fid,headerFormatStr, "# Name", "Value   ", "  Units");
    fprintf(fid,dataFormatStr, "Sref_", Sref(), "Lunit^2");
    fprintf(fid,dataFormatStr, "Cref_", Cref(), "Lunit");
    fprintf(fid,dataFormatStr, "Bref_", Bref(), "Lunit");
    fprintf(fid,dataFormatStr, "Xcg_", Xcg(), "Lunit");
    fprintf(fid,dataFormatStr, "Ycg_", Ycg(), "Lunit");
    fprintf(fid,dataFormatStr, "Zcg_", Zcg(), "Lunit");
    fprintf(fid,dataFormatStr, "Mach_", Mach(), "no_unit");
    fprintf(fid,dataFormatStr, "AoA_", float(AngleOfAttack()/TORAD), "deg");
    fprintf(fid,dataFormatStr, "Beta_", float(AngleOfBeta()/TORAD), "deg");
    fprintf(fid,dataFormatStr, "Rho_", Density(), "Munit/Lunit^3");
    fprintf(fid,dataFormatStr, "Vinf_", Vinf(), "Lunit/Tunit");
    fprintf(fid,dataFormatStr, "Roll__Rate", RotationalRate_p(), "rad/Tunit");
    fprintf(fid,dataFormatStr, "Pitch_Rate", RotationalRate_q(), "rad/Tunit");
    fprintf(fid,dataFormatStr, "Yaw___Rate", RotationalRate_r(), "rad/Tunit");
    /*
    char control_name[20];
    for ( int n = 1 ; n <= NumberOfControlGroups_ ; n++ ) {
        //                    1234567890123456789
        sprintf(control_name,"Control_Group_%-5d",n);
        fprintf(fid,dataFormatStr, control_name, Delta_Control_, "deg");
    }
    */
    
    fprintf(fid,"\n");
}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER CalculateLeadingEdgeSuctionFraction                #
#                                                                              #
##############################################################################*/

double VSP_SOLVER::CalculateLeadingEdgeSuctionFraction(double Mach, double ToC, double RoC, double EtaToC, double AoA, double Sweep)
{
   
   double Rin, RoCn, ToCn, Machn, Betan, Ctn;
   double e1, e2, e3, Ptt, k, Kt;
   
   // Normal RoC
   
   RoCn = RoC / pow(cos(Sweep),2.);
   
   // Normal ToC
   
   ToCn = ToC / cos(Sweep);   

   // Normal Leading edge radius index
   
   Rin = RoCn * EtaToC / pow(ToCn,2.);
   
   // Exponents
   
   e1 =  0.40*pow(Rin,0.16) - 0.7;
   e2 =  1.60*pow(Rin,0.10) - 3.0;
   e3 = -0.32*pow(Rin,0.10) - 0.3;
   
   // Normal Mach
   
   Machn = Mach * cos(Sweep);
   
   // Catch supersonic case
   
   if ( Machn >= 1. ) return 0.;   
   
   // Betan
   
   Betan = sqrt(1. - pow(Machn,2.));
   
   // Ctn
   
   Ctn = 2.*PI*pow(sin(AoA),2.) / ( Betan * pow(cos(Sweep),3.) );
   
   // Ptt
   
   Ptt = Ctn * Betan * pow( ToCn * pow(EtaToC/0.5,e1) / 0.09, e2);
   
   // k
   
   k = ( 0.14*(1. - (1. - sqrt(Rin)*pow(Machn,5.))) + 0.11*sqrt(Rin))*pow((1.-Machn)/Machn,0.48*(1.+pow(Rin,0.3)));
   
   // Kt

   Kt = (1. + sqrt(pow(ToCn,1.2))) * k * pow(Ptt,e3);
   
   Kt = MAX(0.,MIN(Kt,1.));
   
   return Kt;
 
}

/*##############################################################################
#                                                                              #
#                VSP_SOLVER OutputForcesAndMomentsForGroup                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::OutputForcesAndMomentsForGroup(int Group)
{
   
    int c, k, i, j, t, ComponentID;
    double Thrust, Thrusto, Thrusti, Moment, Momento, Momenti, Power, Powero, Poweri;
    double CT, CQ, CP, EtaP, CT_h, CQ_h, CP_h, FOM;
    double J, Diameter, RPM, Time;
    double Omega, Radius, TipVelocity, Area, Vec[3];

    // Loop over component groups, calculate rotor coefficients if any are
    // flagged as being rotors by the user.

    k = 0;
    
    for ( c = 0 ; c <= VSPGeom().NumberOfComponentGroups() ; c++ ) {
        
       // Write out group data

       Time = CurrentTime_;
       
       if ( NoiseAnalysis_ ) Time = CurrentNoiseTime_ + NoiseTimeShift_;

       if ( !TimeAccurate_ ) Time = CurrentWakeIteration_;
       
       if ( Group == 0 || c == Group ) {
          
          // Write out forces and moments

          fprintf(GroupFile_[c],"%16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf \n",

                  Time,
                  VSPGeom().ComponentGroupList(c).CFix() + VSPGeom().ComponentGroupList(c).CFox(),
                  VSPGeom().ComponentGroupList(c).CFiy() + VSPGeom().ComponentGroupList(c).CFoy(),
                  VSPGeom().ComponentGroupList(c).CFiz() + VSPGeom().ComponentGroupList(c).CFoz(),
                  VSPGeom().ComponentGroupList(c).CFox(),
                  VSPGeom().ComponentGroupList(c).CFoy(),
                  VSPGeom().ComponentGroupList(c).CFoz(),
                  VSPGeom().ComponentGroupList(c).CFix(),
                  VSPGeom().ComponentGroupList(c).CFiy(),
                  VSPGeom().ComponentGroupList(c).CFiz(),                                    
                  VSPGeom().ComponentGroupList(c).CMix() + VSPGeom().ComponentGroupList(c).CMox(),
                  VSPGeom().ComponentGroupList(c).CMiy() + VSPGeom().ComponentGroupList(c).CMoy(),
                  VSPGeom().ComponentGroupList(c).CMiz() + VSPGeom().ComponentGroupList(c).CMoz(),
                  VSPGeom().ComponentGroupList(c).CMox(),
                  VSPGeom().ComponentGroupList(c).CMoy(),
                  VSPGeom().ComponentGroupList(c).CMoz(),
                  VSPGeom().ComponentGroupList(c).CMix(),
                  VSPGeom().ComponentGroupList(c).CMiy(),
                  VSPGeom().ComponentGroupList(c).CMiz(),                                    
                  VSPGeom().ComponentGroupList(c).CLi() + VSPGeom().ComponentGroupList(c).CLo(),
                  VSPGeom().ComponentGroupList(c).CDi() + VSPGeom().ComponentGroupList(c).CDo(),
                  VSPGeom().ComponentGroupList(c).CSi() + VSPGeom().ComponentGroupList(c).CSo(),
                  VSPGeom().ComponentGroupList(c).CLo(),
                  VSPGeom().ComponentGroupList(c).CDo(),   
                  VSPGeom().ComponentGroupList(c).CSo(),                     
                  VSPGeom().ComponentGroupList(c).CLi(),                  
                  VSPGeom().ComponentGroupList(c).CDi(),
                  VSPGeom().ComponentGroupList(c).CSi(),
                  VSPGeom().ComponentGroupList(c).CFiwx() + VSPGeom().ComponentGroupList(c).CFox(),
                  VSPGeom().ComponentGroupList(c).CFiwy() + VSPGeom().ComponentGroupList(c).CFoy(),
                  VSPGeom().ComponentGroupList(c).CFiwz() + VSPGeom().ComponentGroupList(c).CFoz(),
                  VSPGeom().ComponentGroupList(c).CFiwx(),
                  VSPGeom().ComponentGroupList(c).CFiwy(),
                  VSPGeom().ComponentGroupList(c).CFiwz(),                        
                  VSPGeom().ComponentGroupList(c).CLiw() + VSPGeom().ComponentGroupList(c).CLo(),
                  VSPGeom().ComponentGroupList(c).CDiw() + VSPGeom().ComponentGroupList(c).CDo(),
                  VSPGeom().ComponentGroupList(c).CSiw() + VSPGeom().ComponentGroupList(c).CSo(),
                  VSPGeom().ComponentGroupList(c).CLiw(),                  
                  VSPGeom().ComponentGroupList(c).CDiw(),
                  VSPGeom().ComponentGroupList(c).CSiw());    
                              
          // Write out time averaged forces for time accurate solutions

          if ( TimeAccurate_ && Time_ == NumberOfTimeSteps_  ) {
             
             VSPGeom().ComponentGroupList(c).CalculateAverageForcesAndMoments(StartAveragingTimeStep_);

             fprintf(GroupFile_[c],"\n\n");
             fprintf(GroupFile_[c],"Time averaged forces and moments: \n");
             fprintf(GroupFile_[c],"\n");

             fprintf(GroupFile_[c],"%16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf %16.12lf \n",

                     Time,
                     VSPGeom().ComponentGroupList(c).CFix_avg() + VSPGeom().ComponentGroupList(c).CFox_avg(),
                     VSPGeom().ComponentGroupList(c).CFiy_avg() + VSPGeom().ComponentGroupList(c).CFoy_avg(),
                     VSPGeom().ComponentGroupList(c).CFiz_avg() + VSPGeom().ComponentGroupList(c).CFoz_avg(),
                     VSPGeom().ComponentGroupList(c).CFox_avg(),
                     VSPGeom().ComponentGroupList(c).CFoy_avg(),
                     VSPGeom().ComponentGroupList(c).CFoz_avg(),
                     VSPGeom().ComponentGroupList(c).CFix_avg(),
                     VSPGeom().ComponentGroupList(c).CFiy_avg(),
                     VSPGeom().ComponentGroupList(c).CFiz_avg(),                                    
                     VSPGeom().ComponentGroupList(c).CMix_avg() + VSPGeom().ComponentGroupList(c).CMox_avg(),
                     VSPGeom().ComponentGroupList(c).CMiy_avg() + VSPGeom().ComponentGroupList(c).CMoy_avg(),
                     VSPGeom().ComponentGroupList(c).CMiz_avg() + VSPGeom().ComponentGroupList(c).CMoz_avg(),
                     VSPGeom().ComponentGroupList(c).CMox_avg(),
                     VSPGeom().ComponentGroupList(c).CMoy_avg(),
                     VSPGeom().ComponentGroupList(c).CMoz_avg(),
                     VSPGeom().ComponentGroupList(c).CMix_avg(),
                     VSPGeom().ComponentGroupList(c).CMiy_avg(),
                     VSPGeom().ComponentGroupList(c).CMiz_avg(),                                    
                     VSPGeom().ComponentGroupList(c).CLo_avg() + VSPGeom().ComponentGroupList(c).CLi_avg(),
                     VSPGeom().ComponentGroupList(c).CDo_avg() + VSPGeom().ComponentGroupList(c).CDi_avg(),
                     VSPGeom().ComponentGroupList(c).CSo_avg() + VSPGeom().ComponentGroupList(c).CSi_avg(),                        
                     VSPGeom().ComponentGroupList(c).CLo_avg(),
                     VSPGeom().ComponentGroupList(c).CDo_avg(),   
                     VSPGeom().ComponentGroupList(c).CSo_avg(),                           
                     VSPGeom().ComponentGroupList(c).CLi_avg(),                  
                     VSPGeom().ComponentGroupList(c).CDi_avg(),
                     VSPGeom().ComponentGroupList(c).CSi_avg(),
                     VSPGeom().ComponentGroupList(c).CFiwx_avg() + VSPGeom().ComponentGroupList(c).CFox_avg(),
                     VSPGeom().ComponentGroupList(c).CFiwy_avg() + VSPGeom().ComponentGroupList(c).CFoy_avg(),
                     VSPGeom().ComponentGroupList(c).CFiwz_avg() + VSPGeom().ComponentGroupList(c).CFoz_avg(),
                     VSPGeom().ComponentGroupList(c).CFiwx_avg(),
                     VSPGeom().ComponentGroupList(c).CFiwy_avg(),
                     VSPGeom().ComponentGroupList(c).CFiwz_avg(),                        
                     VSPGeom().ComponentGroupList(c).CLiw_avg() + VSPGeom().ComponentGroupList(c).CLo_avg(),
                     VSPGeom().ComponentGroupList(c).CDiw_avg() + VSPGeom().ComponentGroupList(c).CDo_avg(),
                     VSPGeom().ComponentGroupList(c).CSiw_avg() + VSPGeom().ComponentGroupList(c).CSo_avg(),
                     VSPGeom().ComponentGroupList(c).CLiw_avg(),                  
                     VSPGeom().ComponentGroupList(c).CDiw_avg(),
                     VSPGeom().ComponentGroupList(c).CSiw_avg());                            
                     
          }    
                                                        
          // Write out rotor data
          
          if ( VSPGeom().ComponentGroupList(c).GeometryIsARotor() ) {
           
             k++;

             Diameter = VSPGeom().ComponentGroupList(c).RotorDiameter();
             
             RPM = VSPGeom().ComponentGroupList(c).Omega() * 60 / ( 2.*PI );
             
             Vec[0] = VSPGeom().ComponentGroupList(c).CFox() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
             Vec[1] = VSPGeom().ComponentGroupList(c).CFoy() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
             Vec[2] = VSPGeom().ComponentGroupList(c).CFoz() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
             
             Thrusto = vector_dot(Vec, VSPGeom().ComponentGroupList(c).RVec());
             
             Vec[0] = VSPGeom().ComponentGroupList(c).CFix() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
             Vec[1] = VSPGeom().ComponentGroupList(c).CFiy() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
             Vec[2] = VSPGeom().ComponentGroupList(c).CFiz() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
             
             Thrusti = vector_dot(Vec, VSPGeom().ComponentGroupList(c).RVec());
                 
             Thrust = Thrusto + Thrusti;

             // Moments
             
             Vec[0] = VSPGeom().ComponentGroupList(c).CMox() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Bref_;
             Vec[1] = VSPGeom().ComponentGroupList(c).CMoy() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Cref_;
             Vec[2] = VSPGeom().ComponentGroupList(c).CMoz() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Bref_;   
             
             Momento = -vector_dot(Vec, VSPGeom().ComponentGroupList(c).RVec());
               
             Vec[0] = VSPGeom().ComponentGroupList(c).CMix() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Bref_;
             Vec[1] = VSPGeom().ComponentGroupList(c).CMiy() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Cref_;
             Vec[2] = VSPGeom().ComponentGroupList(c).CMiz() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Bref_;   
             
             Momenti = -vector_dot(Vec, VSPGeom().ComponentGroupList(c).RVec());

             Moment = Momento + Momenti;

             // Power
             
             Powero = Momento * VSPGeom().ComponentGroupList(c).Omega();
             
             Poweri  = Momenti * VSPGeom().ComponentGroupList(c).Omega();

             Power = Powero + Poweri;
             
             CalculateRotorCoefficientsFromForces(Thrust, Moment, Diameter, RPM, J, CT, CQ, CP, EtaP, CT_h, CQ_h, CP_h, FOM);                                                    
                        
             Time = CurrentTime_;
          
             if ( NoiseAnalysis_ ) Time = CurrentNoiseTime_ + NoiseTimeShift_;
             
             if ( !TimeAccurate_ ) Time = CurrentWakeIteration_;
                                  //  1      2      3      4      5      6      7      8      9     10     11     12     13     14     15     16     17     18     19   
             fprintf(RotorFile_[k],"%10.5f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f \n",
                      Time,
                      Diameter,
                      RPM,
                      Thrust,
                      Thrusto,
                      Thrusti,
                      Power,
                      Powero,
                      Poweri,
                      Moment,
                      Momento,
                      Momenti,
                      J,
                      CT,
                      CQ,
                      CP,
                      EtaP,
                      CT_h,
                      CQ_h,
                      CP_h,
                      FOM,
                      VSPGeom().ComponentGroupList(c).TotalRotationAngle()/TORAD);                           
                 
             if ( ( TimeAccurate_ && Time_ == NumberOfTimeSteps_ ) ) {
                       
                Diameter = VSPGeom().ComponentGroupList(c).RotorDiameter();
                
                RPM = VSPGeom().ComponentGroupList(c).Omega() * 60 / ( 2.*PI );

                Vec[0] = VSPGeom().ComponentGroupList(c).CFox_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
                Vec[1] = VSPGeom().ComponentGroupList(c).CFoy_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
                Vec[2] = VSPGeom().ComponentGroupList(c).CFoz_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
                
                Thrusto = vector_dot(Vec, VSPGeom().ComponentGroupList(c).RVec());
                
                
                Vec[0] = VSPGeom().ComponentGroupList(c).CFix_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
                Vec[1] = VSPGeom().ComponentGroupList(c).CFiy_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
                Vec[2] = VSPGeom().ComponentGroupList(c).CFiz_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_;
                
                Thrusti = vector_dot(Vec, VSPGeom().ComponentGroupList(c).RVec());
                    
                Thrust = Thrusto + Thrusti;
                
                // Moments
                
                Vec[0] = VSPGeom().ComponentGroupList(c).CMox_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Bref_;
                Vec[1] = VSPGeom().ComponentGroupList(c).CMoy_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Cref_;
                Vec[2] = VSPGeom().ComponentGroupList(c).CMoz_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Bref_;   
                
                Momento = -vector_dot(Vec, VSPGeom().ComponentGroupList(c).RVec());
                  
                Vec[0] = VSPGeom().ComponentGroupList(c).CMix_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Bref_;
                Vec[1] = VSPGeom().ComponentGroupList(c).CMiy_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Cref_;
                Vec[2] = VSPGeom().ComponentGroupList(c).CMiz_avg() * 0.5 * Density_ * Vref_ * Vref_ * Sref_ * Bref_;   
                
                Momenti = -vector_dot(Vec, VSPGeom().ComponentGroupList(c).RVec());
                
                Moment = Momento + Momenti;
                
                // Power
                
                Powero = Momento * VSPGeom().ComponentGroupList(c).Omega();
                
                Poweri  = Momenti * VSPGeom().ComponentGroupList(c).Omega();
                
                Power = Powero + Poweri;
                
                CalculateRotorCoefficientsFromForces(Thrust, Moment, Diameter, RPM, J, CT, CQ, CP, EtaP, CT_h, CQ_h, CP_h, FOM);                                                    

                fprintf(RotorFile_[k],"\n\n");
                fprintf(RotorFile_[k],"Time averaged results: \n");
                fprintf(RotorFile_[k],"\n");
                                                 //  1      2      3      4      5      6      7      8      9     10     11     12     13     14     15     16     17     18     19     20     21      
                fprintf(RotorFile_[k],"           %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.3f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f %10.5f \n",
                        Diameter,
                        RPM,
                        Thrust,
                        Thrusto,
                        Thrusti,
                        Power,
                        Powero,
                        Poweri,                        
                        Moment,
                        Momento,
                        Momenti,
                        J,
                        CT,
                        CQ,
                        CP,
                        EtaP,
                        CT_h,
                        CQ_h,
                        CP_h,
                        FOM,
                        float(VSPGeom().ComponentGroupList(c).TotalRotationAngle()/TORAD));
 
             }
                               
          }
         
       }
      
    }

}

/*##############################################################################
#                                                                              #
#                  VSP_SOLVER CalculateRotorCoefficients                       #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::CalculateRotorCoefficientsFromForces(double Thrust, double Moment, double Diameter, double RPM,
                                                      double &J, double &CT, double &CQ, double &CP, double &EtaP,
                                                      double &CT_h, double &CQ_h, double &CP_h, double &FOM)
{
   
    double n, Omega, Radius, Area, TipVelocity;

    // Revs per second
    
    n = RPM / 60.;
    
    // Advance ratio
    
    J = Vinf_ / (n * Diameter);

    // Propeller coefficients
    
    CT = Thrust / ( Density_ * n * n * pow(Diameter, 4.) );
    CQ = Moment / ( Density_ * n * n * pow(Diameter, 5.) );
    CP = 2.*PI*CQ;
        
    EtaP = J * CT / (2.*PI*CQ);
    
    // Rotor (Helicopter) coefficients
    
    Omega = 2. * PI * RPM / 60.;
    
    Radius = 0.5 * Diameter;
    
    Area = PI * Radius * Radius;
    
    TipVelocity = Omega * Radius;
    
    CT_h = Thrust / ( Density_ * Area * pow(TipVelocity, 2.) );
    CQ_h = Moment / ( Density_ * Area * pow(TipVelocity, 2.) * Radius );
    CP_h = CQ_h;
    
    FOM = 0.;
    
    if ( CT_h > 0. ) FOM = pow(CT_h, 1.5)/(sqrt(2.)*CP_h);

}

/*##############################################################################
#                                                                              #
#                         VSP_SOLVER WriteOutCart3dTriFile                     #
#                                                                              #
##############################################################################*/

void VSP_SOLVER::WriteOutCart3dTriFile(void)
{

    int i;
    char Cart3DFileName[MAX_CHAR_SIZE];
    FILE *Cart3dFile;
    
    // Open the cart3d file
    
    snprintf(Cart3DFileName,sizeof(Cart3DFileName)*sizeof(char),"%s.vspaero.tri",FileName_);
    
    if ( (Cart3dFile = fopen(Cart3DFileName, "w")) == NULL ) {
    
       printf("Could not open the cart3d file for output! \n");
    
       exit(1);
    
    }    

    fprintf(Cart3dFile,"%d %d \n",
            VSPGeom().Grid().NumberOfNodes(),
            VSPGeom().Grid().NumberOfLoops());

    // Write out node data

    for ( i = 1 ; i <= VSPGeom().Grid().NumberOfNodes() ; i++ ) {

       fprintf(Cart3dFile,"%f %f %f \n",
               VSPGeom().Grid().NodeList(i).x(),
               VSPGeom().Grid().NodeList(i).y(),
               VSPGeom().Grid().NodeList(i).z());
                                         
    }

         
    // Write out triangulated surface mesh

    for ( i = 1 ; i <= VSPGeom().Grid().NumberOfLoops() ; i++ ) {

       fprintf(Cart3dFile,"%d %d %d \n",
               VSPGeom().Grid().LoopList(i).Node1(),
               VSPGeom().Grid().LoopList(i).Node2(),
               VSPGeom().Grid().LoopList(i).Node3());
               
    }

    for ( i = 1 ; i <= VSPGeom().Grid().NumberOfLoops() ; i++ ) {

       fprintf(Cart3dFile,"%d \n",
               VSPGeom().Grid().LoopList(i).SurfaceID());

    }

}

#include "END_NAME_SPACE.H"
 
